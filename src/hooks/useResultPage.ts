import { useState, useEffect, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import type { GroupingResult, Participant } from '@/utils/grouping'
import { migrateParticipantData } from '@/utils/grouping'
import { createSnapshot } from '@/utils/backup'

export function useResultPage() {
  const router = useRouter()
  const [result, setResult] = useState<GroupingResult | null>(null)
  const [participants, setParticipants] = useState<Participant[]>([])
  const [exitedParticipants, setExitedParticipants] = useState<{[id: string]: {name: string, gender: 'male' | 'female'}}>({})
  const [activeTab, setActiveTab] = useState<'groups' | 'stats' | 'seating' | 'history'>('groups')
  const [isMobile, setIsMobile] = useState(false)
  const [checkInStatus, setCheckInStatus] = useState<{[participantId: string]: boolean}>({})

  // Round management
  const [availableRounds, setAvailableRounds] = useState<number[]>([])
  const [selectedHistoryRound, setSelectedHistoryRound] = useState<number | null>(null)
  const [historyResult, setHistoryResult] = useState<GroupingResult | null>(null)
  const [selectedGroupsRound, setSelectedGroupsRound] = useState<number | null>(null)
  const [groupsRoundResult, setGroupsRoundResult] = useState<GroupingResult | null>(null)

  // Participant editing
  const [editingParticipant, setEditingParticipant] = useState<string | null>(null)
  const [editForm, setEditForm] = useState({
    name: '',
    gender: 'male' as 'male' | 'female',
    mbti: 'extrovert' as 'extrovert' | 'introvert'
  })

  // Participant addition
  const [showAddForm, setShowAddForm] = useState<number | null>(null)
  const [newParticipant, setNewParticipant] = useState({
    name: '',
    gender: 'male' as 'male' | 'female',
    mbti: 'extrovert' as 'extrovert' | 'introvert'
  })

  // Drag and drop / mobile interaction
  const [draggedParticipant, setDraggedParticipant] = useState<{id: string, fromGroupId: number} | null>(null)
  const [swapMessage, setSwapMessage] = useState<string | null>(null)
  const [selectedParticipant, setSelectedParticipant] = useState<string | null>(null)
  const [swapSelectedParticipant, setSwapSelectedParticipant] = useState<{id: string, groupId: number} | null>(null)
  
  // Broadcast Ï±ÑÎÑê Ïù∏Ïä§ÌÑ¥Ïä§Î•º Ï†ÄÏû•
  const [broadcastChannel, setBroadcastChannel] = useState<any>(null)

  // Initial data loading
  const loadData = useCallback(async () => {
    try {
      const { 
        getGroupingResult, 
        getParticipants, 
        getExitedParticipants,
        getCurrentMeetingId,
        getAllRounds,
        checkTableStructure
      } = await import('@/utils/database')
      
      const meetingId = getCurrentMeetingId()
      if (!meetingId) {
        console.log('ÌôúÏÑ± Î™®ÏûÑÏù¥ ÏóÜÏäµÎãàÎã§.')
        router.push('/')
        return
      }
      
      console.log('üì• Í≤∞Í≥º ÌéòÏù¥ÏßÄ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...')
      
      await checkTableStructure()
      
      const [groupingResult, participants, exitedParticipants, rounds] = await Promise.all([
        getGroupingResult(),
        getParticipants(),
        getExitedParticipants(),
        getAllRounds()
      ])
      
      if (groupingResult && participants.length > 0) {
        setExitedParticipants(exitedParticipants)
        
        const migratedParticipants = migrateParticipantData(participants, groupingResult.round || 1)
        
        setResult(groupingResult)
        setParticipants(migratedParticipants)
        setAvailableRounds(rounds)
        
        // Ï≤¥ÌÅ¨Ïù∏ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        const initialCheckInStatus: {[participantId: string]: boolean} = {}
        migratedParticipants.forEach(participant => {
          initialCheckInStatus[participant.id] = participant.isCheckedIn || false
        })
        setCheckInStatus(initialCheckInStatus)
        
        console.log('‚úÖ Í≤∞Í≥º ÌéòÏù¥ÏßÄ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å')
      } else {
        console.log('Í∑∏Î£π Î∞∞Ïπò Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§. Î©îÏù∏ ÌéòÏù¥ÏßÄÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§.')
        router.push('/')
      }
    } catch (error) {
      console.error('‚ùå Í≤∞Í≥º ÌéòÏù¥ÏßÄ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë Ïò§Î•ò:', error)
      router.push('/')
    }
  }, [router])

  // Mobile detection
  useEffect(() => {
    const checkIsMobile = () => {
      setIsMobile(window.innerWidth <= 768)
    }
    
    checkIsMobile()
    window.addEventListener('resize', checkIsMobile)
    return () => window.removeEventListener('resize', checkIsMobile)
  }, [])

  // Load data on mount
  useEffect(() => {
    loadData()
  }, [loadData])

  // Supabase BroadcastÎ°ú Ïã§ÏãúÍ∞Ñ Ï≤¥ÌÅ¨Ïù∏ ÏÉÅÌÉú ÎèôÍ∏∞Ìôî
  useEffect(() => {
    if (!result) return

    const setupBroadcast = async () => {
      try {
        const { getCurrentMeetingId } = await import('@/utils/database')
        const { createSupabaseClient } = await import('@/lib/supabase')
        const supabase = createSupabaseClient()
        const meetingId = getCurrentMeetingId()
        
        if (!supabase || !meetingId) {
          console.log('Supabase ÎòêÎäî Î™®ÏûÑ IDÍ∞Ä ÏóÜÏñ¥ÏÑú Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏Î•º ÏÑ§Ï†ïÌïòÏßÄ ÏïäÏäµÎãàÎã§.')
          return
        }

        const channelName = `checkin-${meetingId}`
        console.log('üì° Supabase Broadcast Ï±ÑÎÑê Íµ¨ÎèÖ ÏãúÏûë:', channelName)
        console.log('üîç ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥:', { meetingId, participantCount: participants.length })
        
        const channel = supabase
          .channel(channelName)
          .on('broadcast', { event: 'checkin-update' }, (payload: any) => {
            console.log('üéØ [ÏàòÏã†] Ï≤¥ÌÅ¨Ïù∏ ÏóÖÎç∞Ïù¥Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏:', {
              Ï†ÑÏ≤¥_payload: payload,
              event: payload.event,
              payload_ÎÇ¥Ïö©: payload.payload
            })
            
            if (payload.payload && payload.payload.participantId !== undefined && payload.payload.isChecked !== undefined) {
              const { participantId, isChecked } = payload.payload
              
              setCheckInStatus(prev => {
                console.log('üîÑ Ï≤¥ÌÅ¨Ïù∏ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏:', { 
                  participantId, 
                  Í∏∞Ï°¥: prev[participantId], 
                  ÏÉàÎ°úÏö¥Í∞í: isChecked 
                })
                return {
                  ...prev,
                  [participantId]: isChecked
                }
              })
              
              const participantName = participants.find(p => p.id === participantId)?.name
              console.log(`‚úÖ ${participantName}Ïùò Ï≤¥ÌÅ¨Ïù∏ ÏÉÅÌÉúÍ∞Ä ${isChecked ? 'Ï≤¥ÌÅ¨Îê®' : 'Ìï¥Ï†úÎê®'}ÏúºÎ°ú Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞ÌôîÎê®`)
            } else {
              console.warn('‚ö†Ô∏è Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ ÌéòÏù¥Î°úÎìú Íµ¨Ï°∞Í∞Ä ÏòàÏÉÅÍ≥º Îã§Î¶Ñ:', payload)
            }
          })
          .on('broadcast', { event: 'checkin-reset-all' }, (payload: any) => {
            console.log('üéØ [ÏàòÏã†] Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏:', payload)
            
            if (payload.payload && payload.payload.resetAll) {
              const resetStatus: {[participantId: string]: boolean} = {}
              participants.forEach(p => {
                resetStatus[p.id] = false
              })
              setCheckInStatus(resetStatus)
              
              console.log('‚úÖ Ï†ÑÏ≤¥ Ï≤¥ÌÅ¨Ïù∏ ÏÉÅÌÉúÍ∞Ä Ï¥àÍ∏∞ÌôîÎê®')
            }
          })
          .subscribe((status) => {
            console.log('üì° Broadcast Ï±ÑÎÑê ÏÉÅÌÉú Î≥ÄÍ≤Ω:', { status, channelName })
            if (status === 'SUBSCRIBED') {
              console.log('‚úÖ Broadcast Ï±ÑÎÑê Íµ¨ÎèÖ ÏÑ±Í≥µ!', channelName)
              setBroadcastChannel(channel) // Ï±ÑÎÑê Ïù∏Ïä§ÌÑ¥Ïä§ Ï†ÄÏû•
            } else if (status === 'CHANNEL_ERROR') {
              console.error('‚ùå Broadcast Ï±ÑÎÑê Ïò§Î•ò:', channelName)
            } else if (status === 'TIMED_OUT') {
              console.error('‚ùå Broadcast Ï±ÑÎÑê ÌÉÄÏûÑÏïÑÏõÉ:', channelName)
            }
          })

        return () => {
          console.log('üì° Broadcast Ï±ÑÎÑê Íµ¨ÎèÖ Ìï¥Ï†ú')
          setBroadcastChannel(null)
          channel.unsubscribe()
        }
      } catch (error) {
        console.error('‚ùå Broadcast ÏÑ§Ï†ï Ï§ë Ïò§Î•ò:', error)
      }
    }

    const cleanup = setupBroadcast()
    
    return () => {
      cleanup?.then(cleanupFn => cleanupFn?.())
    }
  }, [result, participants])

  // Round selection functions
  const selectHistoryRound = useCallback(async (round: number) => {
    try {
      const { getGroupingResultByRound } = await import('@/utils/database')
      const roundResult = await getGroupingResultByRound(round)
      
      if (roundResult) {
        setSelectedHistoryRound(round)
        setHistoryResult(roundResult)
        console.log(`${round}ÎùºÏö¥Îìú ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú ÏôÑÎ£å`)
      } else {
        console.log(`${round}ÎùºÏö¥Îìú Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`)
      }
    } catch (error) {
      console.error('ÌûàÏä§ÌÜ†Î¶¨ ÎùºÏö¥Îìú Î°úÎìú Ï§ë Ïò§Î•ò:', error)
    }
  }, [])

  const selectGroupsRound = useCallback(async (round: number) => {
    try {
      const { getGroupingResultByRound } = await import('@/utils/database')
      const roundResult = await getGroupingResultByRound(round)
      
      if (roundResult) {
        setSelectedGroupsRound(round)
        setGroupsRoundResult(roundResult)
        console.log(`${round}ÎùºÏö¥Îìú Í≤∞Í≥º Î°úÎìú ÏôÑÎ£å`)
      } else {
        console.log(`${round}ÎùºÏö¥Îìú Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`)
      }
    } catch (error) {
      console.error('Í∑∏Î£π ÎùºÏö¥Îìú Î°úÎìú Ï§ë Ïò§Î•ò:', error)
    }
  }, [])

  const returnToCurrentRound = useCallback(() => {
    setSelectedGroupsRound(null)
    setGroupsRoundResult(null)
  }, [])

  // Check-in functions with DB + Broadcast
  const toggleCheckIn = useCallback(async (participantId: string) => {
    try {
      const currentStatus = checkInStatus[participantId] || false
      const newStatus = !currentStatus
      
      // 1. Ï¶âÏãú Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (ÎÇôÍ¥ÄÏ†Å ÏóÖÎç∞Ïù¥Ìä∏)
      setCheckInStatus(prev => ({
        ...prev,
        [participantId]: newStatus
      }))
      
      // 2. DBÏóê Ï†ÄÏû•
      const { updateParticipantCheckIn, getCurrentMeetingId } = await import('@/utils/database')
      const success = await updateParticipantCheckIn(participantId, newStatus)
      
      if (success) {
        // 3. Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏Î°ú Îã§Î•∏ ÏÇ¨Ïö©ÏûêÎì§ÏóêÍ≤å ÏïåÎ¶º
        try {
          if (broadcastChannel) {
            const broadcastData = {
              type: 'broadcast',
              event: 'checkin-update',
              payload: {
                participantId,
                isChecked: newStatus
              }
            }
            
            console.log('üì§ [Ï†ÑÏÜ°] Ï†ÄÏû•Îêú Ï±ÑÎÑêÎ°ú Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï†ÑÏÜ° ÏãúÏûë:', { broadcastData })
            
            const sendResult = await broadcastChannel.send(broadcastData)
            
            const participantName = participants.find(p => p.id === participantId)?.name
            console.log(`üì§ [Ï†ÑÏÜ°] ${participantName}Ïùò Ï≤¥ÌÅ¨Ïù∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï†ÑÏÜ° Í≤∞Í≥º:`, sendResult)
          } else {
            console.warn('‚ö†Ô∏è Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï±ÑÎÑêÏù¥ ÏïÑÏßÅ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏùå')
          }
        } catch (broadcastError) {
          console.error('‚ùå Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï†ÑÏÜ° Ïã§Ìå®:', broadcastError)
        }
      } else {
        // DB Ï†ÄÏû• Ïã§Ìå® Ïãú Î°úÏª¨ ÏÉÅÌÉú ÎêòÎèåÎ¶¨Í∏∞
        setCheckInStatus(prev => ({
          ...prev,
          [participantId]: currentStatus
        }))
        
        const participantName = participants.find(p => p.id === participantId)?.name
        console.log(`${participantName}Ïùò Ï≤¥ÌÅ¨Ïù∏ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå® (Î°úÏª¨ÏóêÏÑúÎßå ÏûëÎèô)`)
      }
    } catch (error) {
      console.error('Ï≤¥ÌÅ¨Ïù∏ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error)
      
      // Ïò§Î•ò Î∞úÏÉù Ïãú Î°úÏª¨ ÏÉÅÌÉú ÎêòÎèåÎ¶¨Í∏∞
      setCheckInStatus(prev => ({
        ...prev,
        [participantId]: checkInStatus[participantId] || false
      }))
    }
  }, [checkInStatus, participants])

  const resetAllCheckIn = useCallback(async () => {
    console.log('üîÑ [ÏãúÏûë] resetAllCheckIn Ìï®Ïàò Ìò∏Ï∂úÎê®')
    console.log('üì° [ÌôïÏù∏] broadcastChannel ÏÉÅÌÉú:', { 
      exists: !!broadcastChannel, 
      type: typeof broadcastChannel,
      participantCount: participants.length 
    })
    
    try {
      const { resetAllCheckInStatus, getCurrentMeetingId } = await import('@/utils/database')
      console.log('üíæ [ÏãúÏûë] DBÏóêÏÑú Ï†ÑÏ≤¥ Ï≤¥ÌÅ¨Ïù∏ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî ÏãúÎèÑ')
      
      const success = await resetAllCheckInStatus()
      console.log('üíæ [Í≤∞Í≥º] DB Ï¥àÍ∏∞Ìôî Í≤∞Í≥º:', success)
      
      if (success) {
        // Î°úÏª¨ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        const resetStatus: {[participantId: string]: boolean} = {}
        participants.forEach(p => {
          resetStatus[p.id] = false
        })
        setCheckInStatus(resetStatus)
        console.log('‚úÖ Î°úÏª¨ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å')
        
        // Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
        console.log('üì° [ÏãúÏûë] Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï†ÑÏÜ° ÏãúÎèÑ')
        try {
          if (broadcastChannel) {
            console.log('üì° [ÌôïÏù∏] Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï±ÑÎÑê Ï°¥Ïû¨Ìï®, Ï†ÑÏÜ° ÏãúÏûë')
            
            const broadcastData = {
              type: 'broadcast',
              event: 'checkin-reset-all',
              payload: { resetAll: true }
            }
            console.log('üì§ [Ï†ÑÏÜ°] Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞:', broadcastData)
            
            const sendResult = await broadcastChannel.send(broadcastData)
            console.log('üì° [Í≤∞Í≥º] Ï†ÑÏ≤¥ Ï≤¥ÌÅ¨Ïù∏ Ï¥àÍ∏∞Ìôî Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï†ÑÏÜ° ÏôÑÎ£å:', sendResult)
          } else {
            console.warn('‚ö†Ô∏è [Í≤ΩÍ≥†] Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï±ÑÎÑêÏù¥ nullÏûÑ - Ï†ÑÏÜ°ÌïòÏßÄ ÏïäÏùå')
          }
        } catch (broadcastError) {
          console.error('‚ùå [Ïò§Î•ò] Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï†ÑÏÜ° Ïã§Ìå®:', broadcastError)
        }
      } else {
        console.error('‚ùå [Ïò§Î•ò] DB Ï¥àÍ∏∞Ìôî Ïã§Ìå®Î°ú Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï†ÑÏÜ°ÌïòÏßÄ ÏïäÏùå')
      }
    } catch (error) {
      console.error('‚ùå [Ïò§Î•ò] Ï†ÑÏ≤¥ Ï≤¥ÌÅ¨Ïù∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error)
    }
  }, [participants, broadcastChannel])

  return {
    // State
    result,
    participants,
    exitedParticipants,
    activeTab,
    isMobile,
    checkInStatus,
    availableRounds,
    selectedHistoryRound,
    historyResult,
    selectedGroupsRound,
    groupsRoundResult,
    editingParticipant,
    editForm,
    showAddForm,
    newParticipant,
    draggedParticipant,
    swapMessage,
    selectedParticipant,
    swapSelectedParticipant,
    
    // Setters
    setResult,
    setParticipants,
    setActiveTab,
    setEditingParticipant,
    setEditForm,
    setShowAddForm,
    setNewParticipant,
    setDraggedParticipant,
    setSwapMessage,
    setSelectedParticipant,
    setSwapSelectedParticipant,
    
    // Functions
    loadData,
    selectHistoryRound,
    selectGroupsRound,
    returnToCurrentRound,
    toggleCheckIn,
    resetAllCheckIn,
    router
  }
}