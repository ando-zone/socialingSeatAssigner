'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { createOptimalGroups, updateMeetingHistory, migrateParticipantData, type GenderConstraint } from '@/utils/grouping'
import { exportToJSON, importFromJSON, getSnapshots, restoreSnapshot } from '@/utils/backup'

// Components
import ParticipantManager from '@/components/ParticipantManager'
import GroupingSettings from '@/components/GroupingSettings'
import GroupingActions from '@/components/GroupingActions'
import BackupManager from '@/components/BackupManager'

// Hooks
import { useParticipants } from '@/hooks/useParticipants'
import { useGroupingSettings } from '@/hooks/useGroupingSettings'

export default function Home() {
  const router = useRouter()
  
  // Custom hooks
  const {
    participants,
    setParticipants,
    addParticipant,
    removeParticipant,
    bulkAddParticipants
  } = useParticipants()
  
  const {
    groupingMode,
    groupSize,
    numGroups,
    customGroupSizes,
    customGroupGenders,
    enableGenderRatio,
    groupSettingsLoaded,
    setGroupingMode,
    setGroupSize,
    setNumGroups,
    setCustomGroupSizes,
    setCustomGroupGenders,
    setEnableGenderRatio,
    setGroupSettingsLoaded,
    handleNumGroupsChange,
    handleGroupSizeChange,
    handleGroupMaleCountChange,
    handleGroupFemaleCountChange,
    saveGroupSettings
  } = useGroupingSettings()

  // Local states
  const [currentRound, setCurrentRound] = useState(1)
  const [isLoading, setIsLoading] = useState(false)
  const [snapshots, setSnapshots] = useState<any[]>([])
  const [isInitialLoad, setIsInitialLoad] = useState(true)
  const [hasExistingResult, setHasExistingResult] = useState(false)
  const [isClient, setIsClient] = useState(false)
  const [currentMeeting, setCurrentMeeting] = useState<any>(null)

  // Check if running on client side
  useEffect(() => {
    setIsClient(true)
  }, [])

  // Data loading effect
  useEffect(() => {
    if (!isClient || !isInitialLoad) return

    const checkUrlMeetingId = async () => {
      try {
        const urlParams = new URLSearchParams(window.location.search)
        const urlMeetingId = urlParams.get('meeting')
        
        if (urlMeetingId) {
          const { createSupabaseClient, getCurrentMeetingId, setCurrentMeetingId, getUserMeetings } = await import('@/utils/database')
          const supabase = createSupabaseClient()
          
          if (supabase) {
            const { data: { user } } = await supabase.auth.getUser()
            if (user) {
              const userMeetings = await getUserMeetings(user.id)
              const targetMeeting = userMeetings.find(m => m.id === urlMeetingId)
              
              if (targetMeeting) {
                setCurrentMeetingId(urlMeetingId)
                console.log('URLÏóêÏÑú Î™®ÏûÑ ÏÑ§Ï†ïÎê®:', urlMeetingId)
              }
            }
          }
          
          // URLÏóêÏÑú meeting ÌååÎùºÎØ∏ÌÑ∞ Ï†úÍ±∞
          window.history.replaceState({}, document.title, window.location.pathname)
        }
      } catch (error) {
        console.error('URL Î™®ÏûÑ ID Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò:', error)
      }
    }

    const loadData = async () => {
      try {
        const {
          getCurrentMeetingId,
          getCurrentMeeting,
          getParticipants,
          getGroupingResult,
          getGroupSettings
        } = await import('@/utils/database')
        
        const meetingId = getCurrentMeetingId()
        if (!meetingId) {
          console.log('ÌôúÏÑ± Î™®ÏûÑÏù¥ ÏóÜÏäµÎãàÎã§.')
          setIsInitialLoad(false)
          return
        }

        const meeting = await getCurrentMeeting()
        setCurrentMeeting(meeting)
        
        console.log('üì• SupabaseÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...')
        
        const [participants, groupingResult, groupSettings] = await Promise.all([
          getParticipants(),
          getGroupingResult(),
          getGroupSettings()
        ])

        console.log('üîç Î°úÎìúÎêú Îç∞Ïù¥ÌÑ∞:', {
          participantsCount: participants.length,
          hasGroupingResult: !!groupingResult,
          groupSettingsLoaded: !!groupSettings,
          groupSettings: groupSettings
        })
        
        setHasExistingResult(!!groupingResult)
        
        // Ï∞∏Í∞ÄÏûê Îç∞Ïù¥ÌÑ∞ ÏÑ§Ï†ï
        if (participants.length > 0) {
          const currentRound = groupingResult?.round ? groupingResult.round + 1 : 1
          const migratedParticipants = migrateParticipantData(participants, currentRound)
          setParticipants(migratedParticipants)
          setCurrentRound(currentRound)
          console.log('‚úÖ Ï∞∏Í∞ÄÏûê Îç∞Ïù¥ÌÑ∞ Î°úÎìú:', migratedParticipants.length + 'Î™Ö')
        }
        
        // Í∑∏Î£π ÏÑ§Ï†ï Î≥µÏõê
        if (groupSettings) {
          console.log('Ï†ÄÏû•Îêú Í∑∏Î£π ÏÑ§Ï†ï Î≥µÏõê:', groupSettings)
          setGroupingMode(groupSettings.groupingMode || 'manual')
          setGroupSize(groupSettings.groupSize || 4)
          setNumGroups(groupSettings.numGroups || 6)
          setCustomGroupSizes(groupSettings.customGroupSizes || Array(groupSettings.numGroups || 6).fill(groupSettings.groupSize || 4))
          
          // ÏÑ±ÎπÑ ÏÑ§Ï†ï Î≥µÏõê
          if (groupSettings.customGroupGenders) {
            setCustomGroupGenders(groupSettings.customGroupGenders)
          } else {
            const localGenders = localStorage.getItem('seatAssigner_customGroupGenders')
            if (localGenders) {
              try {
                setCustomGroupGenders(JSON.parse(localGenders))
              } catch (e) {
                const numGroups = groupSettings.numGroups || 6
                const defaultMale = Math.ceil((groupSettings.groupSize || 4) * 0.6)
                const defaultFemale = (groupSettings.groupSize || 4) - defaultMale
                setCustomGroupGenders(Array(numGroups).fill({maleCount: defaultMale, femaleCount: defaultFemale}))
              }
            } else {
              const numGroups = groupSettings.numGroups || 6
              const defaultMale = Math.ceil((groupSettings.groupSize || 4) * 0.6)
              const defaultFemale = (groupSettings.groupSize || 4) - defaultMale
              setCustomGroupGenders(Array(numGroups).fill({maleCount: defaultMale, femaleCount: defaultFemale}))
            }
          }
          
          setEnableGenderRatio(groupSettings.enableGenderRatio || false)
        } else {
          // localStorageÏóêÏÑú ÏÑ§Ï†ï Î≥µÏõê ÏãúÎèÑ
          const localGroupSizes = localStorage.getItem('seatAssigner_customGroupSizes')
          const localNumGroups = localStorage.getItem('seatAssigner_numGroups')
          const localGroupSize = localStorage.getItem('seatAssigner_groupSize')
          
          if (localGroupSizes) {
            try {
              setCustomGroupSizes(JSON.parse(localGroupSizes))
            } catch (e) {
              const numGroups = localNumGroups ? parseInt(localNumGroups) : 6
              const groupSize = localGroupSize ? parseInt(localGroupSize) : 4
              setCustomGroupSizes(Array(numGroups).fill(groupSize))
            }
          } else {
            const numGroups = localNumGroups ? parseInt(localNumGroups) : 6
            const groupSize = localGroupSize ? parseInt(localGroupSize) : 4
            setCustomGroupSizes(Array(numGroups).fill(groupSize))
          }
        }
        
        setGroupSettingsLoaded(true)
      } catch (error) {
        console.error('‚ùå Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë Ïò§Î•ò:', error)
      } finally {
        setIsInitialLoad(false)
      }
    }

    checkUrlMeetingId().then(loadData)
  }, [isClient, isInitialLoad, setParticipants, setGroupingMode, setGroupSize, setNumGroups, setCustomGroupSizes, setCustomGroupGenders, setEnableGenderRatio, setGroupSettingsLoaded])

  // Save settings when they change
  useEffect(() => {
    if (!isInitialLoad && groupSettingsLoaded) {
      saveGroupSettings()
    }
  }, [groupingMode, groupSize, numGroups, customGroupSizes, customGroupGenders, enableGenderRatio, isInitialLoad, groupSettingsLoaded, saveGroupSettings])

  // Grouping function
  const handleGrouping = async () => {
    if (participants.length < 2) {
      alert('ÏµúÏÜå 2Î™Ö Ïù¥ÏÉÅÏùò Ï∞∏Í∞ÄÏûêÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.')
      return
    }

    if (groupingMode === 'manual') {
      const totalCustomSize = customGroupSizes.reduce((sum, size) => sum + size, 0)
      if (participants.length > totalCustomSize) {
        alert(`Ï∞∏Í∞ÄÏûê Ïàò(${participants.length}Î™Ö)Í∞Ä ÏÑ§Ï†ïÎêú Í∑∏Î£π Ï¥ù Ïù∏Ïõê(${totalCustomSize}Î™Ö)Î≥¥Îã§ ÎßéÏäµÎãàÎã§. Í∑∏Î£π ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.`)
        return
      }
    }

    setIsLoading(true)
    
    try {
      const groupSizeParam = groupingMode === 'auto' ? groupSize : customGroupSizes
      
      // ÏÑ±ÎπÑ Ï†úÏïΩ Ï°∞Í±¥ Ï§ÄÎπÑ
      let genderConstraints: GenderConstraint[] | undefined = undefined
      console.log('üîç ÏÑ±ÎπÑ ÏÑ§Ï†ï Ï≤¥ÌÅ¨:', { groupingMode, enableGenderRatio, customGroupGenders })
      
      if (groupingMode === 'manual' && enableGenderRatio) {
        genderConstraints = customGroupGenders.map(gender => ({
          maleCount: gender.maleCount,
          femaleCount: gender.femaleCount
        }))
        console.log('üéØ ÏÑ±ÎπÑ Ï†úÏïΩ Ï°∞Í±¥ Ï†ÅÏö©:', genderConstraints)
      } else {
        console.log('‚ùå ÏÑ±ÎπÑ Ï†úÏïΩ Ï°∞Í±¥ ÎπÑÌôúÏÑ±Ìôî - groupingMode:', groupingMode, 'enableGenderRatio:', enableGenderRatio)
      }
      
      const result = createOptimalGroups(participants, groupSizeParam, currentRound, genderConstraints)
      const updatedParticipants = updateMeetingHistory(participants, result.groups, currentRound)
      
      const nextRound = currentRound + 1
      
      // Supabase Ï†ÄÏû•
      const { getCurrentMeetingId, saveParticipants, saveGroupingResult } = await import('@/utils/database')
      const meetingId = getCurrentMeetingId()
      
      if (meetingId) {
        await Promise.all([
          saveParticipants(updatedParticipants),
          saveGroupingResult(result)
        ])
        console.log('‚úÖ Í∑∏Î£πÌïë Í≤∞Í≥º Ï†ÄÏû• ÏôÑÎ£å')
      }
      
      setParticipants(updatedParticipants)
      setCurrentRound(nextRound)
      
      router.push('/result')
    } catch (error) {
      console.error('Í∑∏Î£πÌïë Ï§ë Ïò§Î•ò:', error)
      alert('Í∑∏Î£πÌïë Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + (error as Error).message)
    } finally {
      setIsLoading(false)
    }
  }

  // Regroup current round
  const regroupCurrentRound = async () => {
    if (participants.length < 2) return

    setIsLoading(true)
    
    try {
      const reGroupRound = currentRound - 1
      
      // ÌòÑÏû¨ ÎùºÏö¥Îìú Í∏∞Î°ùÏùÑ Ï†úÍ±∞Ìïú Ï∞∏Í∞ÄÏûêÎì§
      const participantsForRegroup = participants.map(p => {
        const newMeetingsByRound = { ...p.meetingsByRound }
        delete newMeetingsByRound[reGroupRound]
        
        const allMet = new Set<string>()
        Object.values(newMeetingsByRound).forEach(roundMeetings => {
          if (Array.isArray(roundMeetings)) {
            roundMeetings.forEach(personId => allMet.add(personId))
          }
        })
        const newAllMetPeople = Array.from(allMet)
        
        return {
          ...p,
          meetingsByRound: newMeetingsByRound,
          allMetPeople: newAllMetPeople
        }
      })

      const groupSizeParam = groupingMode === 'auto' ? groupSize : customGroupSizes
      let genderConstraints: GenderConstraint[] | undefined = undefined
      if (groupingMode === 'manual' && enableGenderRatio) {
        genderConstraints = customGroupGenders.map(gender => ({
          maleCount: gender.maleCount,
          femaleCount: gender.femaleCount
        }))
      }

      const result = createOptimalGroups(participantsForRegroup, groupSizeParam, reGroupRound, genderConstraints)
      const updatedParticipants = updateMeetingHistory(participantsForRegroup, result.groups, reGroupRound)

      // Supabase Ï†ÄÏû•
      const { saveParticipants, saveGroupingResult } = await import('@/utils/database')
      await Promise.all([
        saveParticipants(updatedParticipants),
        saveGroupingResult(result)
      ])

      setParticipants(updatedParticipants)
      router.push('/result')
    } catch (error) {
      console.error('Ïû¨Í∑∏Î£πÌïë Ï§ë Ïò§Î•ò:', error)
      alert('Ïû¨Í∑∏Î£πÌïë Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + (error as Error).message)
    } finally {
      setIsLoading(false)
    }
  }

  // Export data
  const handleExportData = async () => {
    try {
      const jsonData = await exportToJSON()
      const blob = new Blob([jsonData], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `socialingSeatAssigner_${new Date().toISOString().slice(0, 10)}.json`
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)
      alert('Îç∞Ïù¥ÌÑ∞Í∞Ä JSON ÌååÏùºÎ°ú ÎÇ¥Î≥¥ÎÇ¥Ï°åÏäµÎãàÎã§!')
    } catch (error) {
      console.error('Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®:', error)
      alert('Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
    }
  }

  // Import data
  const handleImportData = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return

    try {
      const fileContent = await file.text()
      const result = await importFromJSON(fileContent)
      
      if (result.success) {
        alert('Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Í∞ÄÏ†∏ÏôÄÏ°åÏäµÎãàÎã§!')
        
        // Í≤∞Í≥ºÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
        const { getGroupingResult } = await import('@/utils/database')
        const groupingResult = await getGroupingResult()
        setHasExistingResult(!!groupingResult)
        
        // ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®ÏúºÎ°ú Îç∞Ïù¥ÌÑ∞ Îã§Ïãú Î°úÎìú
        window.location.reload()
      } else {
        alert(`Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®: ${result.error}`)
      }
    } catch (error) {
      console.error('Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error)
      alert('Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
    }
    event.target.value = ''
  }

  // Restore snapshot
  const handleRestoreSnapshot = async (snapshotId: number) => {
    if (!confirm('Ïù¥ Ïä§ÎÉÖÏÉ∑ÏúºÎ°ú Î≥µÏõêÌïòÏãúÍ≤†ÏäµÎãàÍπå? ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞Í∞Ä ÎçÆÏñ¥ÏîåÏõåÏßëÎãàÎã§.')) return
    
    try {
      const success = await restoreSnapshot(snapshotId)
      if (success) {
        alert('Ïä§ÎÉÖÏÉ∑Ïù¥ Î≥µÏõêÎêòÏóàÏäµÎãàÎã§!')
        
        // Í≤∞Í≥ºÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
        const { getGroupingResult } = await import('@/utils/database')
        const groupingResult = await getGroupingResult()
        setHasExistingResult(!!groupingResult)
        
        // ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®ÏúºÎ°ú Îç∞Ïù¥ÌÑ∞ Îã§Ïãú Î°úÎìú
        window.location.reload()
      } else {
        alert('Ïä§ÎÉÖÏÉ∑ Î≥µÏõêÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
      }
    } catch (error) {
      console.error('Ïä§ÎÉÖÏÉ∑ Î≥µÏõê Ïã§Ìå®:', error)
      alert('Ïä§ÎÉÖÏÉ∑ Î≥µÏõêÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
    }
  }

  // Refresh snapshots
  const refreshSnapshots = async () => {
    try {
      const allSnapshots = await getSnapshots()
      setSnapshots(allSnapshots)
    } catch (error) {
      console.error('Ïä§ÎÉÖÏÉ∑ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®:', error)
    }
  }

  // New meeting
  const handleNewMeeting = async () => {
    const confirmMsg = 'ÏÉà Î™®ÏûÑÏùÑ ÏãúÏûëÌïòÎ©¥ ÌòÑÏû¨ Î™®Îì† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÇ≠Ï†úÎê©ÎãàÎã§.\n' +
                      'Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.\n\n' +
                      'Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?'
    
    if (!confirm(confirmMsg)) return
    
    try {
      const { clearCurrentMeetingData } = await import('@/utils/database')
      const cleared = await clearCurrentMeetingData()
      
      if (cleared) {
        alert('ÏÉà Î™®ÏûÑÏù¥ ÏãúÏûëÎêòÏóàÏäµÎãàÎã§!')
        window.location.reload()
      } else {
        alert('ÏÉà Î™®ÏûÑ ÏãúÏûëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
      }
    } catch (error) {
      console.error('ÏÉà Î™®ÏûÑ ÏãúÏûë Ïã§Ìå®:', error)
      alert('ÏÉà Î™®ÏûÑ ÏãúÏûëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
    }
  }

  const handleAddParticipant = async (participantData: {
    name: string
    gender: 'male' | 'female'
    mbti: 'extrovert' | 'introvert'
  }) => {
    await addParticipant(participantData)
  }

  const handleBulkAdd = async (bulkText: string) => {
    await bulkAddParticipants(bulkText)
  }

  // Don't render anything on server side
  if (!isClient) {
    return null
  }

  return (
    <div className="min-h-screen bg-gray-100">
      <div className="container mx-auto px-4 py-8 max-w-6xl">
        <div className="text-center mb-8">
          <h1 className="text-4xl font-bold text-gray-800 mb-2">
            ü™ë ÏÜåÏÖúÎßÅ Ï¢åÏÑù Î∞∞Ï†ï ÎèÑÍµ¨
          </h1>
          <p className="text-gray-600">
            Ï∞∏Í∞ÄÏûêÎì§Ïùò ÏÉàÎ°úÏö¥ ÎßåÎÇ®ÏùÑ ÏµúÏ†ÅÌôîÌïòÎäî Ïä§ÎßàÌä∏Ìïú Í∑∏Î£π Î∞∞Ïπò ÎèÑÍµ¨
          </p>
          {currentMeeting && (
            <div className="mt-2 text-sm text-blue-600">
              ÌòÑÏû¨ Î™®ÏûÑ: {currentMeeting.name}
            </div>
          )}
        </div>

        <div className="space-y-8">
          {/* Ï∞∏Í∞ÄÏûê Í¥ÄÎ¶¨ */}
          <ParticipantManager
            participants={participants}
            onAddParticipant={handleAddParticipant}
            onRemoveParticipant={removeParticipant}
            onBulkAdd={handleBulkAdd}
            currentRound={currentRound}
          />

          {/* Í∑∏Î£π ÏÑ§Ï†ï */}
          <GroupingSettings
            groupingMode={groupingMode}
            groupSize={groupSize}
            numGroups={numGroups}
            customGroupSizes={customGroupSizes}
            customGroupGenders={customGroupGenders}
            enableGenderRatio={enableGenderRatio}
            participantCount={participants.length}
            onGroupingModeChange={setGroupingMode}
            onGroupSizeChange={setGroupSize}
            onNumGroupsChange={handleNumGroupsChange}
            onCustomGroupSizeChange={handleGroupSizeChange}
            onCustomGroupMaleCountChange={handleGroupMaleCountChange}
            onCustomGroupFemaleCountChange={handleGroupFemaleCountChange}
            onEnableGenderRatioChange={setEnableGenderRatio}
          />

          {/* Í∑∏Î£πÌïë Ïï°ÏÖò */}
          <div className="bg-white rounded-lg shadow-md p-6">
            <GroupingActions
              participantCount={participants.length}
              hasExistingResult={hasExistingResult}
              isLoading={isLoading}
              onStartGrouping={handleGrouping}
              onRegroupCurrent={regroupCurrentRound}
              onViewResults={() => router.push('/result')}
              groupingMode={groupingMode}
              customGroupSizes={customGroupSizes}
            />
          </div>

          {/* Î∞±ÏóÖ Í¥ÄÎ¶¨ */}
          <BackupManager
            snapshots={snapshots}
            onExportData={handleExportData}
            onImportData={handleImportData}
            onRestoreSnapshot={handleRestoreSnapshot}
            onRefreshSnapshots={refreshSnapshots}
            onNewMeeting={handleNewMeeting}
          />
        </div>
      </div>
    </div>
  )
}