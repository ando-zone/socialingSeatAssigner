"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/grouping.ts":
/*!*******************************!*\
  !*** ./src/utils/grouping.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOptimalGroups: () => (/* binding */ createOptimalGroups),\n/* harmony export */   updateMeetingHistory: () => (/* binding */ updateMeetingHistory)\n/* harmony export */ });\n// 두 참가자가 이전에 만났는지 확인\nfunction haveMet(p1, p2) {\n    var _p1_metPeople;\n    return ((_p1_metPeople = p1.metPeople) === null || _p1_metPeople === void 0 ? void 0 : _p1_metPeople.includes(p2.id)) || false;\n}\n// 그룹의 균형 점수 계산 (높을수록 좋음)\nfunction calculateGroupBalance(group) {\n    if (group.length === 0) return 0;\n    const maleCount = group.filter((p)=>p.gender === 'male').length;\n    const femaleCount = group.filter((p)=>p.gender === 'female').length;\n    const extrovertCount = group.filter((p)=>p.mbti === 'extrovert').length;\n    const introvertCount = group.filter((p)=>p.mbti === 'introvert').length;\n    // 성별 균형 점수 (0-1)\n    const genderBalance = 1 - Math.abs(maleCount - femaleCount) / group.length;\n    // MBTI 균형 점수 (0-1)\n    const mbtiBalance = 1 - Math.abs(extrovertCount - introvertCount) / group.length;\n    // 새로운 만남 점수\n    let newMeetings = 0;\n    let totalPairs = 0;\n    for(let i = 0; i < group.length; i++){\n        for(let j = i + 1; j < group.length; j++){\n            totalPairs++;\n            if (!haveMet(group[i], group[j])) {\n                newMeetings++;\n            }\n        }\n    }\n    const newMeetingScore = totalPairs > 0 ? newMeetings / totalPairs : 1;\n    // 가중 평균 (성별 균형 70%, 새로운 만남 25%, MBTI 균형 5%)\n    return genderBalance * 0.7 + newMeetingScore * 0.25 + mbtiBalance * 0.05;\n}\n// 참가자가 이전 라운드와 다른 그룹 번호를 가져야 하는지 확인\nfunction shouldAvoidGroupNumber(participant, groupNumber) {\n    const history = participant.groupHistory || [];\n    return history.length > 0 && history[history.length - 1] === groupNumber;\n}\n// 최적화된 그룹 배치 알고리즘\nfunction createOptimalGroups(participants) {\n    let groupSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, currentRound = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    if (participants.length < 2) {\n        throw new Error('최소 2명 이상의 참가자가 필요합니다.');\n    }\n    console.log(\"그룹 배치 시작: 참가자 \".concat(participants.length, \"명, 그룹 크기 \").concat(groupSize));\n    // 필요한 그룹 수 계산\n    const numGroups = Math.ceil(participants.length / groupSize);\n    console.log(\"필요한 그룹 수: \".concat(numGroups));\n    // 그룹 배열 초기화\n    const groups = Array.from({\n        length: numGroups\n    }, ()=>[]);\n    // 참가자를 그룹에 배치\n    const shuffledParticipants = [\n        ...participants\n    ].sort(()=>Math.random() - 0.5);\n    // 먼저 순차적으로 배치\n    shuffledParticipants.forEach((participant, index)=>{\n        const groupIndex = index % numGroups;\n        groups[groupIndex].push(participant);\n    });\n    console.log('초기 배치 완료:', groups.map((g)=>g.length));\n    // 그룹 균형 최적화\n    optimizeGroupBalance(groups, groupSize);\n    console.log('최적화 완료:', groups.map((g)=>g.length));\n    // 결과 구성\n    const finalGroups = groups.map((groupMembers, index)=>{\n        const maleCount = groupMembers.filter((p)=>p.gender === 'male').length;\n        const femaleCount = groupMembers.filter((p)=>p.gender === 'female').length;\n        const extrovertCount = groupMembers.filter((p)=>p.mbti === 'extrovert').length;\n        const introvertCount = groupMembers.filter((p)=>p.mbti === 'introvert').length;\n        return {\n            id: index + 1,\n            members: groupMembers,\n            maleCount,\n            femaleCount,\n            extrovertCount,\n            introvertCount\n        };\n    }).filter((group)=>group.members.length > 0) // 빈 그룹 제거\n    ;\n    // 통계 계산\n    let newMeetingsTotal = 0;\n    let totalGenderBalance = 0;\n    let totalMbtiBalance = 0;\n    finalGroups.forEach((group)=>{\n        const groupMembers = group.members;\n        // 새로운 만남 계산\n        for(let i = 0; i < groupMembers.length; i++){\n            for(let j = i + 1; j < groupMembers.length; j++){\n                if (!haveMet(groupMembers[i], groupMembers[j])) {\n                    newMeetingsTotal++;\n                }\n            }\n        }\n        if (groupMembers.length > 0) {\n            totalGenderBalance += 1 - Math.abs(group.maleCount - group.femaleCount) / groupMembers.length;\n            totalMbtiBalance += 1 - Math.abs(group.extrovertCount - group.introvertCount) / groupMembers.length;\n        }\n    });\n    console.log(\"최종 그룹 수: \".concat(finalGroups.length));\n    console.log('각 그룹 크기:', finalGroups.map((g)=>g.members.length));\n    return {\n        groups: finalGroups,\n        round: currentRound,\n        summary: {\n            totalGroups: finalGroups.length,\n            avgGroupSize: finalGroups.length > 0 ? participants.length / finalGroups.length : 0,\n            genderBalanceScore: finalGroups.length > 0 ? Math.round(totalGenderBalance / finalGroups.length * 100) : 0,\n            mbtiBalanceScore: finalGroups.length > 0 ? Math.round(totalMbtiBalance / finalGroups.length * 100) : 0,\n            newMeetingsCount: newMeetingsTotal\n        }\n    };\n}\n// 그룹 균형 최적화 함수\nfunction optimizeGroupBalance(groups, targetGroupSize) {\n    const maxIterations = 50;\n    for(let iteration = 0; iteration < maxIterations; iteration++){\n        let improved = false;\n        // 그룹 크기 균형 맞추기\n        for(let i = 0; i < groups.length; i++){\n            for(let j = 0; j < groups.length; j++){\n                if (i === j) continue;\n                const group1 = groups[i];\n                const group2 = groups[j];\n                // 크기 차이가 2 이상인 경우 조정\n                if (group1.length - group2.length >= 2) {\n                    // group1에서 group2로 한 명 이동\n                    if (group1.length > 1) {\n                        const memberToMove = group1.pop();\n                        if (memberToMove) {\n                            group2.push(memberToMove);\n                            improved = true;\n                        }\n                    }\n                }\n            }\n        }\n        // 성별 균형 개선\n        for(let i = 0; i < groups.length; i++){\n            for(let j = i + 1; j < groups.length; j++){\n                const group1 = groups[i];\n                const group2 = groups[j];\n                if (group1.length === 0 || group2.length === 0) continue;\n                const g1Males = group1.filter((p)=>p.gender === 'male').length;\n                const g1Females = group1.filter((p)=>p.gender === 'female').length;\n                const g2Males = group2.filter((p)=>p.gender === 'male').length;\n                const g2Females = group2.filter((p)=>p.gender === 'female').length;\n                // 성별 불균형이 있는 경우 교환 시도\n                if (Math.abs(g1Males - g1Females) > 1 || Math.abs(g2Males - g2Females) > 1) {\n                    for(let p1 = 0; p1 < group1.length; p1++){\n                        for(let p2 = 0; p2 < group2.length; p2++){\n                            if (group1[p1].gender !== group2[p2].gender) {\n                                // 교환 시도\n                                const oldBalance1 = Math.abs(g1Males - g1Females);\n                                const oldBalance2 = Math.abs(g2Males - g2Females);\n                                const oldTotalBalance = oldBalance1 + oldBalance2;\n                                // 교환해보기\n                                const temp = group1[p1];\n                                group1[p1] = group2[p2];\n                                group2[p2] = temp;\n                                const newG1Males = group1.filter((p)=>p.gender === 'male').length;\n                                const newG1Females = group1.filter((p)=>p.gender === 'female').length;\n                                const newG2Males = group2.filter((p)=>p.gender === 'male').length;\n                                const newG2Females = group2.filter((p)=>p.gender === 'female').length;\n                                const newBalance1 = Math.abs(newG1Males - newG1Females);\n                                const newBalance2 = Math.abs(newG2Males - newG2Females);\n                                const newTotalBalance = newBalance1 + newBalance2;\n                                if (newTotalBalance < oldTotalBalance) {\n                                    improved = true;\n                                    break;\n                                } else {\n                                    // 되돌리기\n                                    const temp2 = group1[p1];\n                                    group1[p1] = group2[p2];\n                                    group2[p2] = temp2;\n                                }\n                            }\n                        }\n                        if (improved) break;\n                    }\n                }\n                if (improved) break;\n            }\n            if (improved) break;\n        }\n        if (!improved) break;\n    }\n}\n// 만남 히스토리 업데이트\nfunction updateMeetingHistory(participants, groups, round) {\n    const updatedParticipants = participants.map((p)=>({\n            ...p,\n            metPeople: [\n                ...p.metPeople || []\n            ],\n            groupHistory: [\n                ...p.groupHistory || []\n            ]\n        }));\n    // 각 그룹 내 참가자들의 만남 기록 업데이트\n    groups.forEach((group)=>{\n        // 그룹 번호 히스토리 업데이트\n        group.members.forEach((member)=>{\n            const participant = updatedParticipants.find((p)=>p.id === member.id);\n            if (participant) {\n                participant.groupHistory.push(group.id);\n            }\n        });\n        // 서로 만난 기록 업데이트\n        for(let i = 0; i < group.members.length; i++){\n            for(let j = i + 1; j < group.members.length; j++){\n                const p1 = updatedParticipants.find((p)=>p.id === group.members[i].id);\n                const p2 = updatedParticipants.find((p)=>p.id === group.members[j].id);\n                if (p1 && p2) {\n                    if (!p1.metPeople.includes(p2.id)) {\n                        p1.metPeople.push(p2.id);\n                    }\n                    if (!p2.metPeople.includes(p1.id)) {\n                        p2.metPeople.push(p1.id);\n                    }\n                }\n            }\n        }\n    });\n    return updatedParticipants;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ncm91cGluZy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQThCQSxxQkFBcUI7QUFDckIsU0FBU0EsUUFBUUMsRUFBZSxFQUFFQyxFQUFlO1FBQ3hDRDtJQUFQLE9BQU9BLEVBQUFBLGdCQUFBQSxHQUFHRSxTQUFTLGNBQVpGLG9DQUFBQSxjQUFjRyxRQUFRLENBQUNGLEdBQUdHLEVBQUUsTUFBSztBQUMxQztBQUVBLHlCQUF5QjtBQUN6QixTQUFTQyxzQkFBc0JDLEtBQW9CO0lBQ2pELElBQUlBLE1BQU1DLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFL0IsTUFBTUMsWUFBWUYsTUFBTUcsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssUUFBUUosTUFBTTtJQUMvRCxNQUFNSyxjQUFjTixNQUFNRyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxVQUFVSixNQUFNO0lBQ25FLE1BQU1NLGlCQUFpQlAsTUFBTUcsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFSSxJQUFJLEtBQUssYUFBYVAsTUFBTTtJQUN2RSxNQUFNUSxpQkFBaUJULE1BQU1HLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUksSUFBSSxLQUFLLGFBQWFQLE1BQU07SUFFdkUsaUJBQWlCO0lBQ2pCLE1BQU1TLGdCQUFnQixJQUFJQyxLQUFLQyxHQUFHLENBQUNWLFlBQVlJLGVBQWVOLE1BQU1DLE1BQU07SUFFMUUsbUJBQW1CO0lBQ25CLE1BQU1ZLGNBQWMsSUFBSUYsS0FBS0MsR0FBRyxDQUFDTCxpQkFBaUJFLGtCQUFrQlQsTUFBTUMsTUFBTTtJQUVoRixZQUFZO0lBQ1osSUFBSWEsY0FBYztJQUNsQixJQUFJQyxhQUFhO0lBQ2pCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJaEIsTUFBTUMsTUFBTSxFQUFFZSxJQUFLO1FBQ3JDLElBQUssSUFBSUMsSUFBSUQsSUFBSSxHQUFHQyxJQUFJakIs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Q0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPc0Y7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2RvaHllb25hbi9zaWRlUHJvamVjdHMvc29jaWFsaW5nU2VhdEFzc2lnbmVyL3NyYy91dGlscy9ncm91cGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFBhcnRpY2lwYW50IHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgZ2VuZGVyOiAnbWFsZScgfCAnZmVtYWxlJ1xuICBtYnRpOiAnZXh0cm92ZXJ0JyB8ICdpbnRyb3ZlcnQnXG4gIG1ldFBlb3BsZT86IHN0cmluZ1tdXG4gIGdyb3VwSGlzdG9yeT86IG51bWJlcltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXAge1xuICBpZDogbnVtYmVyXG4gIG1lbWJlcnM6IFBhcnRpY2lwYW50W11cbiAgbWFsZUNvdW50OiBudW1iZXJcbiAgZmVtYWxlQ291bnQ6IG51bWJlclxuICBleHRyb3ZlcnRDb3VudDogbnVtYmVyXG4gIGludHJvdmVydENvdW50OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91cGluZ1Jlc3VsdCB7XG4gIGdyb3VwczogR3JvdXBbXVxuICByb3VuZDogbnVtYmVyXG4gIHN1bW1hcnk6IHtcbiAgICB0b3RhbEdyb3VwczogbnVtYmVyXG4gICAgYXZnR3JvdXBTaXplOiBudW1iZXJcbiAgICBnZW5kZXJCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG1idGlCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG5ld01lZXRpbmdzQ291bnQ6IG51bWJlclxuICB9XG59XG5cbi8vIOuRkCDssLjqsIDsnpDqsIAg7J207KCE7JeQIOunjOuCrOuKlOyngCDtmZXsnbhcbmZ1bmN0aW9uIGhhdmVNZXQocDE6IFBhcnRpY2lwYW50LCBwMjogUGFydGljaXBhbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIHAxLm1ldFBlb3BsZT8uaW5jbHVkZXMocDIuaWQpIHx8IGZhbHNlXG59XG5cbi8vIOq3uOujueydmCDqt6DtmJUg7KCQ7IiYIOqzhOyCsCAo64aS7J2E7IiY66GdIOyii+ydjClcbmZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VwQmFsYW5jZShncm91cDogUGFydGljaXBhbnRbXSk6IG51bWJlciB7XG4gIGlmIChncm91cC5sZW5ndGggPT09IDApIHJldHVybiAwXG4gIFxuICBjb25zdCBtYWxlQ291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgY29uc3QgZmVtYWxlQ291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICBjb25zdCBleHRyb3ZlcnRDb3VudCA9IGdyb3VwLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2V4dHJvdmVydCcpLmxlbmd0aFxuICBjb25zdCBpbnRyb3ZlcnRDb3VudCA9IGdyb3VwLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICBcbiAgLy8g7ISx67OEIOq3oO2YlSDsoJDsiJggKDAtMSlcbiAgY29uc3QgZ2VuZGVyQmFsYW5jZSA9IDEgLSBNYXRoLmFicyhtYWxlQ291bnQgLSBmZW1hbGVDb3VudCkgLyBncm91cC5sZW5ndGhcbiAgXG4gIC8vIE1CVEkg6reg7ZiVIOygkOyImCAoMC0xKVxuICBjb25zdCBtYnRpQmFsYW5jZSA9IDEgLSBNYXRoLmFicyhleHRyb3ZlcnRDb3VudCAtIGludHJvdmVydENvdW50KSAvIGdyb3VwLmxlbmd0aFxuICBcbiAgLy8g7IOI66Gc7Jq0IOunjOuCqCDsoJDsiJhcbiAgbGV0IG5ld01lZXRpbmdzID0gMFxuICBsZXQgdG90YWxQYWlycyA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwLmxlbmd0aDsgaisrKSB7XG4gICAgICB0b3RhbFBhaXJzKytcbiAgICAgIGlmICghaGF2ZU1ldChncm91cFtpXSwgZ3JvdXBbal0pKSB7XG4gICAgICAgIG5ld01lZXRpbmdzKytcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbmV3TWVldGluZ1Njb3JlID0gdG90YWxQYWlycyA+IDAgPyBuZXdNZWV0aW5ncyAvIHRvdGFsUGFpcnMgOiAxXG4gIFxuICAvLyDqsIDspJEg7Y+J6regICjshLHrs4Qg6reg7ZiVIDcwJSwg7IOI66Gc7Jq0IOunjOuCqCAyNSUsIE1CVEkg6reg7ZiVIDUlKVxuICByZXR1cm4gZ2VuZGVyQmFsYW5jZSAqIDAuNyArIG5ld01lZXRpbmdTY29yZSAqIDAuMjUgKyBtYnRpQmFsYW5jZSAqIDAuMDVcbn1cblxuLy8g7LC46rCA7J6Q6rCAIOydtOyghCDrnbzsmrTrk5zsmYAg64uk66W4IOq3uOujuSDrsojtmLjrpbwg6rCA7KC47JW8IO2VmOuKlOyngCDtmZXsnbhcbmZ1bmN0aW9uIHNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQ6IFBhcnRpY2lwYW50LCBncm91cE51bWJlcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhpc3RvcnkgPSBwYXJ0aWNpcGFudC5ncm91cEhpc3RvcnkgfHwgW11cbiAgcmV0dXJuIGhpc3RvcnkubGVuZ3RoID4gMCAmJiBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV0gPT09IGdyb3VwTnVtYmVyXG59XG5cbi8vIOy1nOygge2ZlOuQnCDqt7jro7kg67Cw7LmYIOyVjOqzoOumrOymmFxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9wdGltYWxHcm91cHMoXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRbXSwgXG4gIGdyb3VwU2l6ZTogbnVtYmVyID0gNCxcbiAgY3VycmVudFJvdW5kOiBudW1iZXIgPSAxXG4pOiBHcm91cGluZ1Jlc3VsdCB7XG4gIGlmIChwYXJ0aWNpcGFudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcign7LWc7IaMIDLrqoUg7J207IOB7J2YIOywuOqwgOyekOqwgCDtlYTsmpTtlanri4jri6QuJylcbiAgfVxuXG4gIGNvbnNvbGUubG9nKGDqt7jro7kg67Cw7LmYIOyLnOyekTog7LC46rCA7J6QICR7cGFydGljaXBhbnRzLmxlbmd0aH3rqoUsIOq3uOujuSDtgazquLAgJHtncm91cFNpemV9YClcblxuICAvLyDtlYTsmpTtlZwg6re466O5IOyImCDqs4TsgrBcbiAgY29uc3QgbnVtR3JvdXBzID0gTWF0aC5jZWlsKHBhcnRpY2lwYW50cy5sZW5ndGggLyBncm91cFNpemUpXG4gIGNvbnNvbGUubG9nKGDtlYTsmpTtlZwg6re466O5IOyImDogJHtudW1Hcm91cHN9YClcblxuICAvLyDqt7jro7kg67Cw7Je0IOy0iOq4sO2ZlFxuICBjb25zdCBncm91cHM6IFBhcnRpY2lwYW50W11bXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG51bUdyb3VwcyB9LCAoKSA9PiBbXSlcblxuICAvLyDssLjqsIDsnpDrpbwg6re466O57JeQIOuwsOy5mFxuICBjb25zdCBzaHVmZmxlZFBhcnRpY2lwYW50cyA9IFsuLi5wYXJ0aWNpcGFudHNdLnNvcnQoKCkgPT4gTWF0aC5yYW5kb20oKSAtIDAuNSlcbiAgXG4gIC8vIOuovOyggCDsiJzssKjsoIHsnLzroZwg67Cw7LmYXG4gIHNodWZmbGVkUGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGdyb3VwSW5kZXggPSBpbmRleCAlIG51bUdyb3Vwc1xuICAgIGdyb3Vwc1tncm91cEluZGV4XS5wdXNoKHBhcnRpY2lwYW50KVxuICB9KVxuXG4gIGNvbnNvbGUubG9nKCfstIjquLAg67Cw7LmYIOyZhOujjDonLCBncm91cHMubWFwKGcgPT4gZy5sZW5ndGgpKVxuXG4gIC8vIOq3uOujuSDqt6DtmJUg7LWc7KCB7ZmUXG4gIG9wdGltaXplR3JvdXBCYWxhbmNlKGdyb3VwcywgZ3JvdXBTaXplKVxuXG4gIGNvbnNvbGUubG9nKCfstZzsoIHtmZQg7JmE66OMOicsIGdyb3Vwcy5tYXAoZyA9PiBnLmxlbmd0aCkpXG5cbiAgLy8g6rKw6rO8IOq1rOyEsVxuICBjb25zdCBmaW5hbEdyb3VwczogR3JvdXBbXSA9IGdyb3Vwcy5tYXAoKGdyb3VwTWVtYmVycywgaW5kZXgpID0+IHtcbiAgICBjb25zdCBtYWxlQ291bnQgPSBncm91cE1lbWJlcnMuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gICAgY29uc3QgZmVtYWxlQ291bnQgPSBncm91cE1lbWJlcnMuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdmZW1hbGUnKS5sZW5ndGhcbiAgICBjb25zdCBleHRyb3ZlcnRDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdleHRyb3ZlcnQnKS5sZW5ndGhcbiAgICBjb25zdCBpbnRyb3ZlcnRDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdpbnRyb3ZlcnQnKS5sZW5ndGhcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGluZGV4ICsgMSxcbiAgICAgIG1lbWJlcnM6IGdyb3VwTWVtYmVycyxcbiAgICAgIG1hbGVDb3VudCxcbiAgICAgIGZlbWFsZUNvdW50LFxuICAgICAgZXh0cm92ZXJ0Q291bnQsXG4gICAgICBpbnRyb3ZlcnRDb3VudFxuICAgIH1cbiAgfSkuZmlsdGVyKGdyb3VwID0+IGdyb3VwLm1lbWJlcnMubGVuZ3RoID4gMCkgLy8g67mIIOq3uOujuSDsoJzqsbBcblxuICAvLyDthrXqs4Qg6rOE7IKwXG4gIGxldCBuZXdNZWV0aW5nc1RvdGFsID0gMFxuICBsZXQgdG90YWxHZW5kZXJCYWxhbmNlID0gMFxuICBsZXQgdG90YWxNYnRpQmFsYW5jZSA9IDBcbiAgXG4gIGZpbmFsR3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgIGNvbnN0IGdyb3VwTWVtYmVycyA9IGdyb3VwLm1lbWJlcnNcbiAgICBcbiAgICAvLyDsg4jroZzsmrQg66eM64KoIOqzhOyCsFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBNZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBncm91cE1lbWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFoYXZlTWV0KGdyb3VwTWVtYmVyc1tpXSwgZ3JvdXBNZW1iZXJzW2pdKSkge1xuICAgICAgICAgIG5ld01lZXRpbmdzVG90YWwrK1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChncm91cE1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdG90YWxHZW5kZXJCYWxhbmNlICs9IDEgLSBNYXRoLmFicyhncm91cC5tYWxlQ291bnQgLSBncm91cC5mZW1hbGVDb3VudCkgLyBncm91cE1lbWJlcnMubGVuZ3RoXG4gICAgICB0b3RhbE1idGlCYWxhbmNlICs9IDEgLSBNYXRoLmFicyhncm91cC5leHRyb3ZlcnRDb3VudCAtIGdyb3VwLmludHJvdmVydENvdW50KSAvIGdyb3VwTWVtYmVycy5sZW5ndGhcbiAgICB9XG4gIH0pXG5cbiAgY29uc29sZS5sb2coYOy1nOyihSDqt7jro7kg7IiYOiAke2ZpbmFsR3JvdXBzLmxlbmd0aH1gKVxuICBjb25zb2xlLmxvZygn6rCBIOq3uOujuSDtgazquLA6JywgZmluYWxHcm91cHMubWFwKGcgPT4gZy5tZW1iZXJzLmxlbmd0aCkpXG5cbiAgcmV0dXJuIHtcbiAgICBncm91cHM6IGZpbmFsR3JvdXBzLFxuICAgIHJvdW5kOiBjdXJyZW50Um91bmQsXG4gICAgc3VtbWFyeToge1xuICAgICAgdG90YWxHcm91cHM6IGZpbmFsR3JvdXBzLmxlbmd0aCxcbiAgICAgIGF2Z0dyb3VwU2l6ZTogZmluYWxHcm91cHMubGVuZ3RoID4gMCA/IHBhcnRpY2lwYW50cy5sZW5ndGggLyBmaW5hbEdyb3Vwcy5sZW5ndGggOiAwLFxuICAgICAgZ2VuZGVyQmFsYW5jZVNjb3JlOiBmaW5hbEdyb3Vwcy5sZW5ndGggPiAwID8gTWF0aC5yb3VuZCgodG90YWxHZW5kZXJCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCkgOiAwLFxuICAgICAgbWJ0aUJhbGFuY2VTY29yZTogZmluYWxHcm91cHMubGVuZ3RoID4gMCA/IE1hdGgucm91bmQoKHRvdGFsTWJ0aUJhbGFuY2UgLyBmaW5hbEdyb3Vwcy5sZW5ndGgpICogMTAwKSA6IDAsXG4gICAgICBuZXdNZWV0aW5nc0NvdW50OiBuZXdNZWV0aW5nc1RvdGFsXG4gICAgfVxuICB9XG59XG5cbi8vIOq3uOujuSDqt6DtmJUg7LWc7KCB7ZmUIO2VqOyImFxuZnVuY3Rpb24gb3B0aW1pemVHcm91cEJhbGFuY2UoZ3JvdXBzOiBQYXJ0aWNpcGFudFtdW10sIHRhcmdldEdyb3VwU2l6ZTogbnVtYmVyKSB7XG4gIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSA1MFxuICBcbiAgZm9yIChsZXQgaXRlcmF0aW9uID0gMDsgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9uczsgaXRlcmF0aW9uKyspIHtcbiAgICBsZXQgaW1wcm92ZWQgPSBmYWxzZVxuICAgIFxuICAgIC8vIOq3uOujuSDtgazquLAg6reg7ZiVIOunnuy2lOq4sFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaSA9PT0gaikgY29udGludWVcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGdyb3VwMSA9IGdyb3Vwc1tpXVxuICAgICAgICBjb25zdCBncm91cDIgPSBncm91cHNbal1cbiAgICAgICAgXG4gICAgICAgIC8vIO2BrOq4sCDssKjsnbTqsIAgMiDsnbTsg4Hsnbgg6rK97JqwIOyhsOyglVxuICAgICAgICBpZiAoZ3JvdXAxLmxlbmd0aCAtIGdyb3VwMi5sZW5ndGggPj0gMikge1xuICAgICAgICAgIC8vIGdyb3VwMeyXkOyEnCBncm91cDLroZwg7ZWcIOuqhSDsnbTrj5lcbiAgICAgICAgICBpZiAoZ3JvdXAxLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlclRvTW92ZSA9IGdyb3VwMS5wb3AoKVxuICAgICAgICAgICAgaWYgKG1lbWJlclRvTW92ZSkge1xuICAgICAgICAgICAgICBncm91cDIucHVzaChtZW1iZXJUb01vdmUpXG4gICAgICAgICAgICAgIGltcHJvdmVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyDshLHrs4Qg6reg7ZiVIOqwnOyEoFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgZ3JvdXAxID0gZ3JvdXBzW2ldXG4gICAgICAgIGNvbnN0IGdyb3VwMiA9IGdyb3Vwc1tqXVxuICAgICAgICBcbiAgICAgICAgaWYgKGdyb3VwMS5sZW5ndGggPT09IDAgfHwgZ3JvdXAyLmxlbmd0aCA9PT0gMCkgY29udGludWVcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGcxTWFsZXMgPSBncm91cDEuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gICAgICAgIGNvbnN0IGcxRmVtYWxlcyA9IGdyb3VwMS5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgICAgICBjb25zdCBnMk1hbGVzID0gZ3JvdXAyLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnbWFsZScpLmxlbmd0aFxuICAgICAgICBjb25zdCBnMkZlbWFsZXMgPSBncm91cDIuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdmZW1hbGUnKS5sZW5ndGhcbiAgICAgICAgXG4gICAgICAgIC8vIOyEseuzhCDrtojqt6DtmJXsnbQg7J6I64qUIOqyveyasCDqtZDtmZgg7Iuc64+EXG4gICAgICAgIGlmIChNYXRoLmFicyhnMU1hbGVzIC0gZzFGZW1hbGVzKSA+IDEgfHwgTWF0aC5hYnMoZzJNYWxlcyAtIGcyRmVtYWxlcykgPiAxKSB7XG4gICAgICAgICAgZm9yIChsZXQgcDEgPSAwOyBwMSA8IGdyb3VwMS5sZW5ndGg7IHAxKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAyID0gMDsgcDIgPCBncm91cDIubGVuZ3RoOyBwMisrKSB7XG4gICAgICAgICAgICAgIGlmIChncm91cDFbcDFdLmdlbmRlciAhPT0gZ3JvdXAyW3AyXS5nZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAvLyDqtZDtmZgg7Iuc64+EXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkQmFsYW5jZTEgPSBNYXRoLmFicyhnMU1hbGVzIC0gZzFGZW1hbGVzKVxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEJhbGFuY2UyID0gTWF0aC5hYnMoZzJNYWxlcyAtIGcyRmVtYWxlcylcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRUb3RhbEJhbGFuY2UgPSBvbGRCYWxhbmNlMSArIG9sZEJhbGFuY2UyXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8g6rWQ7ZmY7ZW067O06riwXG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IGdyb3VwMVtwMV1cbiAgICAgICAgICAgICAgICBncm91cDFbcDFdID0gZ3JvdXAyW3AyXVxuICAgICAgICAgICAgICAgIGdyb3VwMltwMl0gPSB0ZW1wXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RzFNYWxlcyA9IGdyb3VwMS5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdHMUZlbWFsZXMgPSBncm91cDEuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdmZW1hbGUnKS5sZW5ndGhcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdHMk1hbGVzID0gZ3JvdXAyLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnbWFsZScpLmxlbmd0aFxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0cyRmVtYWxlcyA9IGdyb3VwMi5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0JhbGFuY2UxID0gTWF0aC5hYnMobmV3RzFNYWxlcyAtIG5ld0cxRmVtYWxlcylcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdCYWxhbmNlMiA9IE1hdGguYWJzKG5ld0cyTWFsZXMgLSBuZXdHMkZlbWFsZXMpXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VG90YWxCYWxhbmNlID0gbmV3QmFsYW5jZTEgKyBuZXdCYWxhbmNlMlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChuZXdUb3RhbEJhbGFuY2UgPCBvbGRUb3RhbEJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgIGltcHJvdmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8g65CY64+M66as6riwXG4gICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wMiA9IGdyb3VwMVtwMV1cbiAgICAgICAgICAgICAgICAgIGdyb3VwMVtwMV0gPSBncm91cDJbcDJdXG4gICAgICAgICAgICAgICAgICBncm91cDJbcDJdID0gdGVtcDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbXByb3ZlZCkgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcHJvdmVkKSBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGltcHJvdmVkKSBicmVha1xuICAgIH1cbiAgICBcbiAgICBpZiAoIWltcHJvdmVkKSBicmVha1xuICB9XG59XG5cbi8vIOunjOuCqCDtnojsiqTthqDrpqwg7JeF642w7J207Yq4XG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWVldGluZ0hpc3RvcnkoXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRbXSwgXG4gIGdyb3VwczogR3JvdXBbXSwgXG4gIHJvdW5kOiBudW1iZXJcbik6IFBhcnRpY2lwYW50W10ge1xuICBjb25zdCB1cGRhdGVkUGFydGljaXBhbnRzID0gcGFydGljaXBhbnRzLm1hcChwID0+ICh7XG4gICAgLi4ucCxcbiAgICBtZXRQZW9wbGU6IFsuLi4ocC5tZXRQZW9wbGUgfHwgW10pXSxcbiAgICBncm91cEhpc3Rvcnk6IFsuLi4ocC5ncm91cEhpc3RvcnkgfHwgW10pXVxuICB9KSlcblxuICAvLyDqsIEg6re466O5IOuCtCDssLjqsIDsnpDrk6TsnZgg66eM64KoIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgZ3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgIC8vIOq3uOujuSDrsojtmLgg7Z6I7Iqk7Yag66asIOyXheuNsOydtO2KuFxuICAgIGdyb3VwLm1lbWJlcnMuZm9yRWFjaChtZW1iZXIgPT4ge1xuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBtZW1iZXIuaWQpXG4gICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgcGFydGljaXBhbnQuZ3JvdXBIaXN0b3J5IS5wdXNoKGdyb3VwLmlkKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyDshJzroZwg66eM64KcIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgcDEgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBncm91cC5tZW1iZXJzW2ldLmlkKVxuICAgICAgICBjb25zdCBwMiA9IHVwZGF0ZWRQYXJ0aWNpcGFudHMuZmluZChwID0+IHAuaWQgPT09IGdyb3VwLm1lbWJlcnNbal0uaWQpXG4gICAgICAgIFxuICAgICAgICBpZiAocDEgJiYgcDIpIHtcbiAgICAgICAgICBpZiAoIXAxLm1ldFBlb3BsZSEuaW5jbHVkZXMocDIuaWQpKSB7XG4gICAgICAgICAgICBwMS5tZXRQZW9wbGUhLnB1c2gocDIuaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcDIubWV0UGVvcGxlIS5pbmNsdWRlcyhwMS5pZCkpIHtcbiAgICAgICAgICAgIHAyLm1ldFBlb3BsZSEucHVzaChwMS5pZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRQYXJ0aWNpcGFudHNcbn0iXSwibmFtZXMiOlsiaGF2ZU1ldCIsInAxIiwicDIiLCJtZXRQZW9wbGUiLCJpbmNsdWRlcyIsImlkIiwiY2FsY3VsYXRlR3JvdXBCYWxhbmNlIiwiZ3JvdXAiLCJsZW5ndGgiLCJtYWxlQ291bnQiLCJmaWx0ZXIiLCJwIiwiZ2VuZGVyIiwiZmVtYWxlQ291bnQiLCJleHRyb3ZlcnRDb3VudCIsIm1idGkiLCJpbnRyb3ZlcnRDb3VudCIsImdlbmRlckJhbGFuY2UiLCJNYXRoIiwiYWJzIiwibWJ0aUJhbGFuY2UiLCJuZXdNZWV0aW5ncyIsInRvdGFsUGFpcnMiLCJpIiwiaiIsIm5ld01lZXRpbmdTY29yZSIsInNob3VsZEF2b2lkR3JvdXBOdW1iZXIiLCJwYXJ0aWNpcGFudCIsImdyb3VwTnVtYmVyIiwiaGlzdG9yeSIsImdyb3VwSGlzdG9yeSIsImNyZWF0ZU9wdGltYWxHcm91cHMiLCJwYXJ0aWNpcGFudHMiLCJncm91cFNpemUiLCJjdXJyZW50Um91bmQiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJudW1Hcm91cHMiLCJjZWlsIiwiZ3JvdXBzIiwiQXJyYXkiLCJmcm9tIiwic2h1ZmZsZWRQYXJ0aWNpcGFudHMiLCJzb3J0IiwicmFuZG9tIiwiZm9yRWFjaCIsImluZGV4IiwiZ3JvdXBJbmRleCIsInB1c2giLCJtYXAiLCJnIiwib3B0aW1pemVHcm91cEJhbGFuY2UiLCJmaW5hbEdyb3VwcyIsImdyb3VwTWVtYmVycyIsIm1lbWJlcnMiLCJuZXdNZWV0aW5nc1RvdGFsIiwidG90YWxHZW5kZXJCYWxhbmNlIiwidG90YWxNYnRpQmFsYW5jZSIsInJvdW5kIiwic3VtbWFyeSIsInRvdGFsR3JvdXBzIiwiYXZnR3JvdXBTaXplIiwiZ2VuZGVyQmFsYW5jZVNjb3JlIiwibWJ0aUJhbGFuY2VTY29yZSIsIm5ld01lZXRpbmdzQ291bnQiLCJ0YXJnZXRHcm91cFNpemUiLCJtYXhJdGVyYXRpb25zIiwiaXRlcmF0aW9uIiwiaW1wcm92ZWQiLCJncm91cDEiLCJncm91cDIiLCJtZW1iZXJUb01vdmUiLCJwb3AiLCJnMU1hbGVzIiwiZzFGZW1hbGVzIiwiZzJNYWxlcyIsImcyRmVtYWxlcyIsIm9sZEJhbGFuY2UxIiwib2xkQmFsYW5jZTIiLCJvbGRUb3RhbEJhbGFuY2UiLCJ0ZW1wIiwibmV3RzFNYWxlcyIsIm5ld0cxRmVtYWxlcyIsIm5ld0cyTWFsZXMiLCJuZXdHMkZlbWFsZXMiLCJuZXdCYWxhbmNlMSIsIm5ld0JhbGFuY2UyIiwibmV3VG90YWxCYWxhbmNlIiwidGVtcDIiLCJ1cGRhdGVNZWV0aW5nSGlzdG9yeSIsInVwZGF0ZWRQYXJ0aWNpcGFudHMiLCJtZW1iZXIiLCJmaW5kIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/grouping.ts\n"));

/***/ })

});