"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/grouping.ts":
/*!*******************************!*\
  !*** ./src/utils/grouping.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOptimalGroups: () => (/* binding */ createOptimalGroups),\n/* harmony export */   updateMeetingHistory: () => (/* binding */ updateMeetingHistory)\n/* harmony export */ });\n// 두 참가자가 이전에 만났는지 확인\nfunction haveMet(p1, p2) {\n    var _p1_metPeople;\n    return ((_p1_metPeople = p1.metPeople) === null || _p1_metPeople === void 0 ? void 0 : _p1_metPeople.includes(p2.id)) || false;\n}\n// 그룹의 균형 점수 계산 (높을수록 좋음)\nfunction calculateGroupBalance(group) {\n    const maleCount = group.filter((p)=>p.gender === 'male').length;\n    const femaleCount = group.filter((p)=>p.gender === 'female').length;\n    const extrovertCount = group.filter((p)=>p.mbti === 'extrovert').length;\n    const introvertCount = group.filter((p)=>p.mbti === 'introvert').length;\n    // 성별 균형 점수 (우선순위 높음)\n    const genderBalance = 1 - Math.abs(maleCount - femaleCount) / group.length;\n    // MBTI 균형 점수 (우선순위 낮음)\n    const mbtiBalance = 1 - Math.abs(extrovertCount - introvertCount) / group.length;\n    // 새로운 만남 점수\n    let newMeetings = 0;\n    let totalPairs = 0;\n    for(let i = 0; i < group.length; i++){\n        for(let j = i + 1; j < group.length; j++){\n            totalPairs++;\n            if (!haveMet(group[i], group[j])) {\n                newMeetings++;\n            }\n        }\n    }\n    const newMeetingScore = totalPairs > 0 ? newMeetings / totalPairs : 1;\n    // 가중 평균 (성별 균형 70%, 새로운 만남 25%, MBTI 균형 5%)\n    return genderBalance * 0.7 + newMeetingScore * 0.25 + mbtiBalance * 0.05;\n}\n// 참가자가 이전 라운드와 다른 그룹 번호를 가져야 하는지 확인\nfunction shouldAvoidGroupNumber(participant, groupNumber) {\n    const history = participant.groupHistory || [];\n    return history.length > 0 && history[history.length - 1] === groupNumber;\n}\n// 유전 알고리즘을 사용한 그룹 배치\nfunction createOptimalGroups(participants) {\n    let groupSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, currentRound = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    if (participants.length < 2) {\n        throw new Error('최소 2명 이상의 참가자가 필요합니다.');\n    }\n    const numGroups = Math.ceil(participants.length / groupSize);\n    const populationSize = 100;\n    const generations = 200;\n    const mutationRate = 0.1;\n    // 개체 생성 (그룹 배치 방식)\n    function createIndividual() {\n        const individual = new Array(participants.length);\n        const groupSizes = new Array(numGroups).fill(0);\n        for(let i = 0; i < participants.length; i++){\n            let groupIndex;\n            let attempts = 0;\n            do {\n                groupIndex = Math.floor(Math.random() * numGroups);\n                attempts++;\n            }while (attempts < 10 && (groupSizes[groupIndex] >= groupSize || shouldAvoidGroupNumber(participants[i], groupIndex + 1)));\n            individual[i] = groupIndex;\n            groupSizes[groupIndex]++;\n        }\n        return individual;\n    }\n    // 적합도 계산\n    function calculateFitness(individual) {\n        const groups = Array.from({\n            length: numGroups\n        }, ()=>[]);\n        individual.forEach((groupIndex, participantIndex)=>{\n            groups[groupIndex].push(participants[participantIndex]);\n        });\n        let totalScore = 0;\n        let validGroups = 0;\n        for (const group of groups){\n            if (group.length > 0) {\n                totalScore += calculateGroupBalance(group);\n                validGroups++;\n                // 그룹 번호 회피 보너스\n                for (const participant of group){\n                    const groupNumber = groups.indexOf(group) + 1;\n                    if (!shouldAvoidGroupNumber(participant, groupNumber)) {\n                        totalScore += 0.1;\n                    }\n                }\n            }\n        }\n        return validGroups > 0 ? totalScore / validGroups : 0;\n    }\n    // 교차\n    function crossover(parent1, parent2) {\n        const child = new Array(participants.length);\n        const crossoverPoint = Math.floor(Math.random() * participants.length);\n        for(let i = 0; i < participants.length; i++){\n            child[i] = i < crossoverPoint ? parent1[i] : parent2[i];\n        }\n        return child;\n    }\n    // 돌연변이\n    function mutate(individual) {\n        const mutated = [\n            ...individual\n        ];\n        for(let i = 0; i < mutated.length; i++){\n            if (Math.random() < mutationRate) {\n                let newGroup;\n                let attempts = 0;\n                do {\n                    newGroup = Math.floor(Math.random() * numGroups);\n                    attempts++;\n                }while (attempts < 5 && shouldAvoidGroupNumber(participants[i], newGroup + 1));\n                mutated[i] = newGroup;\n            }\n        }\n        return mutated;\n    }\n    // 유전 알고리즘 실행\n    let population = Array.from({\n        length: populationSize\n    }, ()=>createIndividual());\n    for(let generation = 0; generation < generations; generation++){\n        // 적합도 계산 및 정렬\n        const fitnessScores = population.map(calculateFitness);\n        const sortedIndices = fitnessScores.map((fitness, index)=>({\n                fitness,\n                index\n            })).sort((a, b)=>b.fitness - a.fitness);\n        // 엘리트 선택 (상위 20%)\n        const eliteSize = Math.floor(populationSize * 0.2);\n        const newPopulation = sortedIndices.slice(0, eliteSize).map((item)=>population[item.index]);\n        // 나머지는 교차와 돌연변이로 생성\n        while(newPopulation.length < populationSize){\n            const parent1Index = Math.floor(Math.random() * eliteSize);\n            const parent2Index = Math.floor(Math.random() * eliteSize);\n            const parent1 = newPopulation[parent1Index];\n            const parent2 = newPopulation[parent2Index];\n            let child = crossover(parent1, parent2);\n            child = mutate(child);\n            newPopulation.push(child);\n        }\n        population = newPopulation;\n    }\n    // 최적 해 선택\n    const fitnessScores = population.map(calculateFitness);\n    const bestIndex = fitnessScores.indexOf(Math.max(...fitnessScores));\n    const bestSolution = population[bestIndex];\n    // 결과 구성\n    const finalGroups = [];\n    const groupArrays = Array.from({\n        length: numGroups\n    }, ()=>[]);\n    bestSolution.forEach((groupIndex, participantIndex)=>{\n        groupArrays[groupIndex].push(participants[participantIndex]);\n    });\n    let newMeetingsTotal = 0;\n    let totalGenderBalance = 0;\n    let totalMbtiBalance = 0;\n    groupArrays.forEach((groupMembers, index)=>{\n        if (groupMembers.length > 0) {\n            const maleCount = groupMembers.filter((p)=>p.gender === 'male').length;\n            const femaleCount = groupMembers.filter((p)=>p.gender === 'female').length;\n            const extrovertCount = groupMembers.filter((p)=>p.mbti === 'extrovert').length;\n            const introvertCount = groupMembers.filter((p)=>p.mbti === 'introvert').length;\n            // 새로운 만남 계산\n            for(let i = 0; i < groupMembers.length; i++){\n                for(let j = i + 1; j < groupMembers.length; j++){\n                    if (!haveMet(groupMembers[i], groupMembers[j])) {\n                        newMeetingsTotal++;\n                    }\n                }\n            }\n            totalGenderBalance += 1 - Math.abs(maleCount - femaleCount) / groupMembers.length;\n            totalMbtiBalance += 1 - Math.abs(extrovertCount - introvertCount) / groupMembers.length;\n            finalGroups.push({\n                id: index + 1,\n                members: groupMembers,\n                maleCount,\n                femaleCount,\n                extrovertCount,\n                introvertCount\n            });\n        }\n    });\n    return {\n        groups: finalGroups,\n        round: currentRound,\n        summary: {\n            totalGroups: finalGroups.length,\n            avgGroupSize: participants.length / finalGroups.length,\n            genderBalanceScore: Math.round(totalGenderBalance / finalGroups.length * 100),\n            mbtiBalanceScore: Math.round(totalMbtiBalance / finalGroups.length * 100),\n            newMeetingsCount: newMeetingsTotal\n        }\n    };\n}\n// 만남 히스토리 업데이트\nfunction updateMeetingHistory(participants, groups, round) {\n    const updatedParticipants = participants.map((p)=>({\n            ...p,\n            metPeople: [\n                ...p.metPeople || []\n            ],\n            groupHistory: [\n                ...p.groupHistory || []\n            ]\n        }));\n    // 각 그룹 내 참가자들의 만남 기록 업데이트\n    groups.forEach((group)=>{\n        // 그룹 번호 히스토리 업데이트\n        group.members.forEach((member)=>{\n            const participant = updatedParticipants.find((p)=>p.id === member.id);\n            if (participant) {\n                participant.groupHistory.push(group.id);\n            }\n        });\n        // 서로 만난 기록 업데이트\n        for(let i = 0; i < group.members.length; i++){\n            for(let j = i + 1; j < group.members.length; j++){\n                const p1 = updatedParticipants.find((p)=>p.id === group.members[i].id);\n                const p2 = updatedParticipants.find((p)=>p.id === group.members[j].id);\n                if (p1 && p2) {\n                    if (!p1.metPeople.includes(p2.id)) {\n                        p1.metPeople.push(p2.id);\n                    }\n                    if (!p2.metPeople.includes(p1.id)) {\n                        p2.metPeople.push(p1.id);\n                    }\n                }\n            }\n        }\n    });\n    return updatedParticipants;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ncm91cGluZy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQThCQSxxQkFBcUI7QUFDckIsU0FBU0EsUUFBUUMsRUFBZSxFQUFFQyxFQUFlO1FBQ3hDRDtJQUFQLE9BQU9BLEVBQUFBLGdCQUFBQSxHQUFHRSxTQUFTLGNBQVpGLG9DQUFBQSxjQUFjRyxRQUFRLENBQUNGLEdBQUdHLEVBQUUsTUFBSztBQUMxQztBQUVBLHlCQUF5QjtBQUN6QixTQUFTQyxzQkFBc0JDLEtBQW9CO0lBQ2pELE1BQU1DLFlBQVlELE1BQU1FLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTSxLQUFLLFFBQVFDLE1BQU07SUFDL0QsTUFBTUMsY0FBY04sTUFBTUUsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssVUFBVUMsTUFBTTtJQUNuRSxNQUFNRSxpQkFBaUJQLE1BQU1FLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUssSUFBSSxLQUFLLGFBQWFILE1BQU07SUFDdkUsTUFBTUksaUJBQWlCVCxNQUFNRSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVLLElBQUksS0FBSyxhQUFhSCxNQUFNO0lBRXZFLHFCQUFxQjtJQUNyQixNQUFNSyxnQkFBZ0IsSUFBSUMsS0FBS0MsR0FBRyxDQUFDWCxZQUFZSyxlQUFlTixNQUFNSyxNQUFNO0lBRTFFLHVCQUF1QjtJQUN2QixNQUFNUSxjQUFjLElBQUlGLEtBQUtDLEdBQUcsQ0FBQ0wsaUJBQWlCRSxrQkFBa0JULE1BQU1LLE1BQU07SUFFaEYsWUFBWTtJQUNaLElBQUlTLGNBQWM7SUFDbEIsSUFBSUMsYUFBYTtJQUNqQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWhCLE1BQU1LLE1BQU0sRUFBRVcsSUFBSztRQUNyQyxJQUFLLElBQUlDLElBQUlELElBQUksR0FBR0MsSUFBSWpCLE1BQU1LLE1BQU0sRUFBRVksSUFBSztZQUN6Q0Y7WUFDQSxJQUFJ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Q0FBQUEsSUFBS0EsRUFBRUwsRUFBRSxLQUFLRSxNQUFNcUYsT0FBTyxDQUFDcEUsRUFBRSxDQUFDbkIsRUFBRTtnQkFFckUsSUFBSUosTUFBTUMsSUFBSTtvQkFDWixJQUFJLENBQUNELEdBQUdFLFNBQVMsQ0FBRUMsUUFBUSxDQUFDRixHQUFHRyxFQUFFLEdBQUc7d0JBQ2xDSixHQUFHRSxTQUFTLENBQUVvRCxJQUFJLENBQUNyRCxHQUFHRyxFQUFFO29CQUMxQjtvQkFDQSxJQUFJLENBQUNILEdBQUdDLFNBQVMsQ0FBRUMsUUFBUSxDQUFDSCxHQUFHSSxFQUFFLEdBQUc7d0JBQ2xDSCxHQUFHQyxTQUFTLENBQUVvRCxJQUFJLENBQUN0RCxHQUFHSSxFQUFFO29CQUMxQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU9nRztBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvZG9oeWVvbmFuL3NpZGVQcm9qZWN0cy9zb2NpYWxpbmdTZWF0QXNzaWduZXIvc3JjL3V0aWxzL2dyb3VwaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgUGFydGljaXBhbnQge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBnZW5kZXI6ICdtYWxlJyB8ICdmZW1hbGUnXG4gIG1idGk6ICdleHRyb3ZlcnQnIHwgJ2ludHJvdmVydCdcbiAgbWV0UGVvcGxlPzogc3RyaW5nW11cbiAgZ3JvdXBIaXN0b3J5PzogbnVtYmVyW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91cCB7XG4gIGlkOiBudW1iZXJcbiAgbWVtYmVyczogUGFydGljaXBhbnRbXVxuICBtYWxlQ291bnQ6IG51bWJlclxuICBmZW1hbGVDb3VudDogbnVtYmVyXG4gIGV4dHJvdmVydENvdW50OiBudW1iZXJcbiAgaW50cm92ZXJ0Q291bnQ6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwaW5nUmVzdWx0IHtcbiAgZ3JvdXBzOiBHcm91cFtdXG4gIHJvdW5kOiBudW1iZXJcbiAgc3VtbWFyeToge1xuICAgIHRvdGFsR3JvdXBzOiBudW1iZXJcbiAgICBhdmdHcm91cFNpemU6IG51bWJlclxuICAgIGdlbmRlckJhbGFuY2VTY29yZTogbnVtYmVyXG4gICAgbWJ0aUJhbGFuY2VTY29yZTogbnVtYmVyXG4gICAgbmV3TWVldGluZ3NDb3VudDogbnVtYmVyXG4gIH1cbn1cblxuLy8g65GQIOywuOqwgOyekOqwgCDsnbTsoITsl5Ag66eM64Ks64qU7KeAIO2ZleyduFxuZnVuY3Rpb24gaGF2ZU1ldChwMTogUGFydGljaXBhbnQsIHAyOiBQYXJ0aWNpcGFudCk6IGJvb2xlYW4ge1xuICByZXR1cm4gcDEubWV0UGVvcGxlPy5pbmNsdWRlcyhwMi5pZCkgfHwgZmFsc2Vcbn1cblxuLy8g6re466O57J2YIOq3oO2YlSDsoJDsiJgg6rOE7IKwICjrhpLsnYTsiJjroZ0g7KKL7J2MKVxuZnVuY3Rpb24gY2FsY3VsYXRlR3JvdXBCYWxhbmNlKGdyb3VwOiBQYXJ0aWNpcGFudFtdKTogbnVtYmVyIHtcbiAgY29uc3QgbWFsZUNvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gIGNvbnN0IGZlbWFsZUNvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdmZW1hbGUnKS5sZW5ndGhcbiAgY29uc3QgZXh0cm92ZXJ0Q291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdleHRyb3ZlcnQnKS5sZW5ndGhcbiAgY29uc3QgaW50cm92ZXJ0Q291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdpbnRyb3ZlcnQnKS5sZW5ndGhcbiAgXG4gIC8vIOyEseuzhCDqt6DtmJUg7KCQ7IiYICjsmrDshKDsiJzsnIQg64aS7J2MKVxuICBjb25zdCBnZW5kZXJCYWxhbmNlID0gMSAtIE1hdGguYWJzKG1hbGVDb3VudCAtIGZlbWFsZUNvdW50KSAvIGdyb3VwLmxlbmd0aFxuICBcbiAgLy8gTUJUSSDqt6DtmJUg7KCQ7IiYICjsmrDshKDsiJzsnIQg64Ku7J2MKVxuICBjb25zdCBtYnRpQmFsYW5jZSA9IDEgLSBNYXRoLmFicyhleHRyb3ZlcnRDb3VudCAtIGludHJvdmVydENvdW50KSAvIGdyb3VwLmxlbmd0aFxuICBcbiAgLy8g7IOI66Gc7Jq0IOunjOuCqCDsoJDsiJhcbiAgbGV0IG5ld01lZXRpbmdzID0gMFxuICBsZXQgdG90YWxQYWlycyA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwLmxlbmd0aDsgaisrKSB7XG4gICAgICB0b3RhbFBhaXJzKytcbiAgICAgIGlmICghaGF2ZU1ldChncm91cFtpXSwgZ3JvdXBbal0pKSB7XG4gICAgICAgIG5ld01lZXRpbmdzKytcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbmV3TWVldGluZ1Njb3JlID0gdG90YWxQYWlycyA+IDAgPyBuZXdNZWV0aW5ncyAvIHRvdGFsUGFpcnMgOiAxXG4gIFxuICAvLyDqsIDspJEg7Y+J6regICjshLHrs4Qg6reg7ZiVIDcwJSwg7IOI66Gc7Jq0IOunjOuCqCAyNSUsIE1CVEkg6reg7ZiVIDUlKVxuICByZXR1cm4gZ2VuZGVyQmFsYW5jZSAqIDAuNyArIG5ld01lZXRpbmdTY29yZSAqIDAuMjUgKyBtYnRpQmFsYW5jZSAqIDAuMDVcbn1cblxuLy8g7LC46rCA7J6Q6rCAIOydtOyghCDrnbzsmrTrk5zsmYAg64uk66W4IOq3uOujuSDrsojtmLjrpbwg6rCA7KC47JW8IO2VmOuKlOyngCDtmZXsnbhcbmZ1bmN0aW9uIHNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQ6IFBhcnRpY2lwYW50LCBncm91cE51bWJlcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhpc3RvcnkgPSBwYXJ0aWNpcGFudC5ncm91cEhpc3RvcnkgfHwgW11cbiAgcmV0dXJuIGhpc3RvcnkubGVuZ3RoID4gMCAmJiBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV0gPT09IGdyb3VwTnVtYmVyXG59XG5cbi8vIOycoOyghCDslYzqs6DrpqzsppjsnYQg7IKs7Jqp7ZWcIOq3uOujuSDrsLDsuZhcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPcHRpbWFsR3JvdXBzKFxuICBwYXJ0aWNpcGFudHM6IFBhcnRpY2lwYW50W10sIFxuICBncm91cFNpemU6IG51bWJlciA9IDQsXG4gIGN1cnJlbnRSb3VuZDogbnVtYmVyID0gMVxuKTogR3JvdXBpbmdSZXN1bHQge1xuICBpZiAocGFydGljaXBhbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ+y1nOyGjCAy66qFIOydtOyDgeydmCDssLjqsIDsnpDqsIAg7ZWE7JqU7ZWp64uI64ukLicpXG4gIH1cblxuICBjb25zdCBudW1Hcm91cHMgPSBNYXRoLmNlaWwocGFydGljaXBhbnRzLmxlbmd0aCAvIGdyb3VwU2l6ZSlcbiAgY29uc3QgcG9wdWxhdGlvblNpemUgPSAxMDBcbiAgY29uc3QgZ2VuZXJhdGlvbnMgPSAyMDBcbiAgY29uc3QgbXV0YXRpb25SYXRlID0gMC4xXG5cbiAgLy8g6rCc7LK0IOyDneyEsSAo6re466O5IOuwsOy5mCDrsKnsi50pXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGl2aWR1YWwoKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGluZGl2aWR1YWwgPSBuZXcgQXJyYXkocGFydGljaXBhbnRzLmxlbmd0aClcbiAgICBjb25zdCBncm91cFNpemVzID0gbmV3IEFycmF5KG51bUdyb3VwcykuZmlsbCgwKVxuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljaXBhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZ3JvdXBJbmRleFxuICAgICAgbGV0IGF0dGVtcHRzID0gMFxuICAgICAgXG4gICAgICBkbyB7XG4gICAgICAgIGdyb3VwSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBudW1Hcm91cHMpXG4gICAgICAgIGF0dGVtcHRzKytcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICBhdHRlbXB0cyA8IDEwICYmIChcbiAgICAgICAgICBncm91cFNpemVzW2dyb3VwSW5kZXhdID49IGdyb3VwU2l6ZSB8fCBcbiAgICAgICAgICBzaG91bGRBdm9pZEdyb3VwTnVtYmVyKHBhcnRpY2lwYW50c1tpXSwgZ3JvdXBJbmRleCArIDEpXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIFxuICAgICAgaW5kaXZpZHVhbFtpXSA9IGdyb3VwSW5kZXhcbiAgICAgIGdyb3VwU2l6ZXNbZ3JvdXBJbmRleF0rK1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaW5kaXZpZHVhbFxuICB9XG5cbiAgLy8g7KCB7ZWp64+EIOqzhOyCsFxuICBmdW5jdGlvbiBjYWxjdWxhdGVGaXRuZXNzKGluZGl2aWR1YWw6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICBjb25zdCBncm91cHM6IFBhcnRpY2lwYW50W11bXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG51bUdyb3VwcyB9LCAoKSA9PiBbXSlcbiAgICBcbiAgICBpbmRpdmlkdWFsLmZvckVhY2goKGdyb3VwSW5kZXgsIHBhcnRpY2lwYW50SW5kZXgpID0+IHtcbiAgICAgIGdyb3Vwc1tncm91cEluZGV4XS5wdXNoKHBhcnRpY2lwYW50c1twYXJ0aWNpcGFudEluZGV4XSlcbiAgICB9KVxuICAgIFxuICAgIGxldCB0b3RhbFNjb3JlID0gMFxuICAgIGxldCB2YWxpZEdyb3VwcyA9IDBcbiAgICBcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGdyb3Vwcykge1xuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdG90YWxTY29yZSArPSBjYWxjdWxhdGVHcm91cEJhbGFuY2UoZ3JvdXApXG4gICAgICAgIHZhbGlkR3JvdXBzKytcbiAgICAgICAgXG4gICAgICAgIC8vIOq3uOujuSDrsojtmLgg7ZqM7ZS8IOuztOuEiOyKpFxuICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2lwYW50IG9mIGdyb3VwKSB7XG4gICAgICAgICAgY29uc3QgZ3JvdXBOdW1iZXIgPSBncm91cHMuaW5kZXhPZihncm91cCkgKyAxXG4gICAgICAgICAgaWYgKCFzaG91bGRBdm9pZEdyb3VwTnVtYmVyKHBhcnRpY2lwYW50LCBncm91cE51bWJlcikpIHtcbiAgICAgICAgICAgIHRvdGFsU2NvcmUgKz0gMC4xXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB2YWxpZEdyb3VwcyA+IDAgPyB0b3RhbFNjb3JlIC8gdmFsaWRHcm91cHMgOiAwXG4gIH1cblxuICAvLyDqtZDssKhcbiAgZnVuY3Rpb24gY3Jvc3NvdmVyKHBhcmVudDE6IG51bWJlcltdLCBwYXJlbnQyOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICBjb25zdCBjaGlsZCA9IG5ldyBBcnJheShwYXJ0aWNpcGFudHMubGVuZ3RoKVxuICAgIGNvbnN0IGNyb3Nzb3ZlclBvaW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFydGljaXBhbnRzLmxlbmd0aClcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2lwYW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRbaV0gPSBpIDwgY3Jvc3NvdmVyUG9pbnQgPyBwYXJlbnQxW2ldIDogcGFyZW50MltpXVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY2hpbGRcbiAgfVxuXG4gIC8vIOuPjOyXsOuzgOydtFxuICBmdW5jdGlvbiBtdXRhdGUoaW5kaXZpZHVhbDogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgY29uc3QgbXV0YXRlZCA9IFsuLi5pbmRpdmlkdWFsXVxuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCBtdXRhdGlvblJhdGUpIHtcbiAgICAgICAgbGV0IG5ld0dyb3VwXG4gICAgICAgIGxldCBhdHRlbXB0cyA9IDBcbiAgICAgICAgXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuZXdHcm91cCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG51bUdyb3VwcylcbiAgICAgICAgICBhdHRlbXB0cysrXG4gICAgICAgIH0gd2hpbGUgKFxuICAgICAgICAgIGF0dGVtcHRzIDwgNSAmJlxuICAgICAgICAgIHNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnRzW2ldLCBuZXdHcm91cCArIDEpXG4gICAgICAgIClcbiAgICAgICAgXG4gICAgICAgIG11dGF0ZWRbaV0gPSBuZXdHcm91cFxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbXV0YXRlZFxuICB9XG5cbiAgLy8g7Jyg7KCEIOyVjOqzoOumrOymmCDsi6TtlolcbiAgbGV0IHBvcHVsYXRpb24gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBwb3B1bGF0aW9uU2l6ZSB9LCAoKSA9PiBjcmVhdGVJbmRpdmlkdWFsKCkpXG4gIFxuICBmb3IgKGxldCBnZW5lcmF0aW9uID0gMDsgZ2VuZXJhdGlvbiA8IGdlbmVyYXRpb25zOyBnZW5lcmF0aW9uKyspIHtcbiAgICAvLyDsoIHtlanrj4Qg6rOE7IKwIOuwjyDsoJXroKxcbiAgICBjb25zdCBmaXRuZXNzU2NvcmVzID0gcG9wdWxhdGlvbi5tYXAoY2FsY3VsYXRlRml0bmVzcylcbiAgICBjb25zdCBzb3J0ZWRJbmRpY2VzID0gZml0bmVzc1Njb3Jlc1xuICAgICAgLm1hcCgoZml0bmVzcywgaW5kZXgpID0+ICh7IGZpdG5lc3MsIGluZGV4IH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuZml0bmVzcyAtIGEuZml0bmVzcylcbiAgICBcbiAgICAvLyDsl5jrpqztirgg7ISg7YOdICjsg4HsnIQgMjAlKVxuICAgIGNvbnN0IGVsaXRlU2l6ZSA9IE1hdGguZmxvb3IocG9wdWxhdGlvblNpemUgKiAwLjIpXG4gICAgY29uc3QgbmV3UG9wdWxhdGlvbiA9IHNvcnRlZEluZGljZXNcbiAgICAgIC5zbGljZSgwLCBlbGl0ZVNpemUpXG4gICAgICAubWFwKGl0ZW0gPT4gcG9wdWxhdGlvbltpdGVtLmluZGV4XSlcbiAgICBcbiAgICAvLyDrgpjrqLjsp4DripQg6rWQ7LCo7JmAIOuPjOyXsOuzgOydtOuhnCDsg53shLFcbiAgICB3aGlsZSAobmV3UG9wdWxhdGlvbi5sZW5ndGggPCBwb3B1bGF0aW9uU2l6ZSkge1xuICAgICAgY29uc3QgcGFyZW50MUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZWxpdGVTaXplKVxuICAgICAgY29uc3QgcGFyZW50MkluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZWxpdGVTaXplKVxuICAgICAgXG4gICAgICBjb25zdCBwYXJlbnQxID0gbmV3UG9wdWxhdGlvbltwYXJlbnQxSW5kZXhdXG4gICAgICBjb25zdCBwYXJlbnQyID0gbmV3UG9wdWxhdGlvbltwYXJlbnQySW5kZXhdXG4gICAgICBcbiAgICAgIGxldCBjaGlsZCA9IGNyb3Nzb3ZlcihwYXJlbnQxLCBwYXJlbnQyKVxuICAgICAgY2hpbGQgPSBtdXRhdGUoY2hpbGQpXG4gICAgICBcbiAgICAgIG5ld1BvcHVsYXRpb24ucHVzaChjaGlsZClcbiAgICB9XG4gICAgXG4gICAgcG9wdWxhdGlvbiA9IG5ld1BvcHVsYXRpb25cbiAgfVxuXG4gIC8vIOy1nOyggSDtlbQg7ISg7YOdXG4gIGNvbnN0IGZpdG5lc3NTY29yZXMgPSBwb3B1bGF0aW9uLm1hcChjYWxjdWxhdGVGaXRuZXNzKVxuICBjb25zdCBiZXN0SW5kZXggPSBmaXRuZXNzU2NvcmVzLmluZGV4T2YoTWF0aC5tYXgoLi4uZml0bmVzc1Njb3JlcykpXG4gIGNvbnN0IGJlc3RTb2x1dGlvbiA9IHBvcHVsYXRpb25bYmVzdEluZGV4XVxuXG4gIC8vIOqysOqzvCDqtazshLFcbiAgY29uc3QgZmluYWxHcm91cHM6IEdyb3VwW10gPSBbXVxuICBjb25zdCBncm91cEFycmF5czogUGFydGljaXBhbnRbXVtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtR3JvdXBzIH0sICgpID0+IFtdKVxuICBcbiAgYmVzdFNvbHV0aW9uLmZvckVhY2goKGdyb3VwSW5kZXgsIHBhcnRpY2lwYW50SW5kZXgpID0+IHtcbiAgICBncm91cEFycmF5c1tncm91cEluZGV4XS5wdXNoKHBhcnRpY2lwYW50c1twYXJ0aWNpcGFudEluZGV4XSlcbiAgfSlcbiAgXG4gIGxldCBuZXdNZWV0aW5nc1RvdGFsID0gMFxuICBsZXQgdG90YWxHZW5kZXJCYWxhbmNlID0gMFxuICBsZXQgdG90YWxNYnRpQmFsYW5jZSA9IDBcbiAgXG4gIGdyb3VwQXJyYXlzLmZvckVhY2goKGdyb3VwTWVtYmVycywgaW5kZXgpID0+IHtcbiAgICBpZiAoZ3JvdXBNZW1iZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICAgIGNvbnN0IGZlbWFsZUNvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgICBjb25zdCBleHRyb3ZlcnRDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdleHRyb3ZlcnQnKS5sZW5ndGhcbiAgICAgIGNvbnN0IGludHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICAgICAgXG4gICAgICAvLyDsg4jroZzsmrQg66eM64KoIOqzhOyCsFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cE1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ3JvdXBNZW1iZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKCFoYXZlTWV0KGdyb3VwTWVtYmVyc1tpXSwgZ3JvdXBNZW1iZXJzW2pdKSkge1xuICAgICAgICAgICAgbmV3TWVldGluZ3NUb3RhbCsrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRvdGFsR2VuZGVyQmFsYW5jZSArPSAxIC0gTWF0aC5hYnMobWFsZUNvdW50IC0gZmVtYWxlQ291bnQpIC8gZ3JvdXBNZW1iZXJzLmxlbmd0aFxuICAgICAgdG90YWxNYnRpQmFsYW5jZSArPSAxIC0gTWF0aC5hYnMoZXh0cm92ZXJ0Q291bnQgLSBpbnRyb3ZlcnRDb3VudCkgLyBncm91cE1lbWJlcnMubGVuZ3RoXG4gICAgICBcbiAgICAgIGZpbmFsR3JvdXBzLnB1c2goe1xuICAgICAgICBpZDogaW5kZXggKyAxLFxuICAgICAgICBtZW1iZXJzOiBncm91cE1lbWJlcnMsXG4gICAgICAgIG1hbGVDb3VudCxcbiAgICAgICAgZmVtYWxlQ291bnQsXG4gICAgICAgIGV4dHJvdmVydENvdW50LFxuICAgICAgICBpbnRyb3ZlcnRDb3VudFxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBncm91cHM6IGZpbmFsR3JvdXBzLFxuICAgIHJvdW5kOiBjdXJyZW50Um91bmQsXG4gICAgc3VtbWFyeToge1xuICAgICAgdG90YWxHcm91cHM6IGZpbmFsR3JvdXBzLmxlbmd0aCxcbiAgICAgIGF2Z0dyb3VwU2l6ZTogcGFydGljaXBhbnRzLmxlbmd0aCAvIGZpbmFsR3JvdXBzLmxlbmd0aCxcbiAgICAgIGdlbmRlckJhbGFuY2VTY29yZTogTWF0aC5yb3VuZCgodG90YWxHZW5kZXJCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCksXG4gICAgICBtYnRpQmFsYW5jZVNjb3JlOiBNYXRoLnJvdW5kKCh0b3RhbE1idGlCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCksXG4gICAgICBuZXdNZWV0aW5nc0NvdW50OiBuZXdNZWV0aW5nc1RvdGFsXG4gICAgfVxuICB9XG59XG5cbi8vIOunjOuCqCDtnojsiqTthqDrpqwg7JeF642w7J207Yq4XG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWVldGluZ0hpc3RvcnkoXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRbXSwgXG4gIGdyb3VwczogR3JvdXBbXSwgXG4gIHJvdW5kOiBudW1iZXJcbik6IFBhcnRpY2lwYW50W10ge1xuICBjb25zdCB1cGRhdGVkUGFydGljaXBhbnRzID0gcGFydGljaXBhbnRzLm1hcChwID0+ICh7XG4gICAgLi4ucCxcbiAgICBtZXRQZW9wbGU6IFsuLi4ocC5tZXRQZW9wbGUgfHwgW10pXSxcbiAgICBncm91cEhpc3Rvcnk6IFsuLi4ocC5ncm91cEhpc3RvcnkgfHwgW10pXVxuICB9KSlcblxuICAvLyDqsIEg6re466O5IOuCtCDssLjqsIDsnpDrk6TsnZgg66eM64KoIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgZ3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgIC8vIOq3uOujuSDrsojtmLgg7Z6I7Iqk7Yag66asIOyXheuNsOydtO2KuFxuICAgIGdyb3VwLm1lbWJlcnMuZm9yRWFjaChtZW1iZXIgPT4ge1xuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBtZW1iZXIuaWQpXG4gICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgcGFydGljaXBhbnQuZ3JvdXBIaXN0b3J5IS5wdXNoKGdyb3VwLmlkKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyDshJzroZwg66eM64KcIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgcDEgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBncm91cC5tZW1iZXJzW2ldLmlkKVxuICAgICAgICBjb25zdCBwMiA9IHVwZGF0ZWRQYXJ0aWNpcGFudHMuZmluZChwID0+IHAuaWQgPT09IGdyb3VwLm1lbWJlcnNbal0uaWQpXG4gICAgICAgIFxuICAgICAgICBpZiAocDEgJiYgcDIpIHtcbiAgICAgICAgICBpZiAoIXAxLm1ldFBlb3BsZSEuaW5jbHVkZXMocDIuaWQpKSB7XG4gICAgICAgICAgICBwMS5tZXRQZW9wbGUhLnB1c2gocDIuaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcDIubWV0UGVvcGxlIS5pbmNsdWRlcyhwMS5pZCkpIHtcbiAgICAgICAgICAgIHAyLm1ldFBlb3BsZSEucHVzaChwMS5pZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRQYXJ0aWNpcGFudHNcbn0iXSwibmFtZXMiOlsiaGF2ZU1ldCIsInAxIiwicDIiLCJtZXRQZW9wbGUiLCJpbmNsdWRlcyIsImlkIiwiY2FsY3VsYXRlR3JvdXBCYWxhbmNlIiwiZ3JvdXAiLCJtYWxlQ291bnQiLCJmaWx0ZXIiLCJwIiwiZ2VuZGVyIiwibGVuZ3RoIiwiZmVtYWxlQ291bnQiLCJleHRyb3ZlcnRDb3VudCIsIm1idGkiLCJpbnRyb3ZlcnRDb3VudCIsImdlbmRlckJhbGFuY2UiLCJNYXRoIiwiYWJzIiwibWJ0aUJhbGFuY2UiLCJuZXdNZWV0aW5ncyIsInRvdGFsUGFpcnMiLCJpIiwiaiIsIm5ld01lZXRpbmdTY29yZSIsInNob3VsZEF2b2lkR3JvdXBOdW1iZXIiLCJwYXJ0aWNpcGFudCIsImdyb3VwTnVtYmVyIiwiaGlzdG9yeSIsImdyb3VwSGlzdG9yeSIsImNyZWF0ZU9wdGltYWxHcm91cHMiLCJwYXJ0aWNpcGFudHMiLCJncm91cFNpemUiLCJjdXJyZW50Um91bmQiLCJFcnJvciIsIm51bUdyb3VwcyIsImNlaWwiLCJwb3B1bGF0aW9uU2l6ZSIsImdlbmVyYXRpb25zIiwibXV0YXRpb25SYXRlIiwiY3JlYXRlSW5kaXZpZHVhbCIsImluZGl2aWR1YWwiLCJBcnJheSIsImdyb3VwU2l6ZXMiLCJmaWxsIiwiZ3JvdXBJbmRleCIsImF0dGVtcHRzIiwiZmxvb3IiLCJyYW5kb20iLCJjYWxjdWxhdGVGaXRuZXNzIiwiZ3JvdXBzIiwiZnJvbSIsImZvckVhY2giLCJwYXJ0aWNpcGFudEluZGV4IiwicHVzaCIsInRvdGFsU2NvcmUiLCJ2YWxpZEdyb3VwcyIsImluZGV4T2YiLCJjcm9zc292ZXIiLCJwYXJlbnQxIiwicGFyZW50MiIsImNoaWxkIiwiY3Jvc3NvdmVyUG9pbnQiLCJtdXRhdGUiLCJtdXRhdGVkIiwibmV3R3JvdXAiLCJwb3B1bGF0aW9uIiwiZ2VuZXJhdGlvbiIsImZpdG5lc3NTY29yZXMiLCJtYXAiLCJzb3J0ZWRJbmRpY2VzIiwiZml0bmVzcyIsImluZGV4Iiwic29ydCIsImEiLCJiIiwiZWxpdGVTaXplIiwibmV3UG9wdWxhdGlvbiIsInNsaWNlIiwiaXRlbSIsInBhcmVudDFJbmRleCIsInBhcmVudDJJbmRleCIsImJlc3RJbmRleCIsIm1heCIsImJlc3RTb2x1dGlvbiIsImZpbmFsR3JvdXBzIiwiZ3JvdXBBcnJheXMiLCJuZXdNZWV0aW5nc1RvdGFsIiwidG90YWxHZW5kZXJCYWxhbmNlIiwidG90YWxNYnRpQmFsYW5jZSIsImdyb3VwTWVtYmVycyIsIm1lbWJlcnMiLCJyb3VuZCIsInN1bW1hcnkiLCJ0b3RhbEdyb3VwcyIsImF2Z0dyb3VwU2l6ZSIsImdlbmRlckJhbGFuY2VTY29yZSIsIm1idGlCYWxhbmNlU2NvcmUiLCJuZXdNZWV0aW5nc0NvdW50IiwidXBkYXRlTWVldGluZ0hpc3RvcnkiLCJ1cGRhdGVkUGFydGljaXBhbnRzIiwibWVtYmVyIiwiZmluZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/grouping.ts\n"));

/***/ })

});