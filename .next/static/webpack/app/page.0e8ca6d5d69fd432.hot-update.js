"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/grouping.ts":
/*!*******************************!*\
  !*** ./src/utils/grouping.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOptimalGroups: () => (/* binding */ createOptimalGroups),\n/* harmony export */   updateMeetingHistory: () => (/* binding */ updateMeetingHistory)\n/* harmony export */ });\n// 두 참가자가 이전에 만났는지 확인\nfunction haveMet(p1, p2) {\n    var _p1_metPeople;\n    return ((_p1_metPeople = p1.metPeople) === null || _p1_metPeople === void 0 ? void 0 : _p1_metPeople.includes(p2.id)) || false;\n}\n// 그룹의 균형 점수 계산 (높을수록 좋음)\nfunction calculateGroupBalance(group, groupNumber) {\n    if (group.length === 0) return 0;\n    const maleCount = group.filter((p)=>p.gender === 'male').length;\n    const femaleCount = group.filter((p)=>p.gender === 'female').length;\n    const extrovertCount = group.filter((p)=>p.mbti === 'extrovert').length;\n    const introvertCount = group.filter((p)=>p.mbti === 'introvert').length;\n    // 성별 균형 점수 (0-1)\n    const genderBalance = 1 - Math.abs(maleCount - femaleCount) / group.length;\n    // MBTI 균형 점수 (0-1)\n    const mbtiBalance = 1 - Math.abs(extrovertCount - introvertCount) / group.length;\n    // 새로운 만남 점수\n    let newMeetings = 0;\n    let totalPairs = 0;\n    for(let i = 0; i < group.length; i++){\n        for(let j = i + 1; j < group.length; j++){\n            totalPairs++;\n            if (!haveMet(group[i], group[j])) {\n                newMeetings++;\n            }\n        }\n    }\n    const newMeetingScore = totalPairs > 0 ? newMeetings / totalPairs : 1;\n    // 이전 라운드 그룹 번호 회피 점수\n    let groupAvoidanceScore = 1;\n    if (groupNumber !== undefined) {\n        const membersAvoidingPrevious = group.filter((p)=>!shouldAvoidGroupNumber(p, groupNumber)).length;\n        groupAvoidanceScore = group.length > 0 ? membersAvoidingPrevious / group.length : 1;\n    }\n    // 가중 평균 (성별 균형 60%, 새로운 만남 25%, 그룹 번호 회피 10%, MBTI 균형 5%)\n    return genderBalance * 0.6 + newMeetingScore * 0.25 + groupAvoidanceScore * 0.1 + mbtiBalance * 0.05;\n}\n// 참가자가 이전 라운드와 다른 그룹 번호를 가져야 하는지 확인\nfunction shouldAvoidGroupNumber(participant, groupNumber) {\n    const history = participant.groupHistory || [];\n    return history.length > 0 && history[history.length - 1] === groupNumber;\n}\n// 최적화된 그룹 배치 알고리즘\nfunction createOptimalGroups(participants) {\n    let groupSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, currentRound = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    if (participants.length < 2) {\n        throw new Error('최소 2명 이상의 참가자가 필요합니다.');\n    }\n    console.log(\"그룹 배치 시작: 참가자 \".concat(participants.length, \"명, 그룹 크기 \").concat(groupSize));\n    // 필요한 그룹 수 계산\n    const numGroups = Math.ceil(participants.length / groupSize);\n    console.log(\"필요한 그룹 수: \".concat(numGroups));\n    // 그룹 배열 초기화\n    const groups = Array.from({\n        length: numGroups\n    }, ()=>[]);\n    // 참가자를 그룹에 배치 (이전 라운드 그룹 번호 회피 고려)\n    const shuffledParticipants = [\n        ...participants\n    ].sort(()=>Math.random() - 0.5);\n    // 각 참가자를 적절한 그룹에 배치\n    shuffledParticipants.forEach((participant)=>{\n        let bestGroupIndex = 0;\n        let minGroupSize = groups[0].length;\n        let foundAvoidableGroup = false;\n        // 이전 라운드 그룹 번호를 회피할 수 있는 그룹 찾기\n        for(let i = 0; i < numGroups; i++){\n            const canAvoidPreviousGroup = !shouldAvoidGroupNumber(participant, i + 1);\n            if (canAvoidPreviousGroup && !foundAvoidableGroup) {\n                // 이전 그룹을 회피할 수 있는 첫 번째 그룹\n                bestGroupIndex = i;\n                minGroupSize = groups[i].length;\n                foundAvoidableGroup = true;\n            } else if (canAvoidPreviousGroup && foundAvoidableGroup) {\n                // 이전 그룹을 회피할 수 있는 그룹 중 크기가 더 작은 그룹\n                if (groups[i].length < minGroupSize) {\n                    bestGroupIndex = i;\n                    minGroupSize = groups[i].length;\n                }\n            } else if (!foundAvoidableGroup) {\n                // 이전 그룹을 회피할 수 없다면 가장 작은 그룹\n                if (groups[i].length < minGroupSize) {\n                    bestGroupIndex = i;\n                    minGroupSize = groups[i].length;\n                }\n            }\n        }\n        groups[bestGroupIndex].push(participant);\n    });\n    console.log('초기 배치 완료:', groups.map((g)=>g.length));\n    // 그룹 균형 최적화\n    optimizeGroupBalance(groups, groupSize);\n    console.log('최적화 완료:', groups.map((g)=>g.length));\n    // 결과 구성\n    const finalGroups = groups.map((groupMembers, index)=>{\n        const maleCount = groupMembers.filter((p)=>p.gender === 'male').length;\n        const femaleCount = groupMembers.filter((p)=>p.gender === 'female').length;\n        const extrovertCount = groupMembers.filter((p)=>p.mbti === 'extrovert').length;\n        const introvertCount = groupMembers.filter((p)=>p.mbti === 'introvert').length;\n        return {\n            id: index + 1,\n            members: groupMembers,\n            maleCount,\n            femaleCount,\n            extrovertCount,\n            introvertCount\n        };\n    }).filter((group)=>group.members.length > 0) // 빈 그룹 제거\n    ;\n    // 통계 계산\n    let newMeetingsTotal = 0;\n    let totalGenderBalance = 0;\n    let totalMbtiBalance = 0;\n    finalGroups.forEach((group)=>{\n        const groupMembers = group.members;\n        // 새로운 만남 계산\n        for(let i = 0; i < groupMembers.length; i++){\n            for(let j = i + 1; j < groupMembers.length; j++){\n                if (!haveMet(groupMembers[i], groupMembers[j])) {\n                    newMeetingsTotal++;\n                }\n            }\n        }\n        if (groupMembers.length > 0) {\n            totalGenderBalance += 1 - Math.abs(group.maleCount - group.femaleCount) / groupMembers.length;\n            totalMbtiBalance += 1 - Math.abs(group.extrovertCount - group.introvertCount) / groupMembers.length;\n        }\n    });\n    console.log(\"최종 그룹 수: \".concat(finalGroups.length));\n    console.log('각 그룹 크기:', finalGroups.map((g)=>g.members.length));\n    return {\n        groups: finalGroups,\n        round: currentRound,\n        summary: {\n            totalGroups: finalGroups.length,\n            avgGroupSize: finalGroups.length > 0 ? participants.length / finalGroups.length : 0,\n            genderBalanceScore: finalGroups.length > 0 ? Math.round(totalGenderBalance / finalGroups.length * 100) : 0,\n            mbtiBalanceScore: finalGroups.length > 0 ? Math.round(totalMbtiBalance / finalGroups.length * 100) : 0,\n            newMeetingsCount: newMeetingsTotal\n        }\n    };\n}\n// 그룹 균형 최적화 함수\nfunction optimizeGroupBalance(groups, targetGroupSize) {\n    const maxIterations = 50;\n    for(let iteration = 0; iteration < maxIterations; iteration++){\n        let improved = false;\n        // 그룹 크기 균형 맞추기\n        for(let i = 0; i < groups.length; i++){\n            for(let j = 0; j < groups.length; j++){\n                if (i === j) continue;\n                const group1 = groups[i];\n                const group2 = groups[j];\n                // 크기 차이가 2 이상인 경우 조정\n                if (group1.length - group2.length >= 2) {\n                    // group1에서 group2로 한 명 이동\n                    if (group1.length > 1) {\n                        const memberToMove = group1.pop();\n                        if (memberToMove) {\n                            group2.push(memberToMove);\n                            improved = true;\n                        }\n                    }\n                }\n            }\n        }\n        // 성별 균형 개선\n        for(let i = 0; i < groups.length; i++){\n            for(let j = i + 1; j < groups.length; j++){\n                const group1 = groups[i];\n                const group2 = groups[j];\n                if (group1.length === 0 || group2.length === 0) continue;\n                const g1Males = group1.filter((p)=>p.gender === 'male').length;\n                const g1Females = group1.filter((p)=>p.gender === 'female').length;\n                const g2Males = group2.filter((p)=>p.gender === 'male').length;\n                const g2Females = group2.filter((p)=>p.gender === 'female').length;\n                // 성별 불균형이 있는 경우 교환 시도\n                if (Math.abs(g1Males - g1Females) > 1 || Math.abs(g2Males - g2Females) > 1) {\n                    for(let p1 = 0; p1 < group1.length; p1++){\n                        for(let p2 = 0; p2 < group2.length; p2++){\n                            if (group1[p1].gender !== group2[p2].gender) {\n                                // 교환 시도\n                                const oldBalance1 = Math.abs(g1Males - g1Females);\n                                const oldBalance2 = Math.abs(g2Males - g2Females);\n                                const oldTotalBalance = oldBalance1 + oldBalance2;\n                                // 교환해보기\n                                const temp = group1[p1];\n                                group1[p1] = group2[p2];\n                                group2[p2] = temp;\n                                const newG1Males = group1.filter((p)=>p.gender === 'male').length;\n                                const newG1Females = group1.filter((p)=>p.gender === 'female').length;\n                                const newG2Males = group2.filter((p)=>p.gender === 'male').length;\n                                const newG2Females = group2.filter((p)=>p.gender === 'female').length;\n                                const newBalance1 = Math.abs(newG1Males - newG1Females);\n                                const newBalance2 = Math.abs(newG2Males - newG2Females);\n                                const newTotalBalance = newBalance1 + newBalance2;\n                                if (newTotalBalance < oldTotalBalance) {\n                                    improved = true;\n                                    break;\n                                } else {\n                                    // 되돌리기\n                                    const temp2 = group1[p1];\n                                    group1[p1] = group2[p2];\n                                    group2[p2] = temp2;\n                                }\n                            }\n                        }\n                        if (improved) break;\n                    }\n                }\n                if (improved) break;\n            }\n            if (improved) break;\n        }\n        if (!improved) break;\n    }\n}\n// 만남 히스토리 업데이트\nfunction updateMeetingHistory(participants, groups, round) {\n    const updatedParticipants = participants.map((p)=>({\n            ...p,\n            metPeople: [\n                ...p.metPeople || []\n            ],\n            groupHistory: [\n                ...p.groupHistory || []\n            ]\n        }));\n    // 각 그룹 내 참가자들의 만남 기록 업데이트\n    groups.forEach((group)=>{\n        // 그룹 번호 히스토리 업데이트\n        group.members.forEach((member)=>{\n            const participant = updatedParticipants.find((p)=>p.id === member.id);\n            if (participant) {\n                participant.groupHistory.push(group.id);\n            }\n        });\n        // 서로 만난 기록 업데이트\n        for(let i = 0; i < group.members.length; i++){\n            for(let j = i + 1; j < group.members.length; j++){\n                const p1 = updatedParticipants.find((p)=>p.id === group.members[i].id);\n                const p2 = updatedParticipants.find((p)=>p.id === group.members[j].id);\n                if (p1 && p2) {\n                    if (!p1.metPeople.includes(p2.id)) {\n                        p1.metPeople.push(p2.id);\n                    }\n                    if (!p2.metPeople.includes(p1.id)) {\n                        p2.metPeople.push(p1.id);\n                    }\n                }\n            }\n        }\n    });\n    return updatedParticipants;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ncm91cGluZy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQThCQSxxQkFBcUI7QUFDckIsU0FBU0EsUUFBUUMsRUFBZSxFQUFFQyxFQUFlO1FBQ3hDRDtJQUFQLE9BQU9BLEVBQUFBLGdCQUFBQSxHQUFHRSxTQUFTLGNBQVpGLG9DQUFBQSxjQUFjRyxRQUFRLENBQUNGLEdBQUdHLEVBQUUsTUFBSztBQUMxQztBQUVBLHlCQUF5QjtBQUN6QixTQUFTQyxzQkFBc0JDLEtBQW9CLEVBQUVDLFdBQW9CO0lBQ3ZFLElBQUlELE1BQU1FLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFL0IsTUFBTUMsWUFBWUgsTUFBTUksTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssUUFBUUosTUFBTTtJQUMvRCxNQUFNSyxjQUFjUCxNQUFNSSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxVQUFVSixNQUFNO0lBQ25FLE1BQU1NLGlCQUFpQlIsTUFBTUksTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFSSxJQUFJLEtBQUssYUFBYVAsTUFBTTtJQUN2RSxNQUFNUSxpQkFBaUJWLE1BQU1JLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUksSUFBSSxLQUFLLGFBQWFQLE1BQU07SUFFdkUsaUJBQWlCO0lBQ2pCLE1BQU1TLGdCQUFnQixJQUFJQyxLQUFLQyxHQUFHLENBQUNWLFlBQVlJLGVBQWVQLE1BQU1FLE1BQU07SUFFMUUsbUJBQW1CO0lBQ25CLE1BQU1ZLGNBQWMsSUFBSUYsS0FBS0MsR0FBRyxDQUFDTCxpQkFBaUJFLGtCQUFrQlYsTUFBTUUsTUFBTTtJQUVoRixZQUFZO0lBQ1osSUFBSWEsY0FBYztJQUNsQixJQUFJQyxhQUFhO0lBQ2pCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJakIsTUFBTUUsTUFBTSxFQUFFZSxJQUFLO1FBQ3JDLElBQUssSUFBSUMsSUFBSUQsSUFBSSxH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VCIsInNvdXJjZXMiOlsiL1VzZXJzL2RvaHllb25hbi9zaWRlUHJvamVjdHMvc29jaWFsaW5nU2VhdEFzc2lnbmVyL3NyYy91dGlscy9ncm91cGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFBhcnRpY2lwYW50IHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgZ2VuZGVyOiAnbWFsZScgfCAnZmVtYWxlJ1xuICBtYnRpOiAnZXh0cm92ZXJ0JyB8ICdpbnRyb3ZlcnQnXG4gIG1ldFBlb3BsZT86IHN0cmluZ1tdXG4gIGdyb3VwSGlzdG9yeT86IG51bWJlcltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXAge1xuICBpZDogbnVtYmVyXG4gIG1lbWJlcnM6IFBhcnRpY2lwYW50W11cbiAgbWFsZUNvdW50OiBudW1iZXJcbiAgZmVtYWxlQ291bnQ6IG51bWJlclxuICBleHRyb3ZlcnRDb3VudDogbnVtYmVyXG4gIGludHJvdmVydENvdW50OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91cGluZ1Jlc3VsdCB7XG4gIGdyb3VwczogR3JvdXBbXVxuICByb3VuZDogbnVtYmVyXG4gIHN1bW1hcnk6IHtcbiAgICB0b3RhbEdyb3VwczogbnVtYmVyXG4gICAgYXZnR3JvdXBTaXplOiBudW1iZXJcbiAgICBnZW5kZXJCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG1idGlCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG5ld01lZXRpbmdzQ291bnQ6IG51bWJlclxuICB9XG59XG5cbi8vIOuRkCDssLjqsIDsnpDqsIAg7J207KCE7JeQIOunjOuCrOuKlOyngCDtmZXsnbhcbmZ1bmN0aW9uIGhhdmVNZXQocDE6IFBhcnRpY2lwYW50LCBwMjogUGFydGljaXBhbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIHAxLm1ldFBlb3BsZT8uaW5jbHVkZXMocDIuaWQpIHx8IGZhbHNlXG59XG5cbi8vIOq3uOujueydmCDqt6DtmJUg7KCQ7IiYIOqzhOyCsCAo64aS7J2E7IiY66GdIOyii+ydjClcbmZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VwQmFsYW5jZShncm91cDogUGFydGljaXBhbnRbXSwgZ3JvdXBOdW1iZXI/OiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoZ3JvdXAubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuICBcbiAgY29uc3QgbWFsZUNvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gIGNvbnN0IGZlbWFsZUNvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdmZW1hbGUnKS5sZW5ndGhcbiAgY29uc3QgZXh0cm92ZXJ0Q291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdleHRyb3ZlcnQnKS5sZW5ndGhcbiAgY29uc3QgaW50cm92ZXJ0Q291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdpbnRyb3ZlcnQnKS5sZW5ndGhcbiAgXG4gIC8vIOyEseuzhCDqt6DtmJUg7KCQ7IiYICgwLTEpXG4gIGNvbnN0IGdlbmRlckJhbGFuY2UgPSAxIC0gTWF0aC5hYnMobWFsZUNvdW50IC0gZmVtYWxlQ291bnQpIC8gZ3JvdXAubGVuZ3RoXG4gIFxuICAvLyBNQlRJIOq3oO2YlSDsoJDsiJggKDAtMSlcbiAgY29uc3QgbWJ0aUJhbGFuY2UgPSAxIC0gTWF0aC5hYnMoZXh0cm92ZXJ0Q291bnQgLSBpbnRyb3ZlcnRDb3VudCkgLyBncm91cC5sZW5ndGhcbiAgXG4gIC8vIOyDiOuhnOyatCDrp4zrgqgg7KCQ7IiYXG4gIGxldCBuZXdNZWV0aW5ncyA9IDBcbiAgbGV0IHRvdGFsUGFpcnMgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBncm91cC5sZW5ndGg7IGorKykge1xuICAgICAgdG90YWxQYWlycysrXG4gICAgICBpZiAoIWhhdmVNZXQoZ3JvdXBbaV0sIGdyb3VwW2pdKSkge1xuICAgICAgICBuZXdNZWV0aW5ncysrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld01lZXRpbmdTY29yZSA9IHRvdGFsUGFpcnMgPiAwID8gbmV3TWVldGluZ3MgLyB0b3RhbFBhaXJzIDogMVxuICBcbiAgLy8g7J207KCEIOudvOyatOuTnCDqt7jro7kg67KI7Zi4IO2ajO2UvCDsoJDsiJhcbiAgbGV0IGdyb3VwQXZvaWRhbmNlU2NvcmUgPSAxXG4gIGlmIChncm91cE51bWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbWVtYmVyc0F2b2lkaW5nUHJldmlvdXMgPSBncm91cC5maWx0ZXIocCA9PiAhc2hvdWxkQXZvaWRHcm91cE51bWJlcihwLCBncm91cE51bWJlcikpLmxlbmd0aFxuICAgIGdyb3VwQXZvaWRhbmNlU2NvcmUgPSBncm91cC5sZW5ndGggPiAwID8gbWVtYmVyc0F2b2lkaW5nUHJldmlvdXMgLyBncm91cC5sZW5ndGggOiAxXG4gIH1cbiAgXG4gIC8vIOqwgOykkSDtj4nqt6AgKOyEseuzhCDqt6DtmJUgNjAlLCDsg4jroZzsmrQg66eM64KoIDI1JSwg6re466O5IOuyiO2YuCDtmoztlLwgMTAlLCBNQlRJIOq3oO2YlSA1JSlcbiAgcmV0dXJuIGdlbmRlckJhbGFuY2UgKiAwLjYgKyBuZXdNZWV0aW5nU2NvcmUgKiAwLjI1ICsgZ3JvdXBBdm9pZGFuY2VTY29yZSAqIDAuMSArIG1idGlCYWxhbmNlICogMC4wNVxufVxuXG4vLyDssLjqsIDsnpDqsIAg7J207KCEIOudvOyatOuTnOyZgCDri6Trpbgg6re466O5IOuyiO2YuOulvCDqsIDsoLjslbwg7ZWY64qU7KeAIO2ZleyduFxuZnVuY3Rpb24gc2hvdWxkQXZvaWRHcm91cE51bWJlcihwYXJ0aWNpcGFudDogUGFydGljaXBhbnQsIGdyb3VwTnVtYmVyOiBudW1iZXIpOiBib29sZWFuIHtcbiAgY29uc3QgaGlzdG9yeSA9IHBhcnRpY2lwYW50Lmdyb3VwSGlzdG9yeSB8fCBbXVxuICByZXR1cm4gaGlzdG9yeS5sZW5ndGggPiAwICYmIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXSA9PT0gZ3JvdXBOdW1iZXJcbn1cblxuLy8g7LWc7KCB7ZmU65CcIOq3uOujuSDrsLDsuZgg7JWM6rOg66as7KaYXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3B0aW1hbEdyb3VwcyhcbiAgcGFydGljaXBhbnRzOiBQYXJ0aWNpcGFudFtdLCBcbiAgZ3JvdXBTaXplOiBudW1iZXIgPSA0LFxuICBjdXJyZW50Um91bmQ6IG51bWJlciA9IDFcbik6IEdyb3VwaW5nUmVzdWx0IHtcbiAgaWYgKHBhcnRpY2lwYW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCfstZzshowgMuuqhSDsnbTsg4HsnZgg7LC46rCA7J6Q6rCAIO2VhOyalO2VqeuLiOuLpC4nKVxuICB9XG5cbiAgY29uc29sZS5sb2coYOq3uOujuSDrsLDsuZgg7Iuc7J6ROiDssLjqsIDsnpAgJHtwYXJ0aWNpcGFudHMubGVuZ3RofeuqhSwg6re466O5IO2BrOq4sCAke2dyb3VwU2l6ZX1gKVxuXG4gIC8vIO2VhOyalO2VnCDqt7jro7kg7IiYIOqzhOyCsFxuICBjb25zdCBudW1Hcm91cHMgPSBNYXRoLmNlaWwocGFydGljaXBhbnRzLmxlbmd0aCAvIGdyb3VwU2l6ZSlcbiAgY29uc29sZS5sb2coYO2VhOyalO2VnCDqt7jro7kg7IiYOiAke251bUdyb3Vwc31gKVxuXG4gIC8vIOq3uOujuSDrsLDsl7Qg7LSI6riw7ZmUXG4gIGNvbnN0IGdyb3VwczogUGFydGljaXBhbnRbXVtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtR3JvdXBzIH0sICgpID0+IFtdKVxuXG4gIC8vIOywuOqwgOyekOulvCDqt7jro7nsl5Ag67Cw7LmYICjsnbTsoIQg65287Jq065OcIOq3uOujuSDrsojtmLgg7ZqM7ZS8IOqzoOugpClcbiAgY29uc3Qgc2h1ZmZsZWRQYXJ0aWNpcGFudHMgPSBbLi4ucGFydGljaXBhbnRzXS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpXG4gIFxuICAvLyDqsIEg7LC46rCA7J6Q66W8IOyggeygiO2VnCDqt7jro7nsl5Ag67Cw7LmYXG4gIHNodWZmbGVkUGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgbGV0IGJlc3RHcm91cEluZGV4ID0gMFxuICAgIGxldCBtaW5Hcm91cFNpemUgPSBncm91cHNbMF0ubGVuZ3RoXG4gICAgbGV0IGZvdW5kQXZvaWRhYmxlR3JvdXAgPSBmYWxzZVxuICAgIFxuICAgIC8vIOydtOyghCDrnbzsmrTrk5wg6re466O5IOuyiO2YuOulvCDtmoztlLztlaAg7IiYIOyeiOuKlCDqt7jro7kg7LC+6riwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Hcm91cHM7IGkrKykge1xuICAgICAgY29uc3QgY2FuQXZvaWRQcmV2aW91c0dyb3VwID0gIXNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQsIGkgKyAxKVxuICAgICAgXG4gICAgICBpZiAoY2FuQXZvaWRQcmV2aW91c0dyb3VwICYmICFmb3VuZEF2b2lkYWJsZUdyb3VwKSB7XG4gICAgICAgIC8vIOydtOyghCDqt7jro7nsnYQg7ZqM7ZS87ZWgIOyImCDsnojripQg7LKrIOuyiOynuCDqt7jro7lcbiAgICAgICAgYmVzdEdyb3VwSW5kZXggPSBpXG4gICAgICAgIG1pbkdyb3VwU2l6ZSA9IGdyb3Vwc1tpXS5sZW5ndGhcbiAgICAgICAgZm91bmRBdm9pZGFibGVHcm91cCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoY2FuQXZvaWRQcmV2aW91c0dyb3VwICYmIGZvdW5kQXZvaWRhYmxlR3JvdXApIHtcbiAgICAgICAgLy8g7J207KCEIOq3uOujueydhCDtmoztlLztlaAg7IiYIOyeiOuKlCDqt7jro7kg7KSRIO2BrOq4sOqwgCDrjZQg7J6R7J2AIOq3uOujuVxuICAgICAgICBpZiAoZ3JvdXBzW2ldLmxlbmd0aCA8IG1pbkdyb3VwU2l6ZSkge1xuICAgICAgICAgIGJlc3RHcm91cEluZGV4ID0gaVxuICAgICAgICAgIG1pbkdyb3VwU2l6ZSA9IGdyb3Vwc1tpXS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghZm91bmRBdm9pZGFibGVHcm91cCkge1xuICAgICAgICAvLyDsnbTsoIQg6re466O57J2EIO2ajO2UvO2VoCDsiJgg7JeG64uk66m0IOqwgOyepSDsnpHsnYAg6re466O5XG4gICAgICAgIGlmIChncm91cHNbaV0ubGVuZ3RoIDwgbWluR3JvdXBTaXplKSB7XG4gICAgICAgICAgYmVzdEdyb3VwSW5kZXggPSBpXG4gICAgICAgICAgbWluR3JvdXBTaXplID0gZ3JvdXBzW2ldLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGdyb3Vwc1tiZXN0R3JvdXBJbmRleF0ucHVzaChwYXJ0aWNpcGFudClcbiAgfSlcblxuICBjb25zb2xlLmxvZygn7LSI6riwIOuwsOy5mCDsmYTro4w6JywgZ3JvdXBzLm1hcChnID0+IGcubGVuZ3RoKSlcblxuICAvLyDqt7jro7kg6reg7ZiVIOy1nOygge2ZlFxuICBvcHRpbWl6ZUdyb3VwQmFsYW5jZShncm91cHMsIGdyb3VwU2l6ZSlcblxuICBjb25zb2xlLmxvZygn7LWc7KCB7ZmUIOyZhOujjDonLCBncm91cHMubWFwKGcgPT4gZy5sZW5ndGgpKVxuXG4gIC8vIOqysOqzvCDqtazshLFcbiAgY29uc3QgZmluYWxHcm91cHM6IEdyb3VwW10gPSBncm91cHMubWFwKChncm91cE1lbWJlcnMsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgbWFsZUNvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnbWFsZScpLmxlbmd0aFxuICAgIGNvbnN0IGZlbWFsZUNvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgY29uc3QgZXh0cm92ZXJ0Q291bnQgPSBncm91cE1lbWJlcnMuZmlsdGVyKHAgPT4gcC5tYnRpID09PSAnZXh0cm92ZXJ0JykubGVuZ3RoXG4gICAgY29uc3QgaW50cm92ZXJ0Q291bnQgPSBncm91cE1lbWJlcnMuZmlsdGVyKHAgPT4gcC5tYnRpID09PSAnaW50cm92ZXJ0JykubGVuZ3RoXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBpbmRleCArIDEsXG4gICAgICBtZW1iZXJzOiBncm91cE1lbWJlcnMsXG4gICAgICBtYWxlQ291bnQsXG4gICAgICBmZW1hbGVDb3VudCxcbiAgICAgIGV4dHJvdmVydENvdW50LFxuICAgICAgaW50cm92ZXJ0Q291bnRcbiAgICB9XG4gIH0pLmZpbHRlcihncm91cCA9PiBncm91cC5tZW1iZXJzLmxlbmd0aCA+IDApIC8vIOu5iCDqt7jro7kg7KCc6rGwXG5cbiAgLy8g7Ya16rOEIOqzhOyCsFxuICBsZXQgbmV3TWVldGluZ3NUb3RhbCA9IDBcbiAgbGV0IHRvdGFsR2VuZGVyQmFsYW5jZSA9IDBcbiAgbGV0IHRvdGFsTWJ0aUJhbGFuY2UgPSAwXG4gIFxuICBmaW5hbEdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICBjb25zdCBncm91cE1lbWJlcnMgPSBncm91cC5tZW1iZXJzXG4gICAgXG4gICAgLy8g7IOI66Gc7Jq0IOunjOuCqCDqs4TsgrBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwTWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ3JvdXBNZW1iZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghaGF2ZU1ldChncm91cE1lbWJlcnNbaV0sIGdyb3VwTWVtYmVyc1tqXSkpIHtcbiAgICAgICAgICBuZXdNZWV0aW5nc1RvdGFsKytcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoZ3JvdXBNZW1iZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRvdGFsR2VuZGVyQmFsYW5jZSArPSAxIC0gTWF0aC5hYnMoZ3JvdXAubWFsZUNvdW50IC0gZ3JvdXAuZmVtYWxlQ291bnQpIC8gZ3JvdXBNZW1iZXJzLmxlbmd0aFxuICAgICAgdG90YWxNYnRpQmFsYW5jZSArPSAxIC0gTWF0aC5hYnMoZ3JvdXAuZXh0cm92ZXJ0Q291bnQgLSBncm91cC5pbnRyb3ZlcnRDb3VudCkgLyBncm91cE1lbWJlcnMubGVuZ3RoXG4gICAgfVxuICB9KVxuXG4gIGNvbnNvbGUubG9nKGDstZzsooUg6re466O5IOyImDogJHtmaW5hbEdyb3Vwcy5sZW5ndGh9YClcbiAgY29uc29sZS5sb2coJ+qwgSDqt7jro7kg7YGs6riwOicsIGZpbmFsR3JvdXBzLm1hcChnID0+IGcubWVtYmVycy5sZW5ndGgpKVxuXG4gIHJldHVybiB7XG4gICAgZ3JvdXBzOiBmaW5hbEdyb3VwcyxcbiAgICByb3VuZDogY3VycmVudFJvdW5kLFxuICAgIHN1bW1hcnk6IHtcbiAgICAgIHRvdGFsR3JvdXBzOiBmaW5hbEdyb3Vwcy5sZW5ndGgsXG4gICAgICBhdmdHcm91cFNpemU6IGZpbmFsR3JvdXBzLmxlbmd0aCA+IDAgPyBwYXJ0aWNpcGFudHMubGVuZ3RoIC8gZmluYWxHcm91cHMubGVuZ3RoIDogMCxcbiAgICAgIGdlbmRlckJhbGFuY2VTY29yZTogZmluYWxHcm91cHMubGVuZ3RoID4gMCA/IE1hdGgucm91bmQoKHRvdGFsR2VuZGVyQmFsYW5jZSAvIGZpbmFsR3JvdXBzLmxlbmd0aCkgKiAxMDApIDogMCxcbiAgICAgIG1idGlCYWxhbmNlU2NvcmU6IGZpbmFsR3JvdXBzLmxlbmd0aCA+IDAgPyBNYXRoLnJvdW5kKCh0b3RhbE1idGlCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCkgOiAwLFxuICAgICAgbmV3TWVldGluZ3NDb3VudDogbmV3TWVldGluZ3NUb3RhbFxuICAgIH1cbiAgfVxufVxuXG4vLyDqt7jro7kg6reg7ZiVIOy1nOygge2ZlCDtlajsiJhcbmZ1bmN0aW9uIG9wdGltaXplR3JvdXBCYWxhbmNlKGdyb3VwczogUGFydGljaXBhbnRbXVtdLCB0YXJnZXRHcm91cFNpemU6IG51bWJlcikge1xuICBjb25zdCBtYXhJdGVyYXRpb25zID0gNTBcbiAgXG4gIGZvciAobGV0IGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgbGV0IGltcHJvdmVkID0gZmFsc2VcbiAgICBcbiAgICAvLyDqt7jro7kg7YGs6riwIOq3oO2YlSDrp57stpTquLBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGkgPT09IGopIGNvbnRpbnVlXG4gICAgICAgIFxuICAgICAgICBjb25zdCBncm91cDEgPSBncm91cHNbaV1cbiAgICAgICAgY29uc3QgZ3JvdXAyID0gZ3JvdXBzW2pdXG4gICAgICAgIFxuICAgICAgICAvLyDtgazquLAg7LCo7J206rCAIDIg7J207IOB7J24IOqyveyasCDsobDsoJVcbiAgICAgICAgaWYgKGdyb3VwMS5sZW5ndGggLSBncm91cDIubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAvLyBncm91cDHsl5DshJwgZ3JvdXAy66GcIO2VnCDrqoUg7J2064+ZXG4gICAgICAgICAgaWYgKGdyb3VwMS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBtZW1iZXJUb01vdmUgPSBncm91cDEucG9wKClcbiAgICAgICAgICAgIGlmIChtZW1iZXJUb01vdmUpIHtcbiAgICAgICAgICAgICAgZ3JvdXAyLnB1c2gobWVtYmVyVG9Nb3ZlKVxuICAgICAgICAgICAgICBpbXByb3ZlZCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8g7ISx67OEIOq3oO2YlSDqsJzshKBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ3JvdXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwMSA9IGdyb3Vwc1tpXVxuICAgICAgICBjb25zdCBncm91cDIgPSBncm91cHNbal1cbiAgICAgICAgXG4gICAgICAgIGlmIChncm91cDEubGVuZ3RoID09PSAwIHx8IGdyb3VwMi5sZW5ndGggPT09IDApIGNvbnRpbnVlXG4gICAgICAgIFxuICAgICAgICBjb25zdCBnMU1hbGVzID0gZ3JvdXAxLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnbWFsZScpLmxlbmd0aFxuICAgICAgICBjb25zdCBnMUZlbWFsZXMgPSBncm91cDEuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdmZW1hbGUnKS5sZW5ndGhcbiAgICAgICAgY29uc3QgZzJNYWxlcyA9IGdyb3VwMi5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICAgICAgY29uc3QgZzJGZW1hbGVzID0gZ3JvdXAyLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgICAgIFxuICAgICAgICAvLyDshLHrs4Qg67aI6reg7ZiV7J20IOyeiOuKlCDqsr3smrAg6rWQ7ZmYIOyLnOuPhFxuICAgICAgICBpZiAoTWF0aC5hYnMoZzFNYWxlcyAtIGcxRmVtYWxlcykgPiAxIHx8IE1hdGguYWJzKGcyTWFsZXMgLSBnMkZlbWFsZXMpID4gMSkge1xuICAgICAgICAgIGZvciAobGV0IHAxID0gMDsgcDEgPCBncm91cDEubGVuZ3RoOyBwMSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwMiA9IDA7IHAyIDwgZ3JvdXAyLmxlbmd0aDsgcDIrKykge1xuICAgICAgICAgICAgICBpZiAoZ3JvdXAxW3AxXS5nZW5kZXIgIT09IGdyb3VwMltwMl0uZ2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8g6rWQ7ZmYIOyLnOuPhFxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEJhbGFuY2UxID0gTWF0aC5hYnMoZzFNYWxlcyAtIGcxRmVtYWxlcylcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRCYWxhbmNlMiA9IE1hdGguYWJzKGcyTWFsZXMgLSBnMkZlbWFsZXMpXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVG90YWxCYWxhbmNlID0gb2xkQmFsYW5jZTEgKyBvbGRCYWxhbmNlMlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIOq1kO2ZmO2VtOuztOq4sFxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBncm91cDFbcDFdXG4gICAgICAgICAgICAgICAgZ3JvdXAxW3AxXSA9IGdyb3VwMltwMl1cbiAgICAgICAgICAgICAgICBncm91cDJbcDJdID0gdGVtcFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0cxTWFsZXMgPSBncm91cDEuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RzFGZW1hbGVzID0gZ3JvdXAxLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RzJNYWxlcyA9IGdyb3VwMi5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdHMkZlbWFsZXMgPSBncm91cDIuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdmZW1hbGUnKS5sZW5ndGhcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdCYWxhbmNlMSA9IE1hdGguYWJzKG5ld0cxTWFsZXMgLSBuZXdHMUZlbWFsZXMpXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QmFsYW5jZTIgPSBNYXRoLmFicyhuZXdHMk1hbGVzIC0gbmV3RzJGZW1hbGVzKVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RvdGFsQmFsYW5jZSA9IG5ld0JhbGFuY2UxICsgbmV3QmFsYW5jZTJcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobmV3VG90YWxCYWxhbmNlIDwgb2xkVG90YWxCYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICBpbXByb3ZlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIOuQmOuPjOumrOq4sFxuICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcDIgPSBncm91cDFbcDFdXG4gICAgICAgICAgICAgICAgICBncm91cDFbcDFdID0gZ3JvdXAyW3AyXVxuICAgICAgICAgICAgICAgICAgZ3JvdXAyW3AyXSA9IHRlbXAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1wcm92ZWQpIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbXByb3ZlZCkgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpbXByb3ZlZCkgYnJlYWtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFpbXByb3ZlZCkgYnJlYWtcbiAgfVxufVxuXG4vLyDrp4zrgqgg7Z6I7Iqk7Yag66asIOyXheuNsOydtO2KuFxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU1lZXRpbmdIaXN0b3J5KFxuICBwYXJ0aWNpcGFudHM6IFBhcnRpY2lwYW50W10sIFxuICBncm91cHM6IEdyb3VwW10sIFxuICByb3VuZDogbnVtYmVyXG4pOiBQYXJ0aWNpcGFudFtdIHtcbiAgY29uc3QgdXBkYXRlZFBhcnRpY2lwYW50cyA9IHBhcnRpY2lwYW50cy5tYXAocCA9PiAoe1xuICAgIC4uLnAsXG4gICAgbWV0UGVvcGxlOiBbLi4uKHAubWV0UGVvcGxlIHx8IFtdKV0sXG4gICAgZ3JvdXBIaXN0b3J5OiBbLi4uKHAuZ3JvdXBIaXN0b3J5IHx8IFtdKV1cbiAgfSkpXG5cbiAgLy8g6rCBIOq3uOujuSDrgrQg7LC46rCA7J6Q65Ok7J2YIOunjOuCqCDquLDroZ0g7JeF642w7J207Yq4XG4gIGdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICAvLyDqt7jro7kg67KI7Zi4IO2eiOyKpO2GoOumrCDsl4XrjbDsnbTtirhcbiAgICBncm91cC5tZW1iZXJzLmZvckVhY2gobWVtYmVyID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdXBkYXRlZFBhcnRpY2lwYW50cy5maW5kKHAgPT4gcC5pZCA9PT0gbWVtYmVyLmlkKVxuICAgICAgaWYgKHBhcnRpY2lwYW50KSB7XG4gICAgICAgIHBhcnRpY2lwYW50Lmdyb3VwSGlzdG9yeSEucHVzaChncm91cC5pZClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8g7ISc66GcIOunjOuCnCDquLDroZ0g7JeF642w7J207Yq4XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBncm91cC5tZW1iZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHAxID0gdXBkYXRlZFBhcnRpY2lwYW50cy5maW5kKHAgPT4gcC5pZCA9PT0gZ3JvdXAubWVtYmVyc1tpXS5pZClcbiAgICAgICAgY29uc3QgcDIgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBncm91cC5tZW1iZXJzW2pdLmlkKVxuICAgICAgICBcbiAgICAgICAgaWYgKHAxICYmIHAyKSB7XG4gICAgICAgICAgaWYgKCFwMS5tZXRQZW9wbGUhLmluY2x1ZGVzKHAyLmlkKSkge1xuICAgICAgICAgICAgcDEubWV0UGVvcGxlIS5wdXNoKHAyLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXAyLm1ldFBlb3BsZSEuaW5jbHVkZXMocDEuaWQpKSB7XG4gICAgICAgICAgICBwMi5tZXRQZW9wbGUhLnB1c2gocDEuaWQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB1cGRhdGVkUGFydGljaXBhbnRzXG59Il0sIm5hbWVzIjpbImhhdmVNZXQiLCJwMSIsInAyIiwibWV0UGVvcGxlIiwiaW5jbHVkZXMiLCJpZCIsImNhbGN1bGF0ZUdyb3VwQmFsYW5jZSIsImdyb3VwIiwiZ3JvdXBOdW1iZXIiLCJsZW5ndGgiLCJtYWxlQ291bnQiLCJmaWx0ZXIiLCJwIiwiZ2VuZGVyIiwiZmVtYWxlQ291bnQiLCJleHRyb3ZlcnRDb3VudCIsIm1idGkiLCJpbnRyb3ZlcnRDb3VudCIsImdlbmRlckJhbGFuY2UiLCJNYXRoIiwiYWJzIiwibWJ0aUJhbGFuY2UiLCJuZXdNZWV0aW5ncyIsInRvdGFsUGFpcnMiLCJpIiwiaiIsIm5ld01lZXRpbmdTY29yZSIsImdyb3VwQXZvaWRhbmNlU2NvcmUiLCJ1bmRlZmluZWQiLCJtZW1iZXJzQXZvaWRpbmdQcmV2aW91cyIsInNob3VsZEF2b2lkR3JvdXBOdW1iZXIiLCJwYXJ0aWNpcGFudCIsImhpc3RvcnkiLCJncm91cEhpc3RvcnkiLCJjcmVhdGVPcHRpbWFsR3JvdXBzIiwicGFydGljaXBhbnRzIiwiZ3JvdXBTaXplIiwiY3VycmVudFJvdW5kIiwiRXJyb3IiLCJjb25zb2xlIiwibG9nIiwibnVtR3JvdXBzIiwiY2VpbCIsImdyb3VwcyIsIkFycmF5IiwiZnJvbSIsInNodWZmbGVkUGFydGljaXBhbnRzIiwic29ydCIsInJhbmRvbSIsImZvckVhY2giLCJiZXN0R3JvdXBJbmRleCIsIm1pbkdyb3VwU2l6ZSIsImZvdW5kQXZvaWRhYmxlR3JvdXAiLCJjYW5Bdm9pZFByZXZpb3VzR3JvdXAiLCJwdXNoIiwibWFwIiwiZyIsIm9wdGltaXplR3JvdXBCYWxhbmNlIiwiZmluYWxHcm91cHMiLCJncm91cE1lbWJlcnMiLCJpbmRleCIsIm1lbWJlcnMiLCJuZXdNZWV0aW5nc1RvdGFsIiwidG90YWxHZW5kZXJCYWxhbmNlIiwidG90YWxNYnRpQmFsYW5jZSIsInJvdW5kIiwic3VtbWFyeSIsInRvdGFsR3JvdXBzIiwiYXZnR3JvdXBTaXplIiwiZ2VuZGVyQmFsYW5jZVNjb3JlIiwibWJ0aUJhbGFuY2VTY29yZSIsIm5ld01lZXRpbmdzQ291bnQiLCJ0YXJnZXRHcm91cFNpemUiLCJtYXhJdGVyYXRpb25zIiwiaXRlcmF0aW9uIiwiaW1wcm92ZWQiLCJncm91cDEiLCJncm91cDIiLCJtZW1iZXJUb01vdmUiLCJwb3AiLCJnMU1hbGVzIiwiZzFGZW1hbGVzIiwiZzJNYWxlcyIsImcyRmVtYWxlcyIsIm9sZEJhbGFuY2UxIiwib2xkQmFsYW5jZTIiLCJvbGRUb3RhbEJhbGFuY2UiLCJ0ZW1wIiwibmV3RzFNYWxlcyIsIm5ld0cxRmVtYWxlcyIsIm5ld0cyTWFsZXMiLCJuZXdHMkZlbWFsZXMiLCJuZXdCYWxhbmNlMSIsIm5ld0JhbGFuY2UyIiwibmV3VG90YWxCYWxhbmNlIiwidGVtcDIiLCJ1cGRhdGVNZWV0aW5nSGlzdG9yeSIsInVwZGF0ZWRQYXJ0aWNpcGFudHMiLCJtZW1iZXIiLCJmaW5kIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/grouping.ts\n"));

/***/ })

});