"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/grouping.ts":
/*!*******************************!*\
  !*** ./src/utils/grouping.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOptimalGroups: () => (/* binding */ createOptimalGroups),\n/* harmony export */   updateMeetingHistory: () => (/* binding */ updateMeetingHistory)\n/* harmony export */ });\n// 두 참가자가 이전에 만났는지 확인\nfunction haveMet(p1, p2) {\n    var _p1_metPeople;\n    return ((_p1_metPeople = p1.metPeople) === null || _p1_metPeople === void 0 ? void 0 : _p1_metPeople.includes(p2.id)) || false;\n}\n// 그룹의 균형 점수 계산 (높을수록 좋음)\nfunction calculateGroupBalance(group) {\n    const maleCount = group.filter((p)=>p.gender === 'male').length;\n    const femaleCount = group.filter((p)=>p.gender === 'female').length;\n    const extrovertCount = group.filter((p)=>p.mbti === 'extrovert').length;\n    const introvertCount = group.filter((p)=>p.mbti === 'introvert').length;\n    // 성별 균형 점수 (우선순위 높음)\n    const genderBalance = 1 - Math.abs(maleCount - femaleCount) / group.length;\n    // MBTI 균형 점수 (우선순위 낮음)\n    const mbtiBalance = 1 - Math.abs(extrovertCount - introvertCount) / group.length;\n    // 새로운 만남 점수\n    let newMeetings = 0;\n    let totalPairs = 0;\n    for(let i = 0; i < group.length; i++){\n        for(let j = i + 1; j < group.length; j++){\n            totalPairs++;\n            if (!haveMet(group[i], group[j])) {\n                newMeetings++;\n            }\n        }\n    }\n    const newMeetingScore = totalPairs > 0 ? newMeetings / totalPairs : 1;\n    // 가중 평균 (성별 균형 70%, 새로운 만남 25%, MBTI 균형 5%)\n    return genderBalance * 0.7 + newMeetingScore * 0.25 + mbtiBalance * 0.05;\n}\n// 참가자가 이전 라운드와 다른 그룹 번호를 가져야 하는지 확인\nfunction shouldAvoidGroupNumber(participant, groupNumber) {\n    const history = participant.groupHistory || [];\n    return history.length > 0 && history[history.length - 1] === groupNumber;\n}\n// 유전 알고리즘을 사용한 그룹 배치\nfunction createOptimalGroups(participants) {\n    let groupSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, currentRound = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    if (participants.length < 2) {\n        throw new Error('최소 2명 이상의 참가자가 필요합니다.');\n    }\n    const numGroups = Math.ceil(participants.length / groupSize);\n    const populationSize = 100;\n    const generations = 200;\n    const mutationRate = 0.1;\n    // 개체 생성 (그룹 배치 방식)\n    function createIndividual() {\n        const individual = new Array(participants.length);\n        const groupSizes = new Array(numGroups).fill(0);\n        // 먼저 모든 참가자를 순차적으로 배치\n        for(let i = 0; i < participants.length; i++){\n            let groupIndex = i % numGroups // 순차 배치로 시작\n            ;\n            let attempts = 0;\n            // 그룹 크기 제한과 그룹 번호 회피를 고려한 재배치\n            while(attempts < 20){\n                if (groupSizes[groupIndex] < groupSize && !shouldAvoidGroupNumber(participants[i], groupIndex + 1)) {\n                    break;\n                }\n                groupIndex = Math.floor(Math.random() * numGroups);\n                attempts++;\n            }\n            // 최종적으로 조건을 만족하지 못하면 가장 적은 그룹에 배치\n            if (attempts >= 20) {\n                groupIndex = groupSizes.indexOf(Math.min(...groupSizes));\n            }\n            individual[i] = groupIndex;\n            groupSizes[groupIndex]++;\n        }\n        return individual;\n    }\n    // 적합도 계산\n    function calculateFitness(individual) {\n        const groups = Array.from({\n            length: numGroups\n        }, ()=>[]);\n        individual.forEach((groupIndex, participantIndex)=>{\n            groups[groupIndex].push(participants[participantIndex]);\n        });\n        let totalScore = 0;\n        let validGroups = 0;\n        for (const group of groups){\n            if (group.length > 0) {\n                totalScore += calculateGroupBalance(group);\n                validGroups++;\n                // 그룹 번호 회피 보너스\n                for (const participant of group){\n                    const groupNumber = groups.indexOf(group) + 1;\n                    if (!shouldAvoidGroupNumber(participant, groupNumber)) {\n                        totalScore += 0.1;\n                    }\n                }\n            }\n        }\n        return validGroups > 0 ? totalScore / validGroups : 0;\n    }\n    // 교차\n    function crossover(parent1, parent2) {\n        const child = new Array(participants.length);\n        const crossoverPoint = Math.floor(Math.random() * participants.length);\n        for(let i = 0; i < participants.length; i++){\n            child[i] = i < crossoverPoint ? parent1[i] : parent2[i];\n        }\n        return child;\n    }\n    // 돌연변이\n    function mutate(individual) {\n        const mutated = [\n            ...individual\n        ];\n        for(let i = 0; i < mutated.length; i++){\n            if (Math.random() < mutationRate) {\n                let newGroup;\n                let attempts = 0;\n                do {\n                    newGroup = Math.floor(Math.random() * numGroups);\n                    attempts++;\n                }while (attempts < 5 && shouldAvoidGroupNumber(participants[i], newGroup + 1));\n                mutated[i] = newGroup;\n            }\n        }\n        return mutated;\n    }\n    // 유전 알고리즘 실행\n    let population = Array.from({\n        length: populationSize\n    }, ()=>createIndividual());\n    for(let generation = 0; generation < generations; generation++){\n        // 적합도 계산 및 정렬\n        const fitnessScores = population.map(calculateFitness);\n        const sortedIndices = fitnessScores.map((fitness, index)=>({\n                fitness,\n                index\n            })).sort((a, b)=>b.fitness - a.fitness);\n        // 엘리트 선택 (상위 20%)\n        const eliteSize = Math.floor(populationSize * 0.2);\n        const newPopulation = sortedIndices.slice(0, eliteSize).map((item)=>population[item.index]);\n        // 나머지는 교차와 돌연변이로 생성\n        while(newPopulation.length < populationSize){\n            const parent1Index = Math.floor(Math.random() * eliteSize);\n            const parent2Index = Math.floor(Math.random() * eliteSize);\n            const parent1 = newPopulation[parent1Index];\n            const parent2 = newPopulation[parent2Index];\n            let child = crossover(parent1, parent2);\n            child = mutate(child);\n            newPopulation.push(child);\n        }\n        population = newPopulation;\n    }\n    // 최적 해 선택\n    const fitnessScores = population.map(calculateFitness);\n    const bestIndex = fitnessScores.indexOf(Math.max(...fitnessScores));\n    const bestSolution = population[bestIndex];\n    // 결과 구성\n    const finalGroups = [];\n    const groupArrays = Array.from({\n        length: numGroups\n    }, ()=>[]);\n    bestSolution.forEach((groupIndex, participantIndex)=>{\n        groupArrays[groupIndex].push(participants[participantIndex]);\n    });\n    let newMeetingsTotal = 0;\n    let totalGenderBalance = 0;\n    let totalMbtiBalance = 0;\n    groupArrays.forEach((groupMembers, index)=>{\n        const maleCount = groupMembers.filter((p)=>p.gender === 'male').length;\n        const femaleCount = groupMembers.filter((p)=>p.gender === 'female').length;\n        const extrovertCount = groupMembers.filter((p)=>p.mbti === 'extrovert').length;\n        const introvertCount = groupMembers.filter((p)=>p.mbti === 'introvert').length;\n        // 새로운 만남 계산 (빈 그룹이 아닐 때만)\n        if (groupMembers.length > 0) {\n            for(let i = 0; i < groupMembers.length; i++){\n                for(let j = i + 1; j < groupMembers.length; j++){\n                    if (!haveMet(groupMembers[i], groupMembers[j])) {\n                        newMeetingsTotal++;\n                    }\n                }\n            }\n            totalGenderBalance += 1 - Math.abs(maleCount - femaleCount) / groupMembers.length;\n            totalMbtiBalance += 1 - Math.abs(extrovertCount - introvertCount) / groupMembers.length;\n        }\n        // 모든 그룹을 포함 (빈 그룹도 포함)\n        finalGroups.push({\n            id: index + 1,\n            members: groupMembers,\n            maleCount,\n            femaleCount,\n            extrovertCount,\n            introvertCount\n        });\n    });\n    return {\n        groups: finalGroups,\n        round: currentRound,\n        summary: {\n            totalGroups: finalGroups.length,\n            avgGroupSize: participants.length / finalGroups.length,\n            genderBalanceScore: Math.round(totalGenderBalance / finalGroups.length * 100),\n            mbtiBalanceScore: Math.round(totalMbtiBalance / finalGroups.length * 100),\n            newMeetingsCount: newMeetingsTotal\n        }\n    };\n}\n// 만남 히스토리 업데이트\nfunction updateMeetingHistory(participants, groups, round) {\n    const updatedParticipants = participants.map((p)=>({\n            ...p,\n            metPeople: [\n                ...p.metPeople || []\n            ],\n            groupHistory: [\n                ...p.groupHistory || []\n            ]\n        }));\n    // 각 그룹 내 참가자들의 만남 기록 업데이트\n    groups.forEach((group)=>{\n        // 그룹 번호 히스토리 업데이트\n        group.members.forEach((member)=>{\n            const participant = updatedParticipants.find((p)=>p.id === member.id);\n            if (participant) {\n                participant.groupHistory.push(group.id);\n            }\n        });\n        // 서로 만난 기록 업데이트\n        for(let i = 0; i < group.members.length; i++){\n            for(let j = i + 1; j < group.members.length; j++){\n                const p1 = updatedParticipants.find((p)=>p.id === group.members[i].id);\n                const p2 = updatedParticipants.find((p)=>p.id === group.members[j].id);\n                if (p1 && p2) {\n                    if (!p1.metPeople.includes(p2.id)) {\n                        p1.metPeople.push(p2.id);\n                    }\n                    if (!p2.metPeople.includes(p1.id)) {\n                        p2.metPeople.push(p1.id);\n                    }\n                }\n            }\n        }\n    });\n    return updatedParticipants;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ncm91cGluZy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQThCQSxxQkFBcUI7QUFDckIsU0FBU0EsUUFBUUMsRUFBZSxFQUFFQyxFQUFlO1FBQ3hDRDtJQUFQLE9BQU9BLEVBQUFBLGdCQUFBQSxHQUFHRSxTQUFTLGNBQVpGLG9DQUFBQSxjQUFjRyxRQUFRLENBQUNGLEdBQUdHLEVBQUUsTUFBSztBQUMxQztBQUVBLHlCQUF5QjtBQUN6QixTQUFTQyxzQkFBc0JDLEtBQW9CO0lBQ2pELE1BQU1DLFlBQVlELE1BQU1FLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTSxLQUFLLFFBQVFDLE1BQU07SUFDL0QsTUFBTUMsY0FBY04sTUFBTUUsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssVUFBVUMsTUFBTTtJQUNuRSxNQUFNRSxpQkFBaUJQLE1BQU1FLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUssSUFBSSxLQUFLLGFBQWFILE1BQU07SUFDdkUsTUFBTUksaUJBQWlCVCxNQUFNRSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVLLElBQUksS0FBSyxhQUFhSCxNQUFNO0lBRXZFLHFCQUFxQjtJQUNyQixNQUFNSyxnQkFBZ0IsSUFBSUMsS0FBS0MsR0FBRyxDQUFDWCxZQUFZSyxlQUFlTixNQUFNSyxNQUFNO0lBRTFFLHVCQUF1QjtJQUN2QixNQUFNUSxjQUFjLElBQUlGLEtBQUtDLEdBQUcsQ0FBQ0wsaUJBQWlCRSxrQkFBa0JULE1BQU1LLE1BQU07SUFFaEYsWUFBWTtJQUNaLElBQUlTLGNBQWM7SUFDbEIsSUFBSUMsYUFBYTtJQUNqQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWhCLE1BQU1LLE1BQU0sRUFBRVcsSUFBSztRQUNyQyxJQUFLLElBQUlDLElBQUlELElBQUksR0FBR0MsSUFBSWpCLE1BQU1LLE1BQU0sRUFBRVksSUFBSztZQUN6Q0Y7WUFDQSxJQUFJ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Q2pGLE1BQU0sRUFBRVksSUFBSztnQkFDakQsTUFBTXZCLEtBQUtxRyxvQkFBb0JFLElBQUksQ0FBQzlGLENBQUFBLElBQUtBLEVBQUVMLEVBQUUsS0FBS0UsTUFBTXNGLE9BQU8sQ0FBQ3RFLEVBQUUsQ0FBQ2xCLEVBQUU7Z0JBQ3JFLE1BQU1ILEtBQUtvRyxvQkFBb0JFLElBQUksQ0FBQzlGLENBQUFBLElBQUtBLEVBQUVMLEVBQUUsS0FBS0UsTUFBTXNGLE9BQU8sQ0FBQ3JFLEVBQUUsQ0FBQ25CLEVBQUU7Z0JBRXJFLElBQUlKLE1BQU1DLElBQUk7b0JBQ1osSUFBSSxDQUFDRCxHQUFHRSxTQUFTLENBQUVDLFFBQVEsQ0FBQ0YsR0FBR0csRUFBRSxHQUFHO3dCQUNsQ0osR0FBR0UsU0FBUyxDQUFFc0QsSUFBSSxDQUFDdkQsR0FBR0csRUFBRTtvQkFDMUI7b0JBQ0EsSUFBSSxDQUFDSCxHQUFHQyxTQUFTLENBQUVDLFFBQVEsQ0FBQ0gsR0FBR0ksRUFBRSxHQUFHO3dCQUNsQ0gsR0FBR0MsU0FBUyxDQUFFc0QsSUFBSSxDQUFDeEQsR0FBR0ksRUFBRTtvQkFDMUI7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPaUc7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2RvaHllb25hbi9zaWRlUHJvamVjdHMvc29jaWFsaW5nU2VhdEFzc2lnbmVyL3NyYy91dGlscy9ncm91cGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFBhcnRpY2lwYW50IHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgZ2VuZGVyOiAnbWFsZScgfCAnZmVtYWxlJ1xuICBtYnRpOiAnZXh0cm92ZXJ0JyB8ICdpbnRyb3ZlcnQnXG4gIG1ldFBlb3BsZT86IHN0cmluZ1tdXG4gIGdyb3VwSGlzdG9yeT86IG51bWJlcltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXAge1xuICBpZDogbnVtYmVyXG4gIG1lbWJlcnM6IFBhcnRpY2lwYW50W11cbiAgbWFsZUNvdW50OiBudW1iZXJcbiAgZmVtYWxlQ291bnQ6IG51bWJlclxuICBleHRyb3ZlcnRDb3VudDogbnVtYmVyXG4gIGludHJvdmVydENvdW50OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91cGluZ1Jlc3VsdCB7XG4gIGdyb3VwczogR3JvdXBbXVxuICByb3VuZDogbnVtYmVyXG4gIHN1bW1hcnk6IHtcbiAgICB0b3RhbEdyb3VwczogbnVtYmVyXG4gICAgYXZnR3JvdXBTaXplOiBudW1iZXJcbiAgICBnZW5kZXJCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG1idGlCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG5ld01lZXRpbmdzQ291bnQ6IG51bWJlclxuICB9XG59XG5cbi8vIOuRkCDssLjqsIDsnpDqsIAg7J207KCE7JeQIOunjOuCrOuKlOyngCDtmZXsnbhcbmZ1bmN0aW9uIGhhdmVNZXQocDE6IFBhcnRpY2lwYW50LCBwMjogUGFydGljaXBhbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIHAxLm1ldFBlb3BsZT8uaW5jbHVkZXMocDIuaWQpIHx8IGZhbHNlXG59XG5cbi8vIOq3uOujueydmCDqt6DtmJUg7KCQ7IiYIOqzhOyCsCAo64aS7J2E7IiY66GdIOyii+ydjClcbmZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VwQmFsYW5jZShncm91cDogUGFydGljaXBhbnRbXSk6IG51bWJlciB7XG4gIGNvbnN0IG1hbGVDb3VudCA9IGdyb3VwLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnbWFsZScpLmxlbmd0aFxuICBjb25zdCBmZW1hbGVDb3VudCA9IGdyb3VwLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gIGNvbnN0IGV4dHJvdmVydENvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5tYnRpID09PSAnZXh0cm92ZXJ0JykubGVuZ3RoXG4gIGNvbnN0IGludHJvdmVydENvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5tYnRpID09PSAnaW50cm92ZXJ0JykubGVuZ3RoXG4gIFxuICAvLyDshLHrs4Qg6reg7ZiVIOygkOyImCAo7Jqw7ISg7Iic7JyEIOuGkuydjClcbiAgY29uc3QgZ2VuZGVyQmFsYW5jZSA9IDEgLSBNYXRoLmFicyhtYWxlQ291bnQgLSBmZW1hbGVDb3VudCkgLyBncm91cC5sZW5ndGhcbiAgXG4gIC8vIE1CVEkg6reg7ZiVIOygkOyImCAo7Jqw7ISg7Iic7JyEIOuCruydjClcbiAgY29uc3QgbWJ0aUJhbGFuY2UgPSAxIC0gTWF0aC5hYnMoZXh0cm92ZXJ0Q291bnQgLSBpbnRyb3ZlcnRDb3VudCkgLyBncm91cC5sZW5ndGhcbiAgXG4gIC8vIOyDiOuhnOyatCDrp4zrgqgg7KCQ7IiYXG4gIGxldCBuZXdNZWV0aW5ncyA9IDBcbiAgbGV0IHRvdGFsUGFpcnMgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBncm91cC5sZW5ndGg7IGorKykge1xuICAgICAgdG90YWxQYWlycysrXG4gICAgICBpZiAoIWhhdmVNZXQoZ3JvdXBbaV0sIGdyb3VwW2pdKSkge1xuICAgICAgICBuZXdNZWV0aW5ncysrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld01lZXRpbmdTY29yZSA9IHRvdGFsUGFpcnMgPiAwID8gbmV3TWVldGluZ3MgLyB0b3RhbFBhaXJzIDogMVxuICBcbiAgLy8g6rCA7KSRIO2Pieq3oCAo7ISx67OEIOq3oO2YlSA3MCUsIOyDiOuhnOyatCDrp4zrgqggMjUlLCBNQlRJIOq3oO2YlSA1JSlcbiAgcmV0dXJuIGdlbmRlckJhbGFuY2UgKiAwLjcgKyBuZXdNZWV0aW5nU2NvcmUgKiAwLjI1ICsgbWJ0aUJhbGFuY2UgKiAwLjA1XG59XG5cbi8vIOywuOqwgOyekOqwgCDsnbTsoIQg65287Jq065Oc7JmAIOuLpOuluCDqt7jro7kg67KI7Zi466W8IOqwgOyguOyVvCDtlZjripTsp4Ag7ZmV7J24XG5mdW5jdGlvbiBzaG91bGRBdm9pZEdyb3VwTnVtYmVyKHBhcnRpY2lwYW50OiBQYXJ0aWNpcGFudCwgZ3JvdXBOdW1iZXI6IG51bWJlcik6IGJvb2xlYW4ge1xuICBjb25zdCBoaXN0b3J5ID0gcGFydGljaXBhbnQuZ3JvdXBIaXN0b3J5IHx8IFtdXG4gIHJldHVybiBoaXN0b3J5Lmxlbmd0aCA+IDAgJiYgaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdID09PSBncm91cE51bWJlclxufVxuXG4vLyDsnKDsoIQg7JWM6rOg66as7KaY7J2EIOyCrOyaqe2VnCDqt7jro7kg67Cw7LmYXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3B0aW1hbEdyb3VwcyhcbiAgcGFydGljaXBhbnRzOiBQYXJ0aWNpcGFudFtdLCBcbiAgZ3JvdXBTaXplOiBudW1iZXIgPSA0LFxuICBjdXJyZW50Um91bmQ6IG51bWJlciA9IDFcbik6IEdyb3VwaW5nUmVzdWx0IHtcbiAgaWYgKHBhcnRpY2lwYW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCfstZzshowgMuuqhSDsnbTsg4HsnZgg7LC46rCA7J6Q6rCAIO2VhOyalO2VqeuLiOuLpC4nKVxuICB9XG5cbiAgY29uc3QgbnVtR3JvdXBzID0gTWF0aC5jZWlsKHBhcnRpY2lwYW50cy5sZW5ndGggLyBncm91cFNpemUpXG4gIGNvbnN0IHBvcHVsYXRpb25TaXplID0gMTAwXG4gIGNvbnN0IGdlbmVyYXRpb25zID0gMjAwXG4gIGNvbnN0IG11dGF0aW9uUmF0ZSA9IDAuMVxuXG4gIC8vIOqwnOyytCDsg53shLEgKOq3uOujuSDrsLDsuZgg67Cp7IudKVxuICBmdW5jdGlvbiBjcmVhdGVJbmRpdmlkdWFsKCk6IG51bWJlcltdIHtcbiAgICBjb25zdCBpbmRpdmlkdWFsID0gbmV3IEFycmF5KHBhcnRpY2lwYW50cy5sZW5ndGgpXG4gICAgY29uc3QgZ3JvdXBTaXplcyA9IG5ldyBBcnJheShudW1Hcm91cHMpLmZpbGwoMClcbiAgICBcbiAgICAvLyDrqLzsoIAg66qo65OgIOywuOqwgOyekOulvCDsiJzssKjsoIHsnLzroZwg67Cw7LmYXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNpcGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBncm91cEluZGV4ID0gaSAlIG51bUdyb3VwcyAvLyDsiJzssKgg67Cw7LmY66GcIOyLnOyekVxuICAgICAgbGV0IGF0dGVtcHRzID0gMFxuICAgICAgXG4gICAgICAvLyDqt7jro7kg7YGs6riwIOygnO2VnOqzvCDqt7jro7kg67KI7Zi4IO2ajO2UvOulvCDqs6DroKTtlZwg7J6s67Cw7LmYXG4gICAgICB3aGlsZSAoYXR0ZW1wdHMgPCAyMCkge1xuICAgICAgICBpZiAoZ3JvdXBTaXplc1tncm91cEluZGV4XSA8IGdyb3VwU2l6ZSAmJiBcbiAgICAgICAgICAgICFzaG91bGRBdm9pZEdyb3VwTnVtYmVyKHBhcnRpY2lwYW50c1tpXSwgZ3JvdXBJbmRleCArIDEpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBncm91cEluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbnVtR3JvdXBzKVxuICAgICAgICBhdHRlbXB0cysrXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIOy1nOyiheyggeycvOuhnCDsobDqsbTsnYQg66eM7KGx7ZWY7KeAIOuqu+2VmOuptCDqsIDsnqUg7KCB7J2AIOq3uOujueyXkCDrsLDsuZhcbiAgICAgIGlmIChhdHRlbXB0cyA+PSAyMCkge1xuICAgICAgICBncm91cEluZGV4ID0gZ3JvdXBTaXplcy5pbmRleE9mKE1hdGgubWluKC4uLmdyb3VwU2l6ZXMpKVxuICAgICAgfVxuICAgICAgXG4gICAgICBpbmRpdmlkdWFsW2ldID0gZ3JvdXBJbmRleFxuICAgICAgZ3JvdXBTaXplc1tncm91cEluZGV4XSsrXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpbmRpdmlkdWFsXG4gIH1cblxuICAvLyDsoIHtlanrj4Qg6rOE7IKwXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUZpdG5lc3MoaW5kaXZpZHVhbDogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGNvbnN0IGdyb3VwczogUGFydGljaXBhbnRbXVtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtR3JvdXBzIH0sICgpID0+IFtdKVxuICAgIFxuICAgIGluZGl2aWR1YWwuZm9yRWFjaCgoZ3JvdXBJbmRleCwgcGFydGljaXBhbnRJbmRleCkgPT4ge1xuICAgICAgZ3JvdXBzW2dyb3VwSW5kZXhdLnB1c2gocGFydGljaXBhbnRzW3BhcnRpY2lwYW50SW5kZXhdKVxuICAgIH0pXG4gICAgXG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwXG4gICAgbGV0IHZhbGlkR3JvdXBzID0gMFxuICAgIFxuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZ3JvdXBzKSB7XG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgICB0b3RhbFNjb3JlICs9IGNhbGN1bGF0ZUdyb3VwQmFsYW5jZShncm91cClcbiAgICAgICAgdmFsaWRHcm91cHMrK1xuICAgICAgICBcbiAgICAgICAgLy8g6re466O5IOuyiO2YuCDtmoztlLwg67O064SI7IqkXG4gICAgICAgIGZvciAoY29uc3QgcGFydGljaXBhbnQgb2YgZ3JvdXApIHtcbiAgICAgICAgICBjb25zdCBncm91cE51bWJlciA9IGdyb3Vwcy5pbmRleE9mKGdyb3VwKSArIDFcbiAgICAgICAgICBpZiAoIXNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQsIGdyb3VwTnVtYmVyKSkge1xuICAgICAgICAgICAgdG90YWxTY29yZSArPSAwLjFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHZhbGlkR3JvdXBzID4gMCA/IHRvdGFsU2NvcmUgLyB2YWxpZEdyb3VwcyA6IDBcbiAgfVxuXG4gIC8vIOq1kOywqFxuICBmdW5jdGlvbiBjcm9zc292ZXIocGFyZW50MTogbnVtYmVyW10sIHBhcmVudDI6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGNoaWxkID0gbmV3IEFycmF5KHBhcnRpY2lwYW50cy5sZW5ndGgpXG4gICAgY29uc3QgY3Jvc3NvdmVyUG9pbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYXJ0aWNpcGFudHMubGVuZ3RoKVxuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljaXBhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZFtpXSA9IGkgPCBjcm9zc292ZXJQb2ludCA/IHBhcmVudDFbaV0gOiBwYXJlbnQyW2ldXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjaGlsZFxuICB9XG5cbiAgLy8g64+M7Jew67OA7J20XG4gIGZ1bmN0aW9uIG11dGF0ZShpbmRpdmlkdWFsOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICBjb25zdCBtdXRhdGVkID0gWy4uLmluZGl2aWR1YWxdXG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IG11dGF0aW9uUmF0ZSkge1xuICAgICAgICBsZXQgbmV3R3JvdXBcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMFxuICAgICAgICBcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5ld0dyb3VwID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbnVtR3JvdXBzKVxuICAgICAgICAgIGF0dGVtcHRzKytcbiAgICAgICAgfSB3aGlsZSAoXG4gICAgICAgICAgYXR0ZW1wdHMgPCA1ICYmXG4gICAgICAgICAgc2hvdWxkQXZvaWRHcm91cE51bWJlcihwYXJ0aWNpcGFudHNbaV0sIG5ld0dyb3VwICsgMSlcbiAgICAgICAgKVxuICAgICAgICBcbiAgICAgICAgbXV0YXRlZFtpXSA9IG5ld0dyb3VwXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBtdXRhdGVkXG4gIH1cblxuICAvLyDsnKDsoIQg7JWM6rOg66as7KaYIOyLpO2WiVxuICBsZXQgcG9wdWxhdGlvbiA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHBvcHVsYXRpb25TaXplIH0sICgpID0+IGNyZWF0ZUluZGl2aWR1YWwoKSlcbiAgXG4gIGZvciAobGV0IGdlbmVyYXRpb24gPSAwOyBnZW5lcmF0aW9uIDwgZ2VuZXJhdGlvbnM7IGdlbmVyYXRpb24rKykge1xuICAgIC8vIOygge2VqeuPhCDqs4TsgrAg67CPIOygleugrFxuICAgIGNvbnN0IGZpdG5lc3NTY29yZXMgPSBwb3B1bGF0aW9uLm1hcChjYWxjdWxhdGVGaXRuZXNzKVxuICAgIGNvbnN0IHNvcnRlZEluZGljZXMgPSBmaXRuZXNzU2NvcmVzXG4gICAgICAubWFwKChmaXRuZXNzLCBpbmRleCkgPT4gKHsgZml0bmVzcywgaW5kZXggfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5maXRuZXNzIC0gYS5maXRuZXNzKVxuICAgIFxuICAgIC8vIOyXmOumrO2KuCDshKDtg50gKOyDgeychCAyMCUpXG4gICAgY29uc3QgZWxpdGVTaXplID0gTWF0aC5mbG9vcihwb3B1bGF0aW9uU2l6ZSAqIDAuMilcbiAgICBjb25zdCBuZXdQb3B1bGF0aW9uID0gc29ydGVkSW5kaWNlc1xuICAgICAgLnNsaWNlKDAsIGVsaXRlU2l6ZSlcbiAgICAgIC5tYXAoaXRlbSA9PiBwb3B1bGF0aW9uW2l0ZW0uaW5kZXhdKVxuICAgIFxuICAgIC8vIOuCmOuouOyngOuKlCDqtZDssKjsmYAg64+M7Jew67OA7J2066GcIOyDneyEsVxuICAgIHdoaWxlIChuZXdQb3B1bGF0aW9uLmxlbmd0aCA8IHBvcHVsYXRpb25TaXplKSB7XG4gICAgICBjb25zdCBwYXJlbnQxSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBlbGl0ZVNpemUpXG4gICAgICBjb25zdCBwYXJlbnQySW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBlbGl0ZVNpemUpXG4gICAgICBcbiAgICAgIGNvbnN0IHBhcmVudDEgPSBuZXdQb3B1bGF0aW9uW3BhcmVudDFJbmRleF1cbiAgICAgIGNvbnN0IHBhcmVudDIgPSBuZXdQb3B1bGF0aW9uW3BhcmVudDJJbmRleF1cbiAgICAgIFxuICAgICAgbGV0IGNoaWxkID0gY3Jvc3NvdmVyKHBhcmVudDEsIHBhcmVudDIpXG4gICAgICBjaGlsZCA9IG11dGF0ZShjaGlsZClcbiAgICAgIFxuICAgICAgbmV3UG9wdWxhdGlvbi5wdXNoKGNoaWxkKVxuICAgIH1cbiAgICBcbiAgICBwb3B1bGF0aW9uID0gbmV3UG9wdWxhdGlvblxuICB9XG5cbiAgLy8g7LWc7KCBIO2VtCDshKDtg51cbiAgY29uc3QgZml0bmVzc1Njb3JlcyA9IHBvcHVsYXRpb24ubWFwKGNhbGN1bGF0ZUZpdG5lc3MpXG4gIGNvbnN0IGJlc3RJbmRleCA9IGZpdG5lc3NTY29yZXMuaW5kZXhPZihNYXRoLm1heCguLi5maXRuZXNzU2NvcmVzKSlcbiAgY29uc3QgYmVzdFNvbHV0aW9uID0gcG9wdWxhdGlvbltiZXN0SW5kZXhdXG5cbiAgLy8g6rKw6rO8IOq1rOyEsVxuICBjb25zdCBmaW5hbEdyb3VwczogR3JvdXBbXSA9IFtdXG4gIGNvbnN0IGdyb3VwQXJyYXlzOiBQYXJ0aWNpcGFudFtdW10gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBudW1Hcm91cHMgfSwgKCkgPT4gW10pXG4gIFxuICBiZXN0U29sdXRpb24uZm9yRWFjaCgoZ3JvdXBJbmRleCwgcGFydGljaXBhbnRJbmRleCkgPT4ge1xuICAgIGdyb3VwQXJyYXlzW2dyb3VwSW5kZXhdLnB1c2gocGFydGljaXBhbnRzW3BhcnRpY2lwYW50SW5kZXhdKVxuICB9KVxuICBcbiAgbGV0IG5ld01lZXRpbmdzVG90YWwgPSAwXG4gIGxldCB0b3RhbEdlbmRlckJhbGFuY2UgPSAwXG4gIGxldCB0b3RhbE1idGlCYWxhbmNlID0gMFxuICBcbiAgZ3JvdXBBcnJheXMuZm9yRWFjaCgoZ3JvdXBNZW1iZXJzLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICBjb25zdCBmZW1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgIGNvbnN0IGV4dHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2V4dHJvdmVydCcpLmxlbmd0aFxuICAgIGNvbnN0IGludHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICAgIFxuICAgIC8vIOyDiOuhnOyatCDrp4zrgqgg6rOE7IKwICjruYgg6re466O57J20IOyVhOuLkCDrlYzrp4wpXG4gICAgaWYgKGdyb3VwTWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwTWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBncm91cE1lbWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoIWhhdmVNZXQoZ3JvdXBNZW1iZXJzW2ldLCBncm91cE1lbWJlcnNbal0pKSB7XG4gICAgICAgICAgICBuZXdNZWV0aW5nc1RvdGFsKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdG90YWxHZW5kZXJCYWxhbmNlICs9IDEgLSBNYXRoLmFicyhtYWxlQ291bnQgLSBmZW1hbGVDb3VudCkgLyBncm91cE1lbWJlcnMubGVuZ3RoXG4gICAgICB0b3RhbE1idGlCYWxhbmNlICs9IDEgLSBNYXRoLmFicyhleHRyb3ZlcnRDb3VudCAtIGludHJvdmVydENvdW50KSAvIGdyb3VwTWVtYmVycy5sZW5ndGhcbiAgICB9XG4gICAgXG4gICAgLy8g66qo65OgIOq3uOujueydhCDtj6ztlaggKOu5iCDqt7jro7nrj4Qg7Y+s7ZWoKVxuICAgIGZpbmFsR3JvdXBzLnB1c2goe1xuICAgICAgaWQ6IGluZGV4ICsgMSxcbiAgICAgIG1lbWJlcnM6IGdyb3VwTWVtYmVycyxcbiAgICAgIG1hbGVDb3VudCxcbiAgICAgIGZlbWFsZUNvdW50LFxuICAgICAgZXh0cm92ZXJ0Q291bnQsXG4gICAgICBpbnRyb3ZlcnRDb3VudFxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBncm91cHM6IGZpbmFsR3JvdXBzLFxuICAgIHJvdW5kOiBjdXJyZW50Um91bmQsXG4gICAgc3VtbWFyeToge1xuICAgICAgdG90YWxHcm91cHM6IGZpbmFsR3JvdXBzLmxlbmd0aCxcbiAgICAgIGF2Z0dyb3VwU2l6ZTogcGFydGljaXBhbnRzLmxlbmd0aCAvIGZpbmFsR3JvdXBzLmxlbmd0aCxcbiAgICAgIGdlbmRlckJhbGFuY2VTY29yZTogTWF0aC5yb3VuZCgodG90YWxHZW5kZXJCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCksXG4gICAgICBtYnRpQmFsYW5jZVNjb3JlOiBNYXRoLnJvdW5kKCh0b3RhbE1idGlCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCksXG4gICAgICBuZXdNZWV0aW5nc0NvdW50OiBuZXdNZWV0aW5nc1RvdGFsXG4gICAgfVxuICB9XG59XG5cbi8vIOunjOuCqCDtnojsiqTthqDrpqwg7JeF642w7J207Yq4XG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWVldGluZ0hpc3RvcnkoXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRbXSwgXG4gIGdyb3VwczogR3JvdXBbXSwgXG4gIHJvdW5kOiBudW1iZXJcbik6IFBhcnRpY2lwYW50W10ge1xuICBjb25zdCB1cGRhdGVkUGFydGljaXBhbnRzID0gcGFydGljaXBhbnRzLm1hcChwID0+ICh7XG4gICAgLi4ucCxcbiAgICBtZXRQZW9wbGU6IFsuLi4ocC5tZXRQZW9wbGUgfHwgW10pXSxcbiAgICBncm91cEhpc3Rvcnk6IFsuLi4ocC5ncm91cEhpc3RvcnkgfHwgW10pXVxuICB9KSlcblxuICAvLyDqsIEg6re466O5IOuCtCDssLjqsIDsnpDrk6TsnZgg66eM64KoIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgZ3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgIC8vIOq3uOujuSDrsojtmLgg7Z6I7Iqk7Yag66asIOyXheuNsOydtO2KuFxuICAgIGdyb3VwLm1lbWJlcnMuZm9yRWFjaChtZW1iZXIgPT4ge1xuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBtZW1iZXIuaWQpXG4gICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgcGFydGljaXBhbnQuZ3JvdXBIaXN0b3J5IS5wdXNoKGdyb3VwLmlkKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyDshJzroZwg66eM64KcIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgcDEgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBncm91cC5tZW1iZXJzW2ldLmlkKVxuICAgICAgICBjb25zdCBwMiA9IHVwZGF0ZWRQYXJ0aWNpcGFudHMuZmluZChwID0+IHAuaWQgPT09IGdyb3VwLm1lbWJlcnNbal0uaWQpXG4gICAgICAgIFxuICAgICAgICBpZiAocDEgJiYgcDIpIHtcbiAgICAgICAgICBpZiAoIXAxLm1ldFBlb3BsZSEuaW5jbHVkZXMocDIuaWQpKSB7XG4gICAgICAgICAgICBwMS5tZXRQZW9wbGUhLnB1c2gocDIuaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcDIubWV0UGVvcGxlIS5pbmNsdWRlcyhwMS5pZCkpIHtcbiAgICAgICAgICAgIHAyLm1ldFBlb3BsZSEucHVzaChwMS5pZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRQYXJ0aWNpcGFudHNcbn0iXSwibmFtZXMiOlsiaGF2ZU1ldCIsInAxIiwicDIiLCJtZXRQZW9wbGUiLCJpbmNsdWRlcyIsImlkIiwiY2FsY3VsYXRlR3JvdXBCYWxhbmNlIiwiZ3JvdXAiLCJtYWxlQ291bnQiLCJmaWx0ZXIiLCJwIiwiZ2VuZGVyIiwibGVuZ3RoIiwiZmVtYWxlQ291bnQiLCJleHRyb3ZlcnRDb3VudCIsIm1idGkiLCJpbnRyb3ZlcnRDb3VudCIsImdlbmRlckJhbGFuY2UiLCJNYXRoIiwiYWJzIiwibWJ0aUJhbGFuY2UiLCJuZXdNZWV0aW5ncyIsInRvdGFsUGFpcnMiLCJpIiwiaiIsIm5ld01lZXRpbmdTY29yZSIsInNob3VsZEF2b2lkR3JvdXBOdW1iZXIiLCJwYXJ0aWNpcGFudCIsImdyb3VwTnVtYmVyIiwiaGlzdG9yeSIsImdyb3VwSGlzdG9yeSIsImNyZWF0ZU9wdGltYWxHcm91cHMiLCJwYXJ0aWNpcGFudHMiLCJncm91cFNpemUiLCJjdXJyZW50Um91bmQiLCJFcnJvciIsIm51bUdyb3VwcyIsImNlaWwiLCJwb3B1bGF0aW9uU2l6ZSIsImdlbmVyYXRpb25zIiwibXV0YXRpb25SYXRlIiwiY3JlYXRlSW5kaXZpZHVhbCIsImluZGl2aWR1YWwiLCJBcnJheSIsImdyb3VwU2l6ZXMiLCJmaWxsIiwiZ3JvdXBJbmRleCIsImF0dGVtcHRzIiwiZmxvb3IiLCJyYW5kb20iLCJpbmRleE9mIiwibWluIiwiY2FsY3VsYXRlRml0bmVzcyIsImdyb3VwcyIsImZyb20iLCJmb3JFYWNoIiwicGFydGljaXBhbnRJbmRleCIsInB1c2giLCJ0b3RhbFNjb3JlIiwidmFsaWRHcm91cHMiLCJjcm9zc292ZXIiLCJwYXJlbnQxIiwicGFyZW50MiIsImNoaWxkIiwiY3Jvc3NvdmVyUG9pbnQiLCJtdXRhdGUiLCJtdXRhdGVkIiwibmV3R3JvdXAiLCJwb3B1bGF0aW9uIiwiZ2VuZXJhdGlvbiIsImZpdG5lc3NTY29yZXMiLCJtYXAiLCJzb3J0ZWRJbmRpY2VzIiwiZml0bmVzcyIsImluZGV4Iiwic29ydCIsImEiLCJiIiwiZWxpdGVTaXplIiwibmV3UG9wdWxhdGlvbiIsInNsaWNlIiwiaXRlbSIsInBhcmVudDFJbmRleCIsInBhcmVudDJJbmRleCIsImJlc3RJbmRleCIsIm1heCIsImJlc3RTb2x1dGlvbiIsImZpbmFsR3JvdXBzIiwiZ3JvdXBBcnJheXMiLCJuZXdNZWV0aW5nc1RvdGFsIiwidG90YWxHZW5kZXJCYWxhbmNlIiwidG90YWxNYnRpQmFsYW5jZSIsImdyb3VwTWVtYmVycyIsIm1lbWJlcnMiLCJyb3VuZCIsInN1bW1hcnkiLCJ0b3RhbEdyb3VwcyIsImF2Z0dyb3VwU2l6ZSIsImdlbmRlckJhbGFuY2VTY29yZSIsIm1idGlCYWxhbmNlU2NvcmUiLCJuZXdNZWV0aW5nc0NvdW50IiwidXBkYXRlTWVldGluZ0hpc3RvcnkiLCJ1cGRhdGVkUGFydGljaXBhbnRzIiwibWVtYmVyIiwiZmluZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/grouping.ts\n"));

/***/ })

});