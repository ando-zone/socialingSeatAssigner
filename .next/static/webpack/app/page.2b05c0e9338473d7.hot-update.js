"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/grouping.ts":
/*!*******************************!*\
  !*** ./src/utils/grouping.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOptimalGroups: () => (/* binding */ createOptimalGroups),\n/* harmony export */   updateMeetingHistory: () => (/* binding */ updateMeetingHistory)\n/* harmony export */ });\n// 두 참가자가 이전에 만났는지 확인\nfunction haveMet(p1, p2) {\n    var _p1_metPeople;\n    return ((_p1_metPeople = p1.metPeople) === null || _p1_metPeople === void 0 ? void 0 : _p1_metPeople.includes(p2.id)) || false;\n}\n// 그룹의 균형 점수 계산 (높을수록 좋음)\nfunction calculateGroupBalance(group) {\n    if (group.length === 0) return 0;\n    const maleCount = group.filter((p)=>p.gender === 'male').length;\n    const femaleCount = group.filter((p)=>p.gender === 'female').length;\n    const extrovertCount = group.filter((p)=>p.mbti === 'extrovert').length;\n    const introvertCount = group.filter((p)=>p.mbti === 'introvert').length;\n    // 성별 균형 점수 (0-1)\n    const genderBalance = 1 - Math.abs(maleCount - femaleCount) / group.length;\n    // MBTI 균형 점수 (0-1)\n    const mbtiBalance = 1 - Math.abs(extrovertCount - introvertCount) / group.length;\n    // 새로운 만남 점수\n    let newMeetings = 0;\n    let totalPairs = 0;\n    for(let i = 0; i < group.length; i++){\n        for(let j = i + 1; j < group.length; j++){\n            totalPairs++;\n            if (!haveMet(group[i], group[j])) {\n                newMeetings++;\n            }\n        }\n    }\n    const newMeetingScore = totalPairs > 0 ? newMeetings / totalPairs : 1;\n    // 가중 평균 (성별 균형 70%, 새로운 만남 25%, MBTI 균형 5%)\n    return genderBalance * 0.7 + newMeetingScore * 0.25 + mbtiBalance * 0.05;\n}\n// 참가자가 이전 라운드와 다른 그룹 번호를 가져야 하는지 확인\nfunction shouldAvoidGroupNumber(participant, groupNumber) {\n    const history = participant.groupHistory || [];\n    return history.length > 0 && history[history.length - 1] === groupNumber;\n}\n// 최적화된 그룹 배치 알고리즘\nfunction createOptimalGroups(participants) {\n    let groupSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, currentRound = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    if (participants.length < 2) {\n        throw new Error('최소 2명 이상의 참가자가 필요합니다.');\n    }\n    console.log(\"그룹 배치 시작: 참가자 \".concat(participants.length, \"명, 그룹 크기 \").concat(groupSize));\n    // 필요한 그룹 수 계산\n    const numGroups = Math.ceil(participants.length / groupSize);\n    console.log(\"필요한 그룹 수: \".concat(numGroups));\n    // 그룹 배열 초기화\n    const groups = Array.from({\n        length: numGroups\n    }, ()=>[]);\n    // 참가자를 그룹에 배치 (이전 라운드 그룹 번호 회피 고려)\n    const shuffledParticipants = [\n        ...participants\n    ].sort(()=>Math.random() - 0.5);\n    // 각 참가자를 적절한 그룹에 배치\n    shuffledParticipants.forEach((participant)=>{\n        let bestGroupIndex = 0;\n        let minGroupSize = groups[0].length;\n        let foundAvoidableGroup = false;\n        // 이전 라운드 그룹 번호를 회피할 수 있는 그룹 찾기\n        for(let i = 0; i < numGroups; i++){\n            const canAvoidPreviousGroup = !shouldAvoidGroupNumber(participant, i + 1);\n            if (canAvoidPreviousGroup && !foundAvoidableGroup) {\n                // 이전 그룹을 회피할 수 있는 첫 번째 그룹\n                bestGroupIndex = i;\n                minGroupSize = groups[i].length;\n                foundAvoidableGroup = true;\n            } else if (canAvoidPreviousGroup && foundAvoidableGroup) {\n                // 이전 그룹을 회피할 수 있는 그룹 중 크기가 더 작은 그룹\n                if (groups[i].length < minGroupSize) {\n                    bestGroupIndex = i;\n                    minGroupSize = groups[i].length;\n                }\n            } else if (!foundAvoidableGroup) {\n                // 이전 그룹을 회피할 수 없다면 가장 작은 그룹\n                if (groups[i].length < minGroupSize) {\n                    bestGroupIndex = i;\n                    minGroupSize = groups[i].length;\n                }\n            }\n        }\n        groups[bestGroupIndex].push(participant);\n    });\n    console.log('초기 배치 완료:', groups.map((g)=>g.length));\n    // 그룹 균형 최적화\n    optimizeGroupBalance(groups, groupSize);\n    console.log('최적화 완료:', groups.map((g)=>g.length));\n    // 결과 구성\n    const finalGroups = groups.map((groupMembers, index)=>{\n        const maleCount = groupMembers.filter((p)=>p.gender === 'male').length;\n        const femaleCount = groupMembers.filter((p)=>p.gender === 'female').length;\n        const extrovertCount = groupMembers.filter((p)=>p.mbti === 'extrovert').length;\n        const introvertCount = groupMembers.filter((p)=>p.mbti === 'introvert').length;\n        return {\n            id: index + 1,\n            members: groupMembers,\n            maleCount,\n            femaleCount,\n            extrovertCount,\n            introvertCount\n        };\n    }).filter((group)=>group.members.length > 0) // 빈 그룹 제거\n    ;\n    // 통계 계산\n    let newMeetingsTotal = 0;\n    let totalGenderBalance = 0;\n    let totalMbtiBalance = 0;\n    finalGroups.forEach((group)=>{\n        const groupMembers = group.members;\n        // 새로운 만남 계산\n        for(let i = 0; i < groupMembers.length; i++){\n            for(let j = i + 1; j < groupMembers.length; j++){\n                if (!haveMet(groupMembers[i], groupMembers[j])) {\n                    newMeetingsTotal++;\n                }\n            }\n        }\n        if (groupMembers.length > 0) {\n            totalGenderBalance += 1 - Math.abs(group.maleCount - group.femaleCount) / groupMembers.length;\n            totalMbtiBalance += 1 - Math.abs(group.extrovertCount - group.introvertCount) / groupMembers.length;\n        }\n    });\n    console.log(\"최종 그룹 수: \".concat(finalGroups.length));\n    console.log('각 그룹 크기:', finalGroups.map((g)=>g.members.length));\n    return {\n        groups: finalGroups,\n        round: currentRound,\n        summary: {\n            totalGroups: finalGroups.length,\n            avgGroupSize: finalGroups.length > 0 ? participants.length / finalGroups.length : 0,\n            genderBalanceScore: finalGroups.length > 0 ? Math.round(totalGenderBalance / finalGroups.length * 100) : 0,\n            mbtiBalanceScore: finalGroups.length > 0 ? Math.round(totalMbtiBalance / finalGroups.length * 100) : 0,\n            newMeetingsCount: newMeetingsTotal\n        }\n    };\n}\n// 그룹 균형 최적화 함수\nfunction optimizeGroupBalance(groups, targetGroupSize) {\n    const maxIterations = 50;\n    for(let iteration = 0; iteration < maxIterations; iteration++){\n        let improved = false;\n        // 그룹 크기 균형 맞추기\n        for(let i = 0; i < groups.length; i++){\n            for(let j = 0; j < groups.length; j++){\n                if (i === j) continue;\n                const group1 = groups[i];\n                const group2 = groups[j];\n                // 크기 차이가 2 이상인 경우 조정\n                if (group1.length - group2.length >= 2) {\n                    // group1에서 group2로 한 명 이동\n                    if (group1.length > 1) {\n                        const memberToMove = group1.pop();\n                        if (memberToMove) {\n                            group2.push(memberToMove);\n                            improved = true;\n                        }\n                    }\n                }\n            }\n        }\n        // 성별 균형 개선\n        for(let i = 0; i < groups.length; i++){\n            for(let j = i + 1; j < groups.length; j++){\n                const group1 = groups[i];\n                const group2 = groups[j];\n                if (group1.length === 0 || group2.length === 0) continue;\n                const g1Males = group1.filter((p)=>p.gender === 'male').length;\n                const g1Females = group1.filter((p)=>p.gender === 'female').length;\n                const g2Males = group2.filter((p)=>p.gender === 'male').length;\n                const g2Females = group2.filter((p)=>p.gender === 'female').length;\n                // 성별 불균형이 있는 경우 교환 시도\n                if (Math.abs(g1Males - g1Females) > 1 || Math.abs(g2Males - g2Females) > 1) {\n                    for(let p1 = 0; p1 < group1.length; p1++){\n                        for(let p2 = 0; p2 < group2.length; p2++){\n                            if (group1[p1].gender !== group2[p2].gender) {\n                                // 교환 시도\n                                const oldBalance1 = Math.abs(g1Males - g1Females);\n                                const oldBalance2 = Math.abs(g2Males - g2Females);\n                                const oldTotalBalance = oldBalance1 + oldBalance2;\n                                // 교환해보기\n                                const temp = group1[p1];\n                                group1[p1] = group2[p2];\n                                group2[p2] = temp;\n                                const newG1Males = group1.filter((p)=>p.gender === 'male').length;\n                                const newG1Females = group1.filter((p)=>p.gender === 'female').length;\n                                const newG2Males = group2.filter((p)=>p.gender === 'male').length;\n                                const newG2Females = group2.filter((p)=>p.gender === 'female').length;\n                                const newBalance1 = Math.abs(newG1Males - newG1Females);\n                                const newBalance2 = Math.abs(newG2Males - newG2Females);\n                                const newTotalBalance = newBalance1 + newBalance2;\n                                if (newTotalBalance < oldTotalBalance) {\n                                    improved = true;\n                                    break;\n                                } else {\n                                    // 되돌리기\n                                    const temp2 = group1[p1];\n                                    group1[p1] = group2[p2];\n                                    group2[p2] = temp2;\n                                }\n                            }\n                        }\n                        if (improved) break;\n                    }\n                }\n                if (improved) break;\n            }\n            if (improved) break;\n        }\n        if (!improved) break;\n    }\n}\n// 만남 히스토리 업데이트\nfunction updateMeetingHistory(participants, groups, round) {\n    const updatedParticipants = participants.map((p)=>({\n            ...p,\n            metPeople: [\n                ...p.metPeople || []\n            ],\n            groupHistory: [\n                ...p.groupHistory || []\n            ]\n        }));\n    // 각 그룹 내 참가자들의 만남 기록 업데이트\n    groups.forEach((group)=>{\n        // 그룹 번호 히스토리 업데이트\n        group.members.forEach((member)=>{\n            const participant = updatedParticipants.find((p)=>p.id === member.id);\n            if (participant) {\n                participant.groupHistory.push(group.id);\n            }\n        });\n        // 서로 만난 기록 업데이트\n        for(let i = 0; i < group.members.length; i++){\n            for(let j = i + 1; j < group.members.length; j++){\n                const p1 = updatedParticipants.find((p)=>p.id === group.members[i].id);\n                const p2 = updatedParticipants.find((p)=>p.id === group.members[j].id);\n                if (p1 && p2) {\n                    if (!p1.metPeople.includes(p2.id)) {\n                        p1.metPeople.push(p2.id);\n                    }\n                    if (!p2.metPeople.includes(p1.id)) {\n                        p2.metPeople.push(p1.id);\n                    }\n                }\n            }\n        }\n    });\n    return updatedParticipants;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ncm91cGluZy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQThCQSxxQkFBcUI7QUFDckIsU0FBU0EsUUFBUUMsRUFBZSxFQUFFQyxFQUFlO1FBQ3hDRDtJQUFQLE9BQU9BLEVBQUFBLGdCQUFBQSxHQUFHRSxTQUFTLGNBQVpGLG9DQUFBQSxjQUFjRyxRQUFRLENBQUNGLEdBQUdHLEVBQUUsTUFBSztBQUMxQztBQUVBLHlCQUF5QjtBQUN6QixTQUFTQyxzQkFBc0JDLEtBQW9CO0lBQ2pELElBQUlBLE1BQU1DLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFL0IsTUFBTUMsWUFBWUYsTUFBTUcsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssUUFBUUosTUFBTTtJQUMvRCxNQUFNSyxjQUFjTixNQUFNRyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxVQUFVSixNQUFNO0lBQ25FLE1BQU1NLGlCQUFpQlAsTUFBTUcsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFSSxJQUFJLEtBQUssYUFBYVAsTUFBTTtJQUN2RSxNQUFNUSxpQkFBaUJULE1BQU1HLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUksSUFBSSxLQUFLLGFBQWFQLE1BQU07SUFFdkUsaUJBQWlCO0lBQ2pCLE1BQU1TLGdCQUFnQixJQUFJQyxLQUFLQyxHQUFHLENBQUNWLFlBQVlJLGVBQWVOLE1BQU1DLE1BQU07SUFFMUUsbUJBQW1CO0lBQ25CLE1BQU1ZLGNBQWMsSUFBSUYsS0FBS0MsR0FBRyxDQUFDTCxpQkFBaUJFLGtCQUFrQlQsTUFBTUMsTUFBTTtJQUVoRixZQUFZO0lBQ1osSUFBSWEsY0FBYztJQUNsQixJQUFJQyxhQUFhO0lBQ2pCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJaEIsTUFBTUMsTUFBTSxFQUFFZSxJQUFLO1FBQ3JDLElBQUssSUFBSUMsSUFBSUQsSUFBSSxHQUFHQyxJQUFJakIs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Z0JBQWdCO1FBQ2hCLElBQUssSUFBSWtCLElBQUksR0FBR0EsSUFBSWhCLE1BQU1tRCxPQUFPLENBQUNsRCxNQUFNLEVBQUVlLElBQUs7WUFDN0MsSUFBSyxJQUFJQyxJQUFJRCxJQUFJLEdBQUdDLElBQUlqQixNQUFNbUQsT0FBTyxDQUFDbEQsTUFBTSxFQUFFZ0IsSUFBSztnQkFDakQsTUFBTXZCLEtBQUs2RixvQkFBb0JFLElBQUksQ0FBQ3JGLENBQUFBLElBQUtBLEVBQUVOLEVBQUUsS0FBS0UsTUFBTW1ELE9BQU8sQ0FBQ25DLEVBQUUsQ0FBQ2xCLEVBQUU7Z0JBQ3JFLE1BQU1ILEtBQUs0RixvQkFBb0JFLElBQUksQ0FBQ3JGLENBQUFBLElBQUtBLEVBQUVOLEVBQUUsS0FBS0UsTUFBTW1ELE9BQU8sQ0FBQ2xDLEVBQUUsQ0FBQ25CLEVBQUU7Z0JBRXJFLElBQUlKLE1BQU1DLElBQUk7b0JBQ1osSUFBSSxDQUFDRCxHQUFHRSxTQUFTLENBQUVDLFFBQVEsQ0FBQ0YsR0FBR0csRUFBRSxHQUFHO3dCQUNsQ0osR0FBR0UsU0FBUyxDQUFFZ0QsSUFBSSxDQUFDakQsR0FBR0csRUFBRTtvQkFDMUI7b0JBQ0EsSUFBSSxDQUFDSCxHQUFHQyxTQUFTLENBQUVDLFFBQVEsQ0FBQ0gsR0FBR0ksRUFBRSxHQUFHO3dCQUNsQ0gsR0FBR0MsU0FBUyxDQUFFZ0QsSUFBSSxDQUFDbEQsR0FBR0ksRUFBRTtvQkFDMUI7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPeUY7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2RvaHllb25hbi9zaWRlUHJvamVjdHMvc29jaWFsaW5nU2VhdEFzc2lnbmVyL3NyYy91dGlscy9ncm91cGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFBhcnRpY2lwYW50IHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgZ2VuZGVyOiAnbWFsZScgfCAnZmVtYWxlJ1xuICBtYnRpOiAnZXh0cm92ZXJ0JyB8ICdpbnRyb3ZlcnQnXG4gIG1ldFBlb3BsZT86IHN0cmluZ1tdXG4gIGdyb3VwSGlzdG9yeT86IG51bWJlcltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXAge1xuICBpZDogbnVtYmVyXG4gIG1lbWJlcnM6IFBhcnRpY2lwYW50W11cbiAgbWFsZUNvdW50OiBudW1iZXJcbiAgZmVtYWxlQ291bnQ6IG51bWJlclxuICBleHRyb3ZlcnRDb3VudDogbnVtYmVyXG4gIGludHJvdmVydENvdW50OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91cGluZ1Jlc3VsdCB7XG4gIGdyb3VwczogR3JvdXBbXVxuICByb3VuZDogbnVtYmVyXG4gIHN1bW1hcnk6IHtcbiAgICB0b3RhbEdyb3VwczogbnVtYmVyXG4gICAgYXZnR3JvdXBTaXplOiBudW1iZXJcbiAgICBnZW5kZXJCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG1idGlCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG5ld01lZXRpbmdzQ291bnQ6IG51bWJlclxuICB9XG59XG5cbi8vIOuRkCDssLjqsIDsnpDqsIAg7J207KCE7JeQIOunjOuCrOuKlOyngCDtmZXsnbhcbmZ1bmN0aW9uIGhhdmVNZXQocDE6IFBhcnRpY2lwYW50LCBwMjogUGFydGljaXBhbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIHAxLm1ldFBlb3BsZT8uaW5jbHVkZXMocDIuaWQpIHx8IGZhbHNlXG59XG5cbi8vIOq3uOujueydmCDqt6DtmJUg7KCQ7IiYIOqzhOyCsCAo64aS7J2E7IiY66GdIOyii+ydjClcbmZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VwQmFsYW5jZShncm91cDogUGFydGljaXBhbnRbXSk6IG51bWJlciB7XG4gIGlmIChncm91cC5sZW5ndGggPT09IDApIHJldHVybiAwXG4gIFxuICBjb25zdCBtYWxlQ291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgY29uc3QgZmVtYWxlQ291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICBjb25zdCBleHRyb3ZlcnRDb3VudCA9IGdyb3VwLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2V4dHJvdmVydCcpLmxlbmd0aFxuICBjb25zdCBpbnRyb3ZlcnRDb3VudCA9IGdyb3VwLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICBcbiAgLy8g7ISx67OEIOq3oO2YlSDsoJDsiJggKDAtMSlcbiAgY29uc3QgZ2VuZGVyQmFsYW5jZSA9IDEgLSBNYXRoLmFicyhtYWxlQ291bnQgLSBmZW1hbGVDb3VudCkgLyBncm91cC5sZW5ndGhcbiAgXG4gIC8vIE1CVEkg6reg7ZiVIOygkOyImCAoMC0xKVxuICBjb25zdCBtYnRpQmFsYW5jZSA9IDEgLSBNYXRoLmFicyhleHRyb3ZlcnRDb3VudCAtIGludHJvdmVydENvdW50KSAvIGdyb3VwLmxlbmd0aFxuICBcbiAgLy8g7IOI66Gc7Jq0IOunjOuCqCDsoJDsiJhcbiAgbGV0IG5ld01lZXRpbmdzID0gMFxuICBsZXQgdG90YWxQYWlycyA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwLmxlbmd0aDsgaisrKSB7XG4gICAgICB0b3RhbFBhaXJzKytcbiAgICAgIGlmICghaGF2ZU1ldChncm91cFtpXSwgZ3JvdXBbal0pKSB7XG4gICAgICAgIG5ld01lZXRpbmdzKytcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbmV3TWVldGluZ1Njb3JlID0gdG90YWxQYWlycyA+IDAgPyBuZXdNZWV0aW5ncyAvIHRvdGFsUGFpcnMgOiAxXG4gIFxuICAvLyDqsIDspJEg7Y+J6regICjshLHrs4Qg6reg7ZiVIDcwJSwg7IOI66Gc7Jq0IOunjOuCqCAyNSUsIE1CVEkg6reg7ZiVIDUlKVxuICByZXR1cm4gZ2VuZGVyQmFsYW5jZSAqIDAuNyArIG5ld01lZXRpbmdTY29yZSAqIDAuMjUgKyBtYnRpQmFsYW5jZSAqIDAuMDVcbn1cblxuLy8g7LC46rCA7J6Q6rCAIOydtOyghCDrnbzsmrTrk5zsmYAg64uk66W4IOq3uOujuSDrsojtmLjrpbwg6rCA7KC47JW8IO2VmOuKlOyngCDtmZXsnbhcbmZ1bmN0aW9uIHNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQ6IFBhcnRpY2lwYW50LCBncm91cE51bWJlcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhpc3RvcnkgPSBwYXJ0aWNpcGFudC5ncm91cEhpc3RvcnkgfHwgW11cbiAgcmV0dXJuIGhpc3RvcnkubGVuZ3RoID4gMCAmJiBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV0gPT09IGdyb3VwTnVtYmVyXG59XG5cbi8vIOy1nOygge2ZlOuQnCDqt7jro7kg67Cw7LmYIOyVjOqzoOumrOymmFxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9wdGltYWxHcm91cHMoXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRbXSwgXG4gIGdyb3VwU2l6ZTogbnVtYmVyID0gNCxcbiAgY3VycmVudFJvdW5kOiBudW1iZXIgPSAxXG4pOiBHcm91cGluZ1Jlc3VsdCB7XG4gIGlmIChwYXJ0aWNpcGFudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcign7LWc7IaMIDLrqoUg7J207IOB7J2YIOywuOqwgOyekOqwgCDtlYTsmpTtlanri4jri6QuJylcbiAgfVxuXG4gIGNvbnNvbGUubG9nKGDqt7jro7kg67Cw7LmYIOyLnOyekTog7LC46rCA7J6QICR7cGFydGljaXBhbnRzLmxlbmd0aH3rqoUsIOq3uOujuSDtgazquLAgJHtncm91cFNpemV9YClcblxuICAvLyDtlYTsmpTtlZwg6re466O5IOyImCDqs4TsgrBcbiAgY29uc3QgbnVtR3JvdXBzID0gTWF0aC5jZWlsKHBhcnRpY2lwYW50cy5sZW5ndGggLyBncm91cFNpemUpXG4gIGNvbnNvbGUubG9nKGDtlYTsmpTtlZwg6re466O5IOyImDogJHtudW1Hcm91cHN9YClcblxuICAvLyDqt7jro7kg67Cw7Je0IOy0iOq4sO2ZlFxuICBjb25zdCBncm91cHM6IFBhcnRpY2lwYW50W11bXSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG51bUdyb3VwcyB9LCAoKSA9PiBbXSlcblxuICAvLyDssLjqsIDsnpDrpbwg6re466O57JeQIOuwsOy5mCAo7J207KCEIOudvOyatOuTnCDqt7jro7kg67KI7Zi4IO2ajO2UvCDqs6DroKQpXG4gIGNvbnN0IHNodWZmbGVkUGFydGljaXBhbnRzID0gWy4uLnBhcnRpY2lwYW50c10uc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KVxuICBcbiAgLy8g6rCBIOywuOqwgOyekOulvCDsoIHsoIjtlZwg6re466O57JeQIOuwsOy5mFxuICBzaHVmZmxlZFBhcnRpY2lwYW50cy5mb3JFYWNoKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgIGxldCBiZXN0R3JvdXBJbmRleCA9IDBcbiAgICBsZXQgbWluR3JvdXBTaXplID0gZ3JvdXBzWzBdLmxlbmd0aFxuICAgIGxldCBmb3VuZEF2b2lkYWJsZUdyb3VwID0gZmFsc2VcbiAgICBcbiAgICAvLyDsnbTsoIQg65287Jq065OcIOq3uOujuSDrsojtmLjrpbwg7ZqM7ZS87ZWgIOyImCDsnojripQg6re466O5IOywvuq4sFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtR3JvdXBzOyBpKyspIHtcbiAgICAgIGNvbnN0IGNhbkF2b2lkUHJldmlvdXNHcm91cCA9ICFzaG91bGRBdm9pZEdyb3VwTnVtYmVyKHBhcnRpY2lwYW50LCBpICsgMSlcbiAgICAgIFxuICAgICAgaWYgKGNhbkF2b2lkUHJldmlvdXNHcm91cCAmJiAhZm91bmRBdm9pZGFibGVHcm91cCkge1xuICAgICAgICAvLyDsnbTsoIQg6re466O57J2EIO2ajO2UvO2VoCDsiJgg7J6I64qUIOyyqyDrsojsp7gg6re466O5XG4gICAgICAgIGJlc3RHcm91cEluZGV4ID0gaVxuICAgICAgICBtaW5Hcm91cFNpemUgPSBncm91cHNbaV0ubGVuZ3RoXG4gICAgICAgIGZvdW5kQXZvaWRhYmxlR3JvdXAgPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGNhbkF2b2lkUHJldmlvdXNHcm91cCAmJiBmb3VuZEF2b2lkYWJsZUdyb3VwKSB7XG4gICAgICAgIC8vIOydtOyghCDqt7jro7nsnYQg7ZqM7ZS87ZWgIOyImCDsnojripQg6re466O5IOykkSDtgazquLDqsIAg642UIOyekeydgCDqt7jro7lcbiAgICAgICAgaWYgKGdyb3Vwc1tpXS5sZW5ndGggPCBtaW5Hcm91cFNpemUpIHtcbiAgICAgICAgICBiZXN0R3JvdXBJbmRleCA9IGlcbiAgICAgICAgICBtaW5Hcm91cFNpemUgPSBncm91cHNbaV0ubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWZvdW5kQXZvaWRhYmxlR3JvdXApIHtcbiAgICAgICAgLy8g7J207KCEIOq3uOujueydhCDtmoztlLztlaAg7IiYIOyXhuuLpOuptCDqsIDsnqUg7J6R7J2AIOq3uOujuVxuICAgICAgICBpZiAoZ3JvdXBzW2ldLmxlbmd0aCA8IG1pbkdyb3VwU2l6ZSkge1xuICAgICAgICAgIGJlc3RHcm91cEluZGV4ID0gaVxuICAgICAgICAgIG1pbkdyb3VwU2l6ZSA9IGdyb3Vwc1tpXS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBncm91cHNbYmVzdEdyb3VwSW5kZXhdLnB1c2gocGFydGljaXBhbnQpXG4gIH0pXG5cbiAgY29uc29sZS5sb2coJ+y0iOq4sCDrsLDsuZgg7JmE66OMOicsIGdyb3Vwcy5tYXAoZyA9PiBnLmxlbmd0aCkpXG5cbiAgLy8g6re466O5IOq3oO2YlSDstZzsoIHtmZRcbiAgb3B0aW1pemVHcm91cEJhbGFuY2UoZ3JvdXBzLCBncm91cFNpemUpXG5cbiAgY29uc29sZS5sb2coJ+y1nOygge2ZlCDsmYTro4w6JywgZ3JvdXBzLm1hcChnID0+IGcubGVuZ3RoKSlcblxuICAvLyDqsrDqs7wg6rWs7ISxXG4gIGNvbnN0IGZpbmFsR3JvdXBzOiBHcm91cFtdID0gZ3JvdXBzLm1hcCgoZ3JvdXBNZW1iZXJzLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICBjb25zdCBmZW1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgIGNvbnN0IGV4dHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2V4dHJvdmVydCcpLmxlbmd0aFxuICAgIGNvbnN0IGludHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBpZDogaW5kZXggKyAxLFxuICAgICAgbWVtYmVyczogZ3JvdXBNZW1iZXJzLFxuICAgICAgbWFsZUNvdW50LFxuICAgICAgZmVtYWxlQ291bnQsXG4gICAgICBleHRyb3ZlcnRDb3VudCxcbiAgICAgIGludHJvdmVydENvdW50XG4gICAgfVxuICB9KS5maWx0ZXIoZ3JvdXAgPT4gZ3JvdXAubWVtYmVycy5sZW5ndGggPiAwKSAvLyDruYgg6re466O5IOygnOqxsFxuXG4gIC8vIO2GteqzhCDqs4TsgrBcbiAgbGV0IG5ld01lZXRpbmdzVG90YWwgPSAwXG4gIGxldCB0b3RhbEdlbmRlckJhbGFuY2UgPSAwXG4gIGxldCB0b3RhbE1idGlCYWxhbmNlID0gMFxuICBcbiAgZmluYWxHcm91cHMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgY29uc3QgZ3JvdXBNZW1iZXJzID0gZ3JvdXAubWVtYmVyc1xuICAgIFxuICAgIC8vIOyDiOuhnOyatCDrp4zrgqgg6rOE7IKwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cE1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwTWVtYmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIWhhdmVNZXQoZ3JvdXBNZW1iZXJzW2ldLCBncm91cE1lbWJlcnNbal0pKSB7XG4gICAgICAgICAgbmV3TWVldGluZ3NUb3RhbCsrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGdyb3VwTWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0b3RhbEdlbmRlckJhbGFuY2UgKz0gMSAtIE1hdGguYWJzKGdyb3VwLm1hbGVDb3VudCAtIGdyb3VwLmZlbWFsZUNvdW50KSAvIGdyb3VwTWVtYmVycy5sZW5ndGhcbiAgICAgIHRvdGFsTWJ0aUJhbGFuY2UgKz0gMSAtIE1hdGguYWJzKGdyb3VwLmV4dHJvdmVydENvdW50IC0gZ3JvdXAuaW50cm92ZXJ0Q291bnQpIC8gZ3JvdXBNZW1iZXJzLmxlbmd0aFxuICAgIH1cbiAgfSlcblxuICBjb25zb2xlLmxvZyhg7LWc7KKFIOq3uOujuSDsiJg6ICR7ZmluYWxHcm91cHMubGVuZ3RofWApXG4gIGNvbnNvbGUubG9nKCfqsIEg6re466O5IO2BrOq4sDonLCBmaW5hbEdyb3Vwcy5tYXAoZyA9PiBnLm1lbWJlcnMubGVuZ3RoKSlcblxuICByZXR1cm4ge1xuICAgIGdyb3VwczogZmluYWxHcm91cHMsXG4gICAgcm91bmQ6IGN1cnJlbnRSb3VuZCxcbiAgICBzdW1tYXJ5OiB7XG4gICAgICB0b3RhbEdyb3VwczogZmluYWxHcm91cHMubGVuZ3RoLFxuICAgICAgYXZnR3JvdXBTaXplOiBmaW5hbEdyb3Vwcy5sZW5ndGggPiAwID8gcGFydGljaXBhbnRzLmxlbmd0aCAvIGZpbmFsR3JvdXBzLmxlbmd0aCA6IDAsXG4gICAgICBnZW5kZXJCYWxhbmNlU2NvcmU6IGZpbmFsR3JvdXBzLmxlbmd0aCA+IDAgPyBNYXRoLnJvdW5kKCh0b3RhbEdlbmRlckJhbGFuY2UgLyBmaW5hbEdyb3Vwcy5sZW5ndGgpICogMTAwKSA6IDAsXG4gICAgICBtYnRpQmFsYW5jZVNjb3JlOiBmaW5hbEdyb3Vwcy5sZW5ndGggPiAwID8gTWF0aC5yb3VuZCgodG90YWxNYnRpQmFsYW5jZSAvIGZpbmFsR3JvdXBzLmxlbmd0aCkgKiAxMDApIDogMCxcbiAgICAgIG5ld01lZXRpbmdzQ291bnQ6IG5ld01lZXRpbmdzVG90YWxcbiAgICB9XG4gIH1cbn1cblxuLy8g6re466O5IOq3oO2YlSDstZzsoIHtmZQg7ZWo7IiYXG5mdW5jdGlvbiBvcHRpbWl6ZUdyb3VwQmFsYW5jZShncm91cHM6IFBhcnRpY2lwYW50W11bXSwgdGFyZ2V0R3JvdXBTaXplOiBudW1iZXIpIHtcbiAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDUwXG4gIFxuICBmb3IgKGxldCBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyBpdGVyYXRpb24rKykge1xuICAgIGxldCBpbXByb3ZlZCA9IGZhbHNlXG4gICAgXG4gICAgLy8g6re466O5IO2BrOq4sCDqt6DtmJUg66ee7LaU6riwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JvdXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChpID09PSBqKSBjb250aW51ZVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZ3JvdXAxID0gZ3JvdXBzW2ldXG4gICAgICAgIGNvbnN0IGdyb3VwMiA9IGdyb3Vwc1tqXVxuICAgICAgICBcbiAgICAgICAgLy8g7YGs6riwIOywqOydtOqwgCAyIOydtOyDgeyduCDqsr3smrAg7KGw7KCVXG4gICAgICAgIGlmIChncm91cDEubGVuZ3RoIC0gZ3JvdXAyLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgLy8gZ3JvdXAx7JeQ7IScIGdyb3VwMuuhnCDtlZwg66qFIOydtOuPmVxuICAgICAgICAgIGlmIChncm91cDEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgbWVtYmVyVG9Nb3ZlID0gZ3JvdXAxLnBvcCgpXG4gICAgICAgICAgICBpZiAobWVtYmVyVG9Nb3ZlKSB7XG4gICAgICAgICAgICAgIGdyb3VwMi5wdXNoKG1lbWJlclRvTW92ZSlcbiAgICAgICAgICAgICAgaW1wcm92ZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIOyEseuzhCDqt6DtmJUg6rCc7ISgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBncm91cDEgPSBncm91cHNbaV1cbiAgICAgICAgY29uc3QgZ3JvdXAyID0gZ3JvdXBzW2pdXG4gICAgICAgIFxuICAgICAgICBpZiAoZ3JvdXAxLmxlbmd0aCA9PT0gMCB8fCBncm91cDIubGVuZ3RoID09PSAwKSBjb250aW51ZVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZzFNYWxlcyA9IGdyb3VwMS5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICAgICAgY29uc3QgZzFGZW1hbGVzID0gZ3JvdXAxLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgICAgIGNvbnN0IGcyTWFsZXMgPSBncm91cDIuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gICAgICAgIGNvbnN0IGcyRmVtYWxlcyA9IGdyb3VwMi5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgICAgICBcbiAgICAgICAgLy8g7ISx67OEIOu2iOq3oO2YleydtCDsnojripQg6rK97JqwIOq1kO2ZmCDsi5zrj4RcbiAgICAgICAgaWYgKE1hdGguYWJzKGcxTWFsZXMgLSBnMUZlbWFsZXMpID4gMSB8fCBNYXRoLmFicyhnMk1hbGVzIC0gZzJGZW1hbGVzKSA+IDEpIHtcbiAgICAgICAgICBmb3IgKGxldCBwMSA9IDA7IHAxIDwgZ3JvdXAxLmxlbmd0aDsgcDErKykge1xuICAgICAgICAgICAgZm9yIChsZXQgcDIgPSAwOyBwMiA8IGdyb3VwMi5sZW5ndGg7IHAyKyspIHtcbiAgICAgICAgICAgICAgaWYgKGdyb3VwMVtwMV0uZ2VuZGVyICE9PSBncm91cDJbcDJdLmdlbmRlcikge1xuICAgICAgICAgICAgICAgIC8vIOq1kO2ZmCDsi5zrj4RcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRCYWxhbmNlMSA9IE1hdGguYWJzKGcxTWFsZXMgLSBnMUZlbWFsZXMpXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkQmFsYW5jZTIgPSBNYXRoLmFicyhnMk1hbGVzIC0gZzJGZW1hbGVzKVxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFRvdGFsQmFsYW5jZSA9IG9sZEJhbGFuY2UxICsgb2xkQmFsYW5jZTJcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyDqtZDtmZjtlbTrs7TquLBcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gZ3JvdXAxW3AxXVxuICAgICAgICAgICAgICAgIGdyb3VwMVtwMV0gPSBncm91cDJbcDJdXG4gICAgICAgICAgICAgICAgZ3JvdXAyW3AyXSA9IHRlbXBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdHMU1hbGVzID0gZ3JvdXAxLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnbWFsZScpLmxlbmd0aFxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0cxRmVtYWxlcyA9IGdyb3VwMS5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0cyTWFsZXMgPSBncm91cDIuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RzJGZW1hbGVzID0gZ3JvdXAyLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QmFsYW5jZTEgPSBNYXRoLmFicyhuZXdHMU1hbGVzIC0gbmV3RzFGZW1hbGVzKVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0JhbGFuY2UyID0gTWF0aC5hYnMobmV3RzJNYWxlcyAtIG5ld0cyRmVtYWxlcylcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUb3RhbEJhbGFuY2UgPSBuZXdCYWxhbmNlMSArIG5ld0JhbGFuY2UyXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG5ld1RvdGFsQmFsYW5jZSA8IG9sZFRvdGFsQmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgaW1wcm92ZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyDrkJjrj4zrpqzquLBcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAyID0gZ3JvdXAxW3AxXVxuICAgICAgICAgICAgICAgICAgZ3JvdXAxW3AxXSA9IGdyb3VwMltwMl1cbiAgICAgICAgICAgICAgICAgIGdyb3VwMltwMl0gPSB0ZW1wMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltcHJvdmVkKSBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wcm92ZWQpIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaW1wcm92ZWQpIGJyZWFrXG4gICAgfVxuICAgIFxuICAgIGlmICghaW1wcm92ZWQpIGJyZWFrXG4gIH1cbn1cblxuLy8g66eM64KoIO2eiOyKpO2GoOumrCDsl4XrjbDsnbTtirhcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVNZWV0aW5nSGlzdG9yeShcbiAgcGFydGljaXBhbnRzOiBQYXJ0aWNpcGFudFtdLCBcbiAgZ3JvdXBzOiBHcm91cFtdLCBcbiAgcm91bmQ6IG51bWJlclxuKTogUGFydGljaXBhbnRbXSB7XG4gIGNvbnN0IHVwZGF0ZWRQYXJ0aWNpcGFudHMgPSBwYXJ0aWNpcGFudHMubWFwKHAgPT4gKHtcbiAgICAuLi5wLFxuICAgIG1ldFBlb3BsZTogWy4uLihwLm1ldFBlb3BsZSB8fCBbXSldLFxuICAgIGdyb3VwSGlzdG9yeTogWy4uLihwLmdyb3VwSGlzdG9yeSB8fCBbXSldXG4gIH0pKVxuXG4gIC8vIOqwgSDqt7jro7kg64K0IOywuOqwgOyekOuTpOydmCDrp4zrgqgg6riw66GdIOyXheuNsOydtO2KuFxuICBncm91cHMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgLy8g6re466O5IOuyiO2YuCDtnojsiqTthqDrpqwg7JeF642w7J207Yq4XG4gICAgZ3JvdXAubWVtYmVycy5mb3JFYWNoKG1lbWJlciA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHVwZGF0ZWRQYXJ0aWNpcGFudHMuZmluZChwID0+IHAuaWQgPT09IG1lbWJlci5pZClcbiAgICAgIGlmIChwYXJ0aWNpcGFudCkge1xuICAgICAgICBwYXJ0aWNpcGFudC5ncm91cEhpc3RvcnkhLnB1c2goZ3JvdXAuaWQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIOyEnOuhnCDrp4zrgpwg6riw66GdIOyXheuNsOydtO2KuFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ3JvdXAubWVtYmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBwMSA9IHVwZGF0ZWRQYXJ0aWNpcGFudHMuZmluZChwID0+IHAuaWQgPT09IGdyb3VwLm1lbWJlcnNbaV0uaWQpXG4gICAgICAgIGNvbnN0IHAyID0gdXBkYXRlZFBhcnRpY2lwYW50cy5maW5kKHAgPT4gcC5pZCA9PT0gZ3JvdXAubWVtYmVyc1tqXS5pZClcbiAgICAgICAgXG4gICAgICAgIGlmIChwMSAmJiBwMikge1xuICAgICAgICAgIGlmICghcDEubWV0UGVvcGxlIS5pbmNsdWRlcyhwMi5pZCkpIHtcbiAgICAgICAgICAgIHAxLm1ldFBlb3BsZSEucHVzaChwMi5pZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwMi5tZXRQZW9wbGUhLmluY2x1ZGVzKHAxLmlkKSkge1xuICAgICAgICAgICAgcDIubWV0UGVvcGxlIS5wdXNoKHAxLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gdXBkYXRlZFBhcnRpY2lwYW50c1xufSJdLCJuYW1lcyI6WyJoYXZlTWV0IiwicDEiLCJwMiIsIm1ldFBlb3BsZSIsImluY2x1ZGVzIiwiaWQiLCJjYWxjdWxhdGVHcm91cEJhbGFuY2UiLCJncm91cCIsImxlbmd0aCIsIm1hbGVDb3VudCIsImZpbHRlciIsInAiLCJnZW5kZXIiLCJmZW1hbGVDb3VudCIsImV4dHJvdmVydENvdW50IiwibWJ0aSIsImludHJvdmVydENvdW50IiwiZ2VuZGVyQmFsYW5jZSIsIk1hdGgiLCJhYnMiLCJtYnRpQmFsYW5jZSIsIm5ld01lZXRpbmdzIiwidG90YWxQYWlycyIsImkiLCJqIiwibmV3TWVldGluZ1Njb3JlIiwic2hvdWxkQXZvaWRHcm91cE51bWJlciIsInBhcnRpY2lwYW50IiwiZ3JvdXBOdW1iZXIiLCJoaXN0b3J5IiwiZ3JvdXBIaXN0b3J5IiwiY3JlYXRlT3B0aW1hbEdyb3VwcyIsInBhcnRpY2lwYW50cyIsImdyb3VwU2l6ZSIsImN1cnJlbnRSb3VuZCIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsIm51bUdyb3VwcyIsImNlaWwiLCJncm91cHMiLCJBcnJheSIsImZyb20iLCJzaHVmZmxlZFBhcnRpY2lwYW50cyIsInNvcnQiLCJyYW5kb20iLCJmb3JFYWNoIiwiYmVzdEdyb3VwSW5kZXgiLCJtaW5Hcm91cFNpemUiLCJmb3VuZEF2b2lkYWJsZUdyb3VwIiwiY2FuQXZvaWRQcmV2aW91c0dyb3VwIiwicHVzaCIsIm1hcCIsImciLCJvcHRpbWl6ZUdyb3VwQmFsYW5jZSIsImZpbmFsR3JvdXBzIiwiZ3JvdXBNZW1iZXJzIiwiaW5kZXgiLCJtZW1iZXJzIiwibmV3TWVldGluZ3NUb3RhbCIsInRvdGFsR2VuZGVyQmFsYW5jZSIsInRvdGFsTWJ0aUJhbGFuY2UiLCJyb3VuZCIsInN1bW1hcnkiLCJ0b3RhbEdyb3VwcyIsImF2Z0dyb3VwU2l6ZSIsImdlbmRlckJhbGFuY2VTY29yZSIsIm1idGlCYWxhbmNlU2NvcmUiLCJuZXdNZWV0aW5nc0NvdW50IiwidGFyZ2V0R3JvdXBTaXplIiwibWF4SXRlcmF0aW9ucyIsIml0ZXJhdGlvbiIsImltcHJvdmVkIiwiZ3JvdXAxIiwiZ3JvdXAyIiwibWVtYmVyVG9Nb3ZlIiwicG9wIiwiZzFNYWxlcyIsImcxRmVtYWxlcyIsImcyTWFsZXMiLCJnMkZlbWFsZXMiLCJvbGRCYWxhbmNlMSIsIm9sZEJhbGFuY2UyIiwib2xkVG90YWxCYWxhbmNlIiwidGVtcCIsIm5ld0cxTWFsZXMiLCJuZXdHMUZlbWFsZXMiLCJuZXdHMk1hbGVzIiwibmV3RzJGZW1hbGVzIiwibmV3QmFsYW5jZTEiLCJuZXdCYWxhbmNlMiIsIm5ld1RvdGFsQmFsYW5jZSIsInRlbXAyIiwidXBkYXRlTWVldGluZ0hpc3RvcnkiLCJ1cGRhdGVkUGFydGljaXBhbnRzIiwibWVtYmVyIiwiZmluZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/grouping.ts\n"));

/***/ })

});