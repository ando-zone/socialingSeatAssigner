"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/grouping.ts":
/*!*******************************!*\
  !*** ./src/utils/grouping.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOptimalGroups: () => (/* binding */ createOptimalGroups),\n/* harmony export */   updateMeetingHistory: () => (/* binding */ updateMeetingHistory)\n/* harmony export */ });\n// 두 참가자가 이전에 만났는지 확인\nfunction haveMet(p1, p2) {\n    var _p1_metPeople;\n    return ((_p1_metPeople = p1.metPeople) === null || _p1_metPeople === void 0 ? void 0 : _p1_metPeople.includes(p2.id)) || false;\n}\n// 그룹의 균형 점수 계산 (높을수록 좋음)\nfunction calculateGroupBalance(group, groupNumber) {\n    if (group.length === 0) return 0;\n    const maleCount = group.filter((p)=>p.gender === 'male').length;\n    const femaleCount = group.filter((p)=>p.gender === 'female').length;\n    const extrovertCount = group.filter((p)=>p.mbti === 'extrovert').length;\n    const introvertCount = group.filter((p)=>p.mbti === 'introvert').length;\n    // 성별 균형 점수 (0-1)\n    const genderBalance = 1 - Math.abs(maleCount - femaleCount) / group.length;\n    // MBTI 균형 점수 (0-1)\n    const mbtiBalance = 1 - Math.abs(extrovertCount - introvertCount) / group.length;\n    // 새로운 만남 점수\n    let newMeetings = 0;\n    let totalPairs = 0;\n    for(let i = 0; i < group.length; i++){\n        for(let j = i + 1; j < group.length; j++){\n            totalPairs++;\n            if (!haveMet(group[i], group[j])) {\n                newMeetings++;\n            }\n        }\n    }\n    const newMeetingScore = totalPairs > 0 ? newMeetings / totalPairs : 1;\n    // 이전 라운드 그룹 번호 회피 점수\n    let groupAvoidanceScore = 1;\n    if (groupNumber !== undefined) {\n        const membersAvoidingPrevious = group.filter((p)=>!shouldAvoidGroupNumber(p, groupNumber)).length;\n        groupAvoidanceScore = group.length > 0 ? membersAvoidingPrevious / group.length : 1;\n    }\n    // 가중 평균 (성별 균형 60%, 새로운 만남 25%, 그룹 번호 회피 10%, MBTI 균형 5%)\n    return genderBalance * 0.6 + newMeetingScore * 0.25 + groupAvoidanceScore * 0.1 + mbtiBalance * 0.05;\n}\n// 참가자가 이전 라운드와 다른 그룹 번호를 가져야 하는지 확인\nfunction shouldAvoidGroupNumber(participant, groupNumber) {\n    const history = participant.groupHistory || [];\n    return history.length > 0 && history[history.length - 1] === groupNumber;\n}\n// 최적화된 그룹 배치 알고리즘\nfunction createOptimalGroups(participants) {\n    let groupSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, currentRound = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    if (participants.length < 2) {\n        throw new Error('최소 2명 이상의 참가자가 필요합니다.');\n    }\n    console.log(\"그룹 배치 시작: 참가자 \".concat(participants.length, \"명, 그룹 크기 \").concat(groupSize));\n    // 필요한 그룹 수 계산\n    const numGroups = Math.ceil(participants.length / groupSize);\n    console.log(\"필요한 그룹 수: \".concat(numGroups));\n    // 그룹 배열 초기화\n    const groups = Array.from({\n        length: numGroups\n    }, ()=>[]);\n    // 참가자를 그룹에 배치 (이전 라운드 그룹 번호 회피 고려)\n    const shuffledParticipants = [\n        ...participants\n    ].sort(()=>Math.random() - 0.5);\n    // 각 참가자를 적절한 그룹에 배치\n    shuffledParticipants.forEach((participant)=>{\n        let bestGroupIndex = 0;\n        let minGroupSize = groups[0].length;\n        let foundAvoidableGroup = false;\n        // 이전 라운드 그룹 번호를 회피할 수 있는 그룹 찾기\n        for(let i = 0; i < numGroups; i++){\n            const canAvoidPreviousGroup = !shouldAvoidGroupNumber(participant, i + 1);\n            if (canAvoidPreviousGroup && !foundAvoidableGroup) {\n                // 이전 그룹을 회피할 수 있는 첫 번째 그룹\n                bestGroupIndex = i;\n                minGroupSize = groups[i].length;\n                foundAvoidableGroup = true;\n            } else if (canAvoidPreviousGroup && foundAvoidableGroup) {\n                // 이전 그룹을 회피할 수 있는 그룹 중 크기가 더 작은 그룹\n                if (groups[i].length < minGroupSize) {\n                    bestGroupIndex = i;\n                    minGroupSize = groups[i].length;\n                }\n            } else if (!foundAvoidableGroup) {\n                // 이전 그룹을 회피할 수 없다면 가장 작은 그룹\n                if (groups[i].length < minGroupSize) {\n                    bestGroupIndex = i;\n                    minGroupSize = groups[i].length;\n                }\n            }\n        }\n        groups[bestGroupIndex].push(participant);\n    });\n    console.log('초기 배치 완료:', groups.map((g)=>g.length));\n    // 이전 라운드 그룹 번호 회피 통계\n    let totalAvoidanceSuccess = 0;\n    let totalParticipants = 0;\n    groups.forEach((group, index)=>{\n        const groupNumber = index + 1;\n        group.forEach((participant)=>{\n            totalParticipants++;\n            if (!shouldAvoidGroupNumber(participant, groupNumber)) {\n                totalAvoidanceSuccess++;\n            }\n        });\n    });\n    console.log(\"그룹 번호 회피 성공률: \".concat(totalParticipants > 0 ? Math.round(totalAvoidanceSuccess / totalParticipants * 100) : 0, \"% (\").concat(totalAvoidanceSuccess, \"/\").concat(totalParticipants, \")\"));\n    // 그룹 균형 최적화\n    optimizeGroupBalance(groups, groupSize);\n    console.log('최적화 완료:', groups.map((g)=>g.length));\n    // 결과 구성\n    const finalGroups = groups.map((groupMembers, index)=>{\n        const maleCount = groupMembers.filter((p)=>p.gender === 'male').length;\n        const femaleCount = groupMembers.filter((p)=>p.gender === 'female').length;\n        const extrovertCount = groupMembers.filter((p)=>p.mbti === 'extrovert').length;\n        const introvertCount = groupMembers.filter((p)=>p.mbti === 'introvert').length;\n        return {\n            id: index + 1,\n            members: groupMembers,\n            maleCount,\n            femaleCount,\n            extrovertCount,\n            introvertCount\n        };\n    }).filter((group)=>group.members.length > 0) // 빈 그룹 제거\n    ;\n    // 통계 계산\n    let newMeetingsTotal = 0;\n    let totalGenderBalance = 0;\n    let totalMbtiBalance = 0;\n    finalGroups.forEach((group)=>{\n        const groupMembers = group.members;\n        // 새로운 만남 계산\n        for(let i = 0; i < groupMembers.length; i++){\n            for(let j = i + 1; j < groupMembers.length; j++){\n                if (!haveMet(groupMembers[i], groupMembers[j])) {\n                    newMeetingsTotal++;\n                }\n            }\n        }\n        if (groupMembers.length > 0) {\n            totalGenderBalance += 1 - Math.abs(group.maleCount - group.femaleCount) / groupMembers.length;\n            totalMbtiBalance += 1 - Math.abs(group.extrovertCount - group.introvertCount) / groupMembers.length;\n        }\n    });\n    console.log(\"최종 그룹 수: \".concat(finalGroups.length));\n    console.log('각 그룹 크기:', finalGroups.map((g)=>g.members.length));\n    return {\n        groups: finalGroups,\n        round: currentRound,\n        summary: {\n            totalGroups: finalGroups.length,\n            avgGroupSize: finalGroups.length > 0 ? participants.length / finalGroups.length : 0,\n            genderBalanceScore: finalGroups.length > 0 ? Math.round(totalGenderBalance / finalGroups.length * 100) : 0,\n            mbtiBalanceScore: finalGroups.length > 0 ? Math.round(totalMbtiBalance / finalGroups.length * 100) : 0,\n            newMeetingsCount: newMeetingsTotal\n        }\n    };\n}\n// 그룹 균형 최적화 함수\nfunction optimizeGroupBalance(groups, targetGroupSize) {\n    const maxIterations = 50;\n    for(let iteration = 0; iteration < maxIterations; iteration++){\n        let improved = false;\n        // 그룹 크기 균형 맞추기\n        for(let i = 0; i < groups.length; i++){\n            for(let j = 0; j < groups.length; j++){\n                if (i === j) continue;\n                const group1 = groups[i];\n                const group2 = groups[j];\n                // 크기 차이가 2 이상인 경우 조정\n                if (group1.length - group2.length >= 2) {\n                    // group1에서 group2로 한 명 이동\n                    if (group1.length > 1) {\n                        const memberToMove = group1.pop();\n                        if (memberToMove) {\n                            group2.push(memberToMove);\n                            improved = true;\n                        }\n                    }\n                }\n            }\n        }\n        // 성별 균형 개선\n        for(let i = 0; i < groups.length; i++){\n            for(let j = i + 1; j < groups.length; j++){\n                const group1 = groups[i];\n                const group2 = groups[j];\n                if (group1.length === 0 || group2.length === 0) continue;\n                const g1Males = group1.filter((p)=>p.gender === 'male').length;\n                const g1Females = group1.filter((p)=>p.gender === 'female').length;\n                const g2Males = group2.filter((p)=>p.gender === 'male').length;\n                const g2Females = group2.filter((p)=>p.gender === 'female').length;\n                // 성별 불균형이 있는 경우 교환 시도\n                if (Math.abs(g1Males - g1Females) > 1 || Math.abs(g2Males - g2Females) > 1) {\n                    for(let p1 = 0; p1 < group1.length; p1++){\n                        for(let p2 = 0; p2 < group2.length; p2++){\n                            if (group1[p1].gender !== group2[p2].gender) {\n                                // 교환 시도\n                                const oldBalance1 = Math.abs(g1Males - g1Females);\n                                const oldBalance2 = Math.abs(g2Males - g2Females);\n                                const oldTotalBalance = oldBalance1 + oldBalance2;\n                                // 교환해보기\n                                const temp = group1[p1];\n                                group1[p1] = group2[p2];\n                                group2[p2] = temp;\n                                const newG1Males = group1.filter((p)=>p.gender === 'male').length;\n                                const newG1Females = group1.filter((p)=>p.gender === 'female').length;\n                                const newG2Males = group2.filter((p)=>p.gender === 'male').length;\n                                const newG2Females = group2.filter((p)=>p.gender === 'female').length;\n                                const newBalance1 = Math.abs(newG1Males - newG1Females);\n                                const newBalance2 = Math.abs(newG2Males - newG2Females);\n                                const newTotalBalance = newBalance1 + newBalance2;\n                                if (newTotalBalance < oldTotalBalance) {\n                                    improved = true;\n                                    break;\n                                } else {\n                                    // 되돌리기\n                                    const temp2 = group1[p1];\n                                    group1[p1] = group2[p2];\n                                    group2[p2] = temp2;\n                                }\n                            }\n                        }\n                        if (improved) break;\n                    }\n                }\n                if (improved) break;\n            }\n            if (improved) break;\n        }\n        if (!improved) break;\n    }\n}\n// 만남 히스토리 업데이트\nfunction updateMeetingHistory(participants, groups, round) {\n    const updatedParticipants = participants.map((p)=>({\n            ...p,\n            metPeople: [\n                ...p.metPeople || []\n            ],\n            groupHistory: [\n                ...p.groupHistory || []\n            ]\n        }));\n    // 각 그룹 내 참가자들의 만남 기록 업데이트\n    groups.forEach((group)=>{\n        // 그룹 번호 히스토리 업데이트\n        group.members.forEach((member)=>{\n            const participant = updatedParticipants.find((p)=>p.id === member.id);\n            if (participant) {\n                participant.groupHistory.push(group.id);\n            }\n        });\n        // 서로 만난 기록 업데이트\n        for(let i = 0; i < group.members.length; i++){\n            for(let j = i + 1; j < group.members.length; j++){\n                const p1 = updatedParticipants.find((p)=>p.id === group.members[i].id);\n                const p2 = updatedParticipants.find((p)=>p.id === group.members[j].id);\n                if (p1 && p2) {\n                    if (!p1.metPeople.includes(p2.id)) {\n                        p1.metPeople.push(p2.id);\n                    }\n                    if (!p2.metPeople.includes(p1.id)) {\n                        p2.metPeople.push(p1.id);\n                    }\n                }\n            }\n        }\n    });\n    return updatedParticipants;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ncm91cGluZy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQThCQSxxQkFBcUI7QUFDckIsU0FBU0EsUUFBUUMsRUFBZSxFQUFFQyxFQUFlO1FBQ3hDRDtJQUFQLE9BQU9BLEVBQUFBLGdCQUFBQSxHQUFHRSxTQUFTLGNBQVpGLG9DQUFBQSxjQUFjRyxRQUFRLENBQUNGLEdBQUdHLEVBQUUsTUFBSztBQUMxQztBQUVBLHlCQUF5QjtBQUN6QixTQUFTQyxzQkFBc0JDLEtBQW9CLEVBQUVDLFdBQW9CO0lBQ3ZFLElBQUlELE1BQU1FLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFL0IsTUFBTUMsWUFBWUgsTUFBTUksTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssUUFBUUosTUFBTTtJQUMvRCxNQUFNSyxjQUFjUCxNQUFNSSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxVQUFVSixNQUFNO0lBQ25FLE1BQU1NLGlCQUFpQlIsTUFBTUksTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFSSxJQUFJLEtBQUssYUFBYVAsTUFBTTtJQUN2RSxNQUFNUSxpQkFBaUJWLE1BQU1JLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUksSUFBSSxLQUFLLGFBQWFQLE1BQU07SUFFdkUsaUJBQWlCO0lBQ2pCLE1BQU1TLGdCQUFnQixJQUFJQyxLQUFLQyxHQUFHLENBQUNWLFlBQVlJLGVBQWVQLE1BQU1FLE1BQU07SUFFMUUsbUJBQW1CO0lBQ25CLE1BQU1ZLGNBQWMsSUFBSUYsS0FBS0MsR0FBRyxDQUFDTCxpQkFBaUJFLGtCQUFrQlYsTUFBTUUsTUFBTTtJQUVoRixZQUFZO0lBQ1osSUFBSWEsY0FBYztJQUNsQixJQUFJQyxhQUFhO0lBQ2pCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJakIsTUFBTUUsTUFBTSxFQUFFZSxJQUFLO1FBQ3JDLElBQUssSUFBSUMsSUFBSUQsSUFBSSxH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LElBQUtBLEVBQUVQLEVBQUUsS0FBS0UsTUFBTXlELE9BQU8sQ0FBQ3ZDLEVBQUUsQ0FBQ3BCLEVBQUU7Z0JBRXJFLElBQUlKLE1BQU1DLElBQUk7b0JBQ1osSUFBSSxDQUFDRCxHQUFHRSxTQUFTLENBQUVDLFFBQVEsQ0FBQ0YsR0FBR0csRUFBRSxHQUFHO3dCQUNsQ0osR0FBR0UsU0FBUyxDQUFFbUQsSUFBSSxDQUFDcEQsR0FBR0csRUFBRTtvQkFDMUI7b0JBQ0EsSUFBSSxDQUFDSCxHQUFHQyxTQUFTLENBQUVDLFFBQVEsQ0FBQ0gsR0FBR0ksRUFBRSxHQUFHO3dCQUNsQ0gsR0FBR0MsU0FBUyxDQUFFbUQsSUFBSSxDQUFDckQsR0FBR0ksRUFBRTtvQkFDMUI7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPOEY7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2RvaHllb25hbi9zaWRlUHJvamVjdHMvc29jaWFsaW5nU2VhdEFzc2lnbmVyL3NyYy91dGlscy9ncm91cGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFBhcnRpY2lwYW50IHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgZ2VuZGVyOiAnbWFsZScgfCAnZmVtYWxlJ1xuICBtYnRpOiAnZXh0cm92ZXJ0JyB8ICdpbnRyb3ZlcnQnXG4gIG1ldFBlb3BsZT86IHN0cmluZ1tdXG4gIGdyb3VwSGlzdG9yeT86IG51bWJlcltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXAge1xuICBpZDogbnVtYmVyXG4gIG1lbWJlcnM6IFBhcnRpY2lwYW50W11cbiAgbWFsZUNvdW50OiBudW1iZXJcbiAgZmVtYWxlQ291bnQ6IG51bWJlclxuICBleHRyb3ZlcnRDb3VudDogbnVtYmVyXG4gIGludHJvdmVydENvdW50OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91cGluZ1Jlc3VsdCB7XG4gIGdyb3VwczogR3JvdXBbXVxuICByb3VuZDogbnVtYmVyXG4gIHN1bW1hcnk6IHtcbiAgICB0b3RhbEdyb3VwczogbnVtYmVyXG4gICAgYXZnR3JvdXBTaXplOiBudW1iZXJcbiAgICBnZW5kZXJCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG1idGlCYWxhbmNlU2NvcmU6IG51bWJlclxuICAgIG5ld01lZXRpbmdzQ291bnQ6IG51bWJlclxuICB9XG59XG5cbi8vIOuRkCDssLjqsIDsnpDqsIAg7J207KCE7JeQIOunjOuCrOuKlOyngCDtmZXsnbhcbmZ1bmN0aW9uIGhhdmVNZXQocDE6IFBhcnRpY2lwYW50LCBwMjogUGFydGljaXBhbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIHAxLm1ldFBlb3BsZT8uaW5jbHVkZXMocDIuaWQpIHx8IGZhbHNlXG59XG5cbi8vIOq3uOujueydmCDqt6DtmJUg7KCQ7IiYIOqzhOyCsCAo64aS7J2E7IiY66GdIOyii+ydjClcbmZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VwQmFsYW5jZShncm91cDogUGFydGljaXBhbnRbXSwgZ3JvdXBOdW1iZXI/OiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoZ3JvdXAubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuICBcbiAgY29uc3QgbWFsZUNvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gIGNvbnN0IGZlbWFsZUNvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdmZW1hbGUnKS5sZW5ndGhcbiAgY29uc3QgZXh0cm92ZXJ0Q291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdleHRyb3ZlcnQnKS5sZW5ndGhcbiAgY29uc3QgaW50cm92ZXJ0Q291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdpbnRyb3ZlcnQnKS5sZW5ndGhcbiAgXG4gIC8vIOyEseuzhCDqt6DtmJUg7KCQ7IiYICgwLTEpXG4gIGNvbnN0IGdlbmRlckJhbGFuY2UgPSAxIC0gTWF0aC5hYnMobWFsZUNvdW50IC0gZmVtYWxlQ291bnQpIC8gZ3JvdXAubGVuZ3RoXG4gIFxuICAvLyBNQlRJIOq3oO2YlSDsoJDsiJggKDAtMSlcbiAgY29uc3QgbWJ0aUJhbGFuY2UgPSAxIC0gTWF0aC5hYnMoZXh0cm92ZXJ0Q291bnQgLSBpbnRyb3ZlcnRDb3VudCkgLyBncm91cC5sZW5ndGhcbiAgXG4gIC8vIOyDiOuhnOyatCDrp4zrgqgg7KCQ7IiYXG4gIGxldCBuZXdNZWV0aW5ncyA9IDBcbiAgbGV0IHRvdGFsUGFpcnMgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBncm91cC5sZW5ndGg7IGorKykge1xuICAgICAgdG90YWxQYWlycysrXG4gICAgICBpZiAoIWhhdmVNZXQoZ3JvdXBbaV0sIGdyb3VwW2pdKSkge1xuICAgICAgICBuZXdNZWV0aW5ncysrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld01lZXRpbmdTY29yZSA9IHRvdGFsUGFpcnMgPiAwID8gbmV3TWVldGluZ3MgLyB0b3RhbFBhaXJzIDogMVxuICBcbiAgLy8g7J207KCEIOudvOyatOuTnCDqt7jro7kg67KI7Zi4IO2ajO2UvCDsoJDsiJhcbiAgbGV0IGdyb3VwQXZvaWRhbmNlU2NvcmUgPSAxXG4gIGlmIChncm91cE51bWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbWVtYmVyc0F2b2lkaW5nUHJldmlvdXMgPSBncm91cC5maWx0ZXIocCA9PiAhc2hvdWxkQXZvaWRHcm91cE51bWJlcihwLCBncm91cE51bWJlcikpLmxlbmd0aFxuICAgIGdyb3VwQXZvaWRhbmNlU2NvcmUgPSBncm91cC5sZW5ndGggPiAwID8gbWVtYmVyc0F2b2lkaW5nUHJldmlvdXMgLyBncm91cC5sZW5ndGggOiAxXG4gIH1cbiAgXG4gIC8vIOqwgOykkSDtj4nqt6AgKOyEseuzhCDqt6DtmJUgNjAlLCDsg4jroZzsmrQg66eM64KoIDI1JSwg6re466O5IOuyiO2YuCDtmoztlLwgMTAlLCBNQlRJIOq3oO2YlSA1JSlcbiAgcmV0dXJuIGdlbmRlckJhbGFuY2UgKiAwLjYgKyBuZXdNZWV0aW5nU2NvcmUgKiAwLjI1ICsgZ3JvdXBBdm9pZGFuY2VTY29yZSAqIDAuMSArIG1idGlCYWxhbmNlICogMC4wNVxufVxuXG4vLyDssLjqsIDsnpDqsIAg7J207KCEIOudvOyatOuTnOyZgCDri6Trpbgg6re466O5IOuyiO2YuOulvCDqsIDsoLjslbwg7ZWY64qU7KeAIO2ZleyduFxuZnVuY3Rpb24gc2hvdWxkQXZvaWRHcm91cE51bWJlcihwYXJ0aWNpcGFudDogUGFydGljaXBhbnQsIGdyb3VwTnVtYmVyOiBudW1iZXIpOiBib29sZWFuIHtcbiAgY29uc3QgaGlzdG9yeSA9IHBhcnRpY2lwYW50Lmdyb3VwSGlzdG9yeSB8fCBbXVxuICByZXR1cm4gaGlzdG9yeS5sZW5ndGggPiAwICYmIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXSA9PT0gZ3JvdXBOdW1iZXJcbn1cblxuLy8g7LWc7KCB7ZmU65CcIOq3uOujuSDrsLDsuZgg7JWM6rOg66as7KaYXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3B0aW1hbEdyb3VwcyhcbiAgcGFydGljaXBhbnRzOiBQYXJ0aWNpcGFudFtdLCBcbiAgZ3JvdXBTaXplOiBudW1iZXIgPSA0LFxuICBjdXJyZW50Um91bmQ6IG51bWJlciA9IDFcbik6IEdyb3VwaW5nUmVzdWx0IHtcbiAgaWYgKHBhcnRpY2lwYW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCfstZzshowgMuuqhSDsnbTsg4HsnZgg7LC46rCA7J6Q6rCAIO2VhOyalO2VqeuLiOuLpC4nKVxuICB9XG5cbiAgY29uc29sZS5sb2coYOq3uOujuSDrsLDsuZgg7Iuc7J6ROiDssLjqsIDsnpAgJHtwYXJ0aWNpcGFudHMubGVuZ3RofeuqhSwg6re466O5IO2BrOq4sCAke2dyb3VwU2l6ZX1gKVxuXG4gIC8vIO2VhOyalO2VnCDqt7jro7kg7IiYIOqzhOyCsFxuICBjb25zdCBudW1Hcm91cHMgPSBNYXRoLmNlaWwocGFydGljaXBhbnRzLmxlbmd0aCAvIGdyb3VwU2l6ZSlcbiAgY29uc29sZS5sb2coYO2VhOyalO2VnCDqt7jro7kg7IiYOiAke251bUdyb3Vwc31gKVxuXG4gIC8vIOq3uOujuSDrsLDsl7Qg7LSI6riw7ZmUXG4gIGNvbnN0IGdyb3VwczogUGFydGljaXBhbnRbXVtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtR3JvdXBzIH0sICgpID0+IFtdKVxuXG4gIC8vIOywuOqwgOyekOulvCDqt7jro7nsl5Ag67Cw7LmYICjsnbTsoIQg65287Jq065OcIOq3uOujuSDrsojtmLgg7ZqM7ZS8IOqzoOugpClcbiAgY29uc3Qgc2h1ZmZsZWRQYXJ0aWNpcGFudHMgPSBbLi4ucGFydGljaXBhbnRzXS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpXG4gIFxuICAvLyDqsIEg7LC46rCA7J6Q66W8IOyggeygiO2VnCDqt7jro7nsl5Ag67Cw7LmYXG4gIHNodWZmbGVkUGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgbGV0IGJlc3RHcm91cEluZGV4ID0gMFxuICAgIGxldCBtaW5Hcm91cFNpemUgPSBncm91cHNbMF0ubGVuZ3RoXG4gICAgbGV0IGZvdW5kQXZvaWRhYmxlR3JvdXAgPSBmYWxzZVxuICAgIFxuICAgIC8vIOydtOyghCDrnbzsmrTrk5wg6re466O5IOuyiO2YuOulvCDtmoztlLztlaAg7IiYIOyeiOuKlCDqt7jro7kg7LC+6riwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Hcm91cHM7IGkrKykge1xuICAgICAgY29uc3QgY2FuQXZvaWRQcmV2aW91c0dyb3VwID0gIXNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQsIGkgKyAxKVxuICAgICAgXG4gICAgICBpZiAoY2FuQXZvaWRQcmV2aW91c0dyb3VwICYmICFmb3VuZEF2b2lkYWJsZUdyb3VwKSB7XG4gICAgICAgIC8vIOydtOyghCDqt7jro7nsnYQg7ZqM7ZS87ZWgIOyImCDsnojripQg7LKrIOuyiOynuCDqt7jro7lcbiAgICAgICAgYmVzdEdyb3VwSW5kZXggPSBpXG4gICAgICAgIG1pbkdyb3VwU2l6ZSA9IGdyb3Vwc1tpXS5sZW5ndGhcbiAgICAgICAgZm91bmRBdm9pZGFibGVHcm91cCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoY2FuQXZvaWRQcmV2aW91c0dyb3VwICYmIGZvdW5kQXZvaWRhYmxlR3JvdXApIHtcbiAgICAgICAgLy8g7J207KCEIOq3uOujueydhCDtmoztlLztlaAg7IiYIOyeiOuKlCDqt7jro7kg7KSRIO2BrOq4sOqwgCDrjZQg7J6R7J2AIOq3uOujuVxuICAgICAgICBpZiAoZ3JvdXBzW2ldLmxlbmd0aCA8IG1pbkdyb3VwU2l6ZSkge1xuICAgICAgICAgIGJlc3RHcm91cEluZGV4ID0gaVxuICAgICAgICAgIG1pbkdyb3VwU2l6ZSA9IGdyb3Vwc1tpXS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghZm91bmRBdm9pZGFibGVHcm91cCkge1xuICAgICAgICAvLyDsnbTsoIQg6re466O57J2EIO2ajO2UvO2VoCDsiJgg7JeG64uk66m0IOqwgOyepSDsnpHsnYAg6re466O5XG4gICAgICAgIGlmIChncm91cHNbaV0ubGVuZ3RoIDwgbWluR3JvdXBTaXplKSB7XG4gICAgICAgICAgYmVzdEdyb3VwSW5kZXggPSBpXG4gICAgICAgICAgbWluR3JvdXBTaXplID0gZ3JvdXBzW2ldLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGdyb3Vwc1tiZXN0R3JvdXBJbmRleF0ucHVzaChwYXJ0aWNpcGFudClcbiAgfSlcblxuICBjb25zb2xlLmxvZygn7LSI6riwIOuwsOy5mCDsmYTro4w6JywgZ3JvdXBzLm1hcChnID0+IGcubGVuZ3RoKSlcbiAgXG4gIC8vIOydtOyghCDrnbzsmrTrk5wg6re466O5IOuyiO2YuCDtmoztlLwg7Ya16rOEXG4gIGxldCB0b3RhbEF2b2lkYW5jZVN1Y2Nlc3MgPSAwXG4gIGxldCB0b3RhbFBhcnRpY2lwYW50cyA9IDBcbiAgZ3JvdXBzLmZvckVhY2goKGdyb3VwLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGdyb3VwTnVtYmVyID0gaW5kZXggKyAxXG4gICAgZ3JvdXAuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgICB0b3RhbFBhcnRpY2lwYW50cysrXG4gICAgICBpZiAoIXNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQsIGdyb3VwTnVtYmVyKSkge1xuICAgICAgICB0b3RhbEF2b2lkYW5jZVN1Y2Nlc3MrK1xuICAgICAgfVxuICAgIH0pXG4gIH0pXG4gIGNvbnNvbGUubG9nKGDqt7jro7kg67KI7Zi4IO2ajO2UvCDshLHqs7XrpaA6ICR7dG90YWxQYXJ0aWNpcGFudHMgPiAwID8gTWF0aC5yb3VuZCgodG90YWxBdm9pZGFuY2VTdWNjZXNzIC8gdG90YWxQYXJ0aWNpcGFudHMpICogMTAwKSA6IDB9JSAoJHt0b3RhbEF2b2lkYW5jZVN1Y2Nlc3N9LyR7dG90YWxQYXJ0aWNpcGFudHN9KWApXG5cbiAgLy8g6re466O5IOq3oO2YlSDstZzsoIHtmZRcbiAgb3B0aW1pemVHcm91cEJhbGFuY2UoZ3JvdXBzLCBncm91cFNpemUpXG5cbiAgY29uc29sZS5sb2coJ+y1nOygge2ZlCDsmYTro4w6JywgZ3JvdXBzLm1hcChnID0+IGcubGVuZ3RoKSlcblxuICAvLyDqsrDqs7wg6rWs7ISxXG4gIGNvbnN0IGZpbmFsR3JvdXBzOiBHcm91cFtdID0gZ3JvdXBzLm1hcCgoZ3JvdXBNZW1iZXJzLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICBjb25zdCBmZW1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgIGNvbnN0IGV4dHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2V4dHJvdmVydCcpLmxlbmd0aFxuICAgIGNvbnN0IGludHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBpZDogaW5kZXggKyAxLFxuICAgICAgbWVtYmVyczogZ3JvdXBNZW1iZXJzLFxuICAgICAgbWFsZUNvdW50LFxuICAgICAgZmVtYWxlQ291bnQsXG4gICAgICBleHRyb3ZlcnRDb3VudCxcbiAgICAgIGludHJvdmVydENvdW50XG4gICAgfVxuICB9KS5maWx0ZXIoZ3JvdXAgPT4gZ3JvdXAubWVtYmVycy5sZW5ndGggPiAwKSAvLyDruYgg6re466O5IOygnOqxsFxuXG4gIC8vIO2GteqzhCDqs4TsgrBcbiAgbGV0IG5ld01lZXRpbmdzVG90YWwgPSAwXG4gIGxldCB0b3RhbEdlbmRlckJhbGFuY2UgPSAwXG4gIGxldCB0b3RhbE1idGlCYWxhbmNlID0gMFxuICBcbiAgZmluYWxHcm91cHMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgY29uc3QgZ3JvdXBNZW1iZXJzID0gZ3JvdXAubWVtYmVyc1xuICAgIFxuICAgIC8vIOyDiOuhnOyatCDrp4zrgqgg6rOE7IKwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cE1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwTWVtYmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIWhhdmVNZXQoZ3JvdXBNZW1iZXJzW2ldLCBncm91cE1lbWJlcnNbal0pKSB7XG4gICAgICAgICAgbmV3TWVldGluZ3NUb3RhbCsrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGdyb3VwTWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0b3RhbEdlbmRlckJhbGFuY2UgKz0gMSAtIE1hdGguYWJzKGdyb3VwLm1hbGVDb3VudCAtIGdyb3VwLmZlbWFsZUNvdW50KSAvIGdyb3VwTWVtYmVycy5sZW5ndGhcbiAgICAgIHRvdGFsTWJ0aUJhbGFuY2UgKz0gMSAtIE1hdGguYWJzKGdyb3VwLmV4dHJvdmVydENvdW50IC0gZ3JvdXAuaW50cm92ZXJ0Q291bnQpIC8gZ3JvdXBNZW1iZXJzLmxlbmd0aFxuICAgIH1cbiAgfSlcblxuICBjb25zb2xlLmxvZyhg7LWc7KKFIOq3uOujuSDsiJg6ICR7ZmluYWxHcm91cHMubGVuZ3RofWApXG4gIGNvbnNvbGUubG9nKCfqsIEg6re466O5IO2BrOq4sDonLCBmaW5hbEdyb3Vwcy5tYXAoZyA9PiBnLm1lbWJlcnMubGVuZ3RoKSlcblxuICByZXR1cm4ge1xuICAgIGdyb3VwczogZmluYWxHcm91cHMsXG4gICAgcm91bmQ6IGN1cnJlbnRSb3VuZCxcbiAgICBzdW1tYXJ5OiB7XG4gICAgICB0b3RhbEdyb3VwczogZmluYWxHcm91cHMubGVuZ3RoLFxuICAgICAgYXZnR3JvdXBTaXplOiBmaW5hbEdyb3Vwcy5sZW5ndGggPiAwID8gcGFydGljaXBhbnRzLmxlbmd0aCAvIGZpbmFsR3JvdXBzLmxlbmd0aCA6IDAsXG4gICAgICBnZW5kZXJCYWxhbmNlU2NvcmU6IGZpbmFsR3JvdXBzLmxlbmd0aCA+IDAgPyBNYXRoLnJvdW5kKCh0b3RhbEdlbmRlckJhbGFuY2UgLyBmaW5hbEdyb3Vwcy5sZW5ndGgpICogMTAwKSA6IDAsXG4gICAgICBtYnRpQmFsYW5jZVNjb3JlOiBmaW5hbEdyb3Vwcy5sZW5ndGggPiAwID8gTWF0aC5yb3VuZCgodG90YWxNYnRpQmFsYW5jZSAvIGZpbmFsR3JvdXBzLmxlbmd0aCkgKiAxMDApIDogMCxcbiAgICAgIG5ld01lZXRpbmdzQ291bnQ6IG5ld01lZXRpbmdzVG90YWxcbiAgICB9XG4gIH1cbn1cblxuLy8g6re466O5IOq3oO2YlSDstZzsoIHtmZQg7ZWo7IiYXG5mdW5jdGlvbiBvcHRpbWl6ZUdyb3VwQmFsYW5jZShncm91cHM6IFBhcnRpY2lwYW50W11bXSwgdGFyZ2V0R3JvdXBTaXplOiBudW1iZXIpIHtcbiAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDUwXG4gIFxuICBmb3IgKGxldCBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyBpdGVyYXRpb24rKykge1xuICAgIGxldCBpbXByb3ZlZCA9IGZhbHNlXG4gICAgXG4gICAgLy8g6re466O5IO2BrOq4sCDqt6DtmJUg66ee7LaU6riwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JvdXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChpID09PSBqKSBjb250aW51ZVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZ3JvdXAxID0gZ3JvdXBzW2ldXG4gICAgICAgIGNvbnN0IGdyb3VwMiA9IGdyb3Vwc1tqXVxuICAgICAgICBcbiAgICAgICAgLy8g7YGs6riwIOywqOydtOqwgCAyIOydtOyDgeyduCDqsr3smrAg7KGw7KCVXG4gICAgICAgIGlmIChncm91cDEubGVuZ3RoIC0gZ3JvdXAyLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgLy8gZ3JvdXAx7JeQ7IScIGdyb3VwMuuhnCDtlZwg66qFIOydtOuPmVxuICAgICAgICAgIGlmIChncm91cDEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgbWVtYmVyVG9Nb3ZlID0gZ3JvdXAxLnBvcCgpXG4gICAgICAgICAgICBpZiAobWVtYmVyVG9Nb3ZlKSB7XG4gICAgICAgICAgICAgIGdyb3VwMi5wdXNoKG1lbWJlclRvTW92ZSlcbiAgICAgICAgICAgICAgaW1wcm92ZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIOyEseuzhCDqt6DtmJUg6rCc7ISgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBncm91cDEgPSBncm91cHNbaV1cbiAgICAgICAgY29uc3QgZ3JvdXAyID0gZ3JvdXBzW2pdXG4gICAgICAgIFxuICAgICAgICBpZiAoZ3JvdXAxLmxlbmd0aCA9PT0gMCB8fCBncm91cDIubGVuZ3RoID09PSAwKSBjb250aW51ZVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZzFNYWxlcyA9IGdyb3VwMS5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICAgICAgY29uc3QgZzFGZW1hbGVzID0gZ3JvdXAxLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgICAgIGNvbnN0IGcyTWFsZXMgPSBncm91cDIuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gICAgICAgIGNvbnN0IGcyRmVtYWxlcyA9IGdyb3VwMi5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgICAgICBcbiAgICAgICAgLy8g7ISx67OEIOu2iOq3oO2YleydtCDsnojripQg6rK97JqwIOq1kO2ZmCDsi5zrj4RcbiAgICAgICAgaWYgKE1hdGguYWJzKGcxTWFsZXMgLSBnMUZlbWFsZXMpID4gMSB8fCBNYXRoLmFicyhnMk1hbGVzIC0gZzJGZW1hbGVzKSA+IDEpIHtcbiAgICAgICAgICBmb3IgKGxldCBwMSA9IDA7IHAxIDwgZ3JvdXAxLmxlbmd0aDsgcDErKykge1xuICAgICAgICAgICAgZm9yIChsZXQgcDIgPSAwOyBwMiA8IGdyb3VwMi5sZW5ndGg7IHAyKyspIHtcbiAgICAgICAgICAgICAgaWYgKGdyb3VwMVtwMV0uZ2VuZGVyICE9PSBncm91cDJbcDJdLmdlbmRlcikge1xuICAgICAgICAgICAgICAgIC8vIOq1kO2ZmCDsi5zrj4RcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRCYWxhbmNlMSA9IE1hdGguYWJzKGcxTWFsZXMgLSBnMUZlbWFsZXMpXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkQmFsYW5jZTIgPSBNYXRoLmFicyhnMk1hbGVzIC0gZzJGZW1hbGVzKVxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFRvdGFsQmFsYW5jZSA9IG9sZEJhbGFuY2UxICsgb2xkQmFsYW5jZTJcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyDqtZDtmZjtlbTrs7TquLBcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gZ3JvdXAxW3AxXVxuICAgICAgICAgICAgICAgIGdyb3VwMVtwMV0gPSBncm91cDJbcDJdXG4gICAgICAgICAgICAgICAgZ3JvdXAyW3AyXSA9IHRlbXBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdHMU1hbGVzID0gZ3JvdXAxLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnbWFsZScpLmxlbmd0aFxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0cxRmVtYWxlcyA9IGdyb3VwMS5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0cyTWFsZXMgPSBncm91cDIuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RzJGZW1hbGVzID0gZ3JvdXAyLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QmFsYW5jZTEgPSBNYXRoLmFicyhuZXdHMU1hbGVzIC0gbmV3RzFGZW1hbGVzKVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0JhbGFuY2UyID0gTWF0aC5hYnMobmV3RzJNYWxlcyAtIG5ld0cyRmVtYWxlcylcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUb3RhbEJhbGFuY2UgPSBuZXdCYWxhbmNlMSArIG5ld0JhbGFuY2UyXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG5ld1RvdGFsQmFsYW5jZSA8IG9sZFRvdGFsQmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgaW1wcm92ZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyDrkJjrj4zrpqzquLBcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAyID0gZ3JvdXAxW3AxXVxuICAgICAgICAgICAgICAgICAgZ3JvdXAxW3AxXSA9IGdyb3VwMltwMl1cbiAgICAgICAgICAgICAgICAgIGdyb3VwMltwMl0gPSB0ZW1wMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltcHJvdmVkKSBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wcm92ZWQpIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaW1wcm92ZWQpIGJyZWFrXG4gICAgfVxuICAgIFxuICAgIGlmICghaW1wcm92ZWQpIGJyZWFrXG4gIH1cbn1cblxuLy8g66eM64KoIO2eiOyKpO2GoOumrCDsl4XrjbDsnbTtirhcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVNZWV0aW5nSGlzdG9yeShcbiAgcGFydGljaXBhbnRzOiBQYXJ0aWNpcGFudFtdLCBcbiAgZ3JvdXBzOiBHcm91cFtdLCBcbiAgcm91bmQ6IG51bWJlclxuKTogUGFydGljaXBhbnRbXSB7XG4gIGNvbnN0IHVwZGF0ZWRQYXJ0aWNpcGFudHMgPSBwYXJ0aWNpcGFudHMubWFwKHAgPT4gKHtcbiAgICAuLi5wLFxuICAgIG1ldFBlb3BsZTogWy4uLihwLm1ldFBlb3BsZSB8fCBbXSldLFxuICAgIGdyb3VwSGlzdG9yeTogWy4uLihwLmdyb3VwSGlzdG9yeSB8fCBbXSldXG4gIH0pKVxuXG4gIC8vIOqwgSDqt7jro7kg64K0IOywuOqwgOyekOuTpOydmCDrp4zrgqgg6riw66GdIOyXheuNsOydtO2KuFxuICBncm91cHMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgLy8g6re466O5IOuyiO2YuCDtnojsiqTthqDrpqwg7JeF642w7J207Yq4XG4gICAgZ3JvdXAubWVtYmVycy5mb3JFYWNoKG1lbWJlciA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHVwZGF0ZWRQYXJ0aWNpcGFudHMuZmluZChwID0+IHAuaWQgPT09IG1lbWJlci5pZClcbiAgICAgIGlmIChwYXJ0aWNpcGFudCkge1xuICAgICAgICBwYXJ0aWNpcGFudC5ncm91cEhpc3RvcnkhLnB1c2goZ3JvdXAuaWQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIOyEnOuhnCDrp4zrgpwg6riw66GdIOyXheuNsOydtO2KuFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ3JvdXAubWVtYmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBwMSA9IHVwZGF0ZWRQYXJ0aWNpcGFudHMuZmluZChwID0+IHAuaWQgPT09IGdyb3VwLm1lbWJlcnNbaV0uaWQpXG4gICAgICAgIGNvbnN0IHAyID0gdXBkYXRlZFBhcnRpY2lwYW50cy5maW5kKHAgPT4gcC5pZCA9PT0gZ3JvdXAubWVtYmVyc1tqXS5pZClcbiAgICAgICAgXG4gICAgICAgIGlmIChwMSAmJiBwMikge1xuICAgICAgICAgIGlmICghcDEubWV0UGVvcGxlIS5pbmNsdWRlcyhwMi5pZCkpIHtcbiAgICAgICAgICAgIHAxLm1ldFBlb3BsZSEucHVzaChwMi5pZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwMi5tZXRQZW9wbGUhLmluY2x1ZGVzKHAxLmlkKSkge1xuICAgICAgICAgICAgcDIubWV0UGVvcGxlIS5wdXNoKHAxLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gdXBkYXRlZFBhcnRpY2lwYW50c1xufSJdLCJuYW1lcyI6WyJoYXZlTWV0IiwicDEiLCJwMiIsIm1ldFBlb3BsZSIsImluY2x1ZGVzIiwiaWQiLCJjYWxjdWxhdGVHcm91cEJhbGFuY2UiLCJncm91cCIsImdyb3VwTnVtYmVyIiwibGVuZ3RoIiwibWFsZUNvdW50IiwiZmlsdGVyIiwicCIsImdlbmRlciIsImZlbWFsZUNvdW50IiwiZXh0cm92ZXJ0Q291bnQiLCJtYnRpIiwiaW50cm92ZXJ0Q291bnQiLCJnZW5kZXJCYWxhbmNlIiwiTWF0aCIsImFicyIsIm1idGlCYWxhbmNlIiwibmV3TWVldGluZ3MiLCJ0b3RhbFBhaXJzIiwiaSIsImoiLCJuZXdNZWV0aW5nU2NvcmUiLCJncm91cEF2b2lkYW5jZVNjb3JlIiwidW5kZWZpbmVkIiwibWVtYmVyc0F2b2lkaW5nUHJldmlvdXMiLCJzaG91bGRBdm9pZEdyb3VwTnVtYmVyIiwicGFydGljaXBhbnQiLCJoaXN0b3J5IiwiZ3JvdXBIaXN0b3J5IiwiY3JlYXRlT3B0aW1hbEdyb3VwcyIsInBhcnRpY2lwYW50cyIsImdyb3VwU2l6ZSIsImN1cnJlbnRSb3VuZCIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsIm51bUdyb3VwcyIsImNlaWwiLCJncm91cHMiLCJBcnJheSIsImZyb20iLCJzaHVmZmxlZFBhcnRpY2lwYW50cyIsInNvcnQiLCJyYW5kb20iLCJmb3JFYWNoIiwiYmVzdEdyb3VwSW5kZXgiLCJtaW5Hcm91cFNpemUiLCJmb3VuZEF2b2lkYWJsZUdyb3VwIiwiY2FuQXZvaWRQcmV2aW91c0dyb3VwIiwicHVzaCIsIm1hcCIsImciLCJ0b3RhbEF2b2lkYW5jZVN1Y2Nlc3MiLCJ0b3RhbFBhcnRpY2lwYW50cyIsImluZGV4Iiwicm91bmQiLCJvcHRpbWl6ZUdyb3VwQmFsYW5jZSIsImZpbmFsR3JvdXBzIiwiZ3JvdXBNZW1iZXJzIiwibWVtYmVycyIsIm5ld01lZXRpbmdzVG90YWwiLCJ0b3RhbEdlbmRlckJhbGFuY2UiLCJ0b3RhbE1idGlCYWxhbmNlIiwic3VtbWFyeSIsInRvdGFsR3JvdXBzIiwiYXZnR3JvdXBTaXplIiwiZ2VuZGVyQmFsYW5jZVNjb3JlIiwibWJ0aUJhbGFuY2VTY29yZSIsIm5ld01lZXRpbmdzQ291bnQiLCJ0YXJnZXRHcm91cFNpemUiLCJtYXhJdGVyYXRpb25zIiwiaXRlcmF0aW9uIiwiaW1wcm92ZWQiLCJncm91cDEiLCJncm91cDIiLCJtZW1iZXJUb01vdmUiLCJwb3AiLCJnMU1hbGVzIiwiZzFGZW1hbGVzIiwiZzJNYWxlcyIsImcyRmVtYWxlcyIsIm9sZEJhbGFuY2UxIiwib2xkQmFsYW5jZTIiLCJvbGRUb3RhbEJhbGFuY2UiLCJ0ZW1wIiwibmV3RzFNYWxlcyIsIm5ld0cxRmVtYWxlcyIsIm5ld0cyTWFsZXMiLCJuZXdHMkZlbWFsZXMiLCJuZXdCYWxhbmNlMSIsIm5ld0JhbGFuY2UyIiwibmV3VG90YWxCYWxhbmNlIiwidGVtcDIiLCJ1cGRhdGVNZWV0aW5nSGlzdG9yeSIsInVwZGF0ZWRQYXJ0aWNpcGFudHMiLCJtZW1iZXIiLCJmaW5kIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/grouping.ts\n"));

/***/ })

});