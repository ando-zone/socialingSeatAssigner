"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/grouping.ts":
/*!*******************************!*\
  !*** ./src/utils/grouping.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOptimalGroups: () => (/* binding */ createOptimalGroups),\n/* harmony export */   updateMeetingHistory: () => (/* binding */ updateMeetingHistory)\n/* harmony export */ });\n// 두 참가자가 이전에 만났는지 확인\nfunction haveMet(p1, p2) {\n    var _p1_metPeople;\n    return ((_p1_metPeople = p1.metPeople) === null || _p1_metPeople === void 0 ? void 0 : _p1_metPeople.includes(p2.id)) || false;\n}\n// 그룹의 균형 점수 계산 (높을수록 좋음)\nfunction calculateGroupBalance(group) {\n    const maleCount = group.filter((p)=>p.gender === 'male').length;\n    const femaleCount = group.filter((p)=>p.gender === 'female').length;\n    const extrovertCount = group.filter((p)=>p.mbti === 'extrovert').length;\n    const introvertCount = group.filter((p)=>p.mbti === 'introvert').length;\n    // 성별 균형 점수 (우선순위 높음)\n    const genderBalance = 1 - Math.abs(maleCount - femaleCount) / group.length;\n    // MBTI 균형 점수 (우선순위 낮음)\n    const mbtiBalance = 1 - Math.abs(extrovertCount - introvertCount) / group.length;\n    // 새로운 만남 점수\n    let newMeetings = 0;\n    let totalPairs = 0;\n    for(let i = 0; i < group.length; i++){\n        for(let j = i + 1; j < group.length; j++){\n            totalPairs++;\n            if (!haveMet(group[i], group[j])) {\n                newMeetings++;\n            }\n        }\n    }\n    const newMeetingScore = totalPairs > 0 ? newMeetings / totalPairs : 1;\n    // 가중 평균 (성별 균형 70%, 새로운 만남 25%, MBTI 균형 5%)\n    return genderBalance * 0.7 + newMeetingScore * 0.25 + mbtiBalance * 0.05;\n}\n// 참가자가 이전 라운드와 다른 그룹 번호를 가져야 하는지 확인\nfunction shouldAvoidGroupNumber(participant, groupNumber) {\n    const history = participant.groupHistory || [];\n    return history.length > 0 && history[history.length - 1] === groupNumber;\n}\n// 유전 알고리즘을 사용한 그룹 배치\nfunction createOptimalGroups(participants) {\n    let groupSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, currentRound = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    if (participants.length < 2) {\n        throw new Error('최소 2명 이상의 참가자가 필요합니다.');\n    }\n    const numGroups = Math.ceil(participants.length / groupSize);\n    const populationSize = 100;\n    const generations = 200;\n    const mutationRate = 0.1;\n    // 개체 생성 (그룹 배치 방식)\n    function createIndividual() {\n        const individual = new Array(participants.length);\n        const groupSizes = new Array(numGroups).fill(0);\n        for(let i = 0; i < participants.length; i++){\n            let groupIndex;\n            let attempts = 0;\n            do {\n                groupIndex = Math.floor(Math.random() * numGroups);\n                attempts++;\n            }while (attempts < 10 && (groupSizes[groupIndex] >= groupSize || shouldAvoidGroupNumber(participants[i], groupIndex + 1)));\n            individual[i] = groupIndex;\n            groupSizes[groupIndex]++;\n        }\n        return individual;\n    }\n    // 적합도 계산\n    function calculateFitness(individual) {\n        const groups = Array.from({\n            length: numGroups\n        }, ()=>[]);\n        individual.forEach((groupIndex, participantIndex)=>{\n            groups[groupIndex].push(participants[participantIndex]);\n        });\n        let totalScore = 0;\n        let validGroups = 0;\n        for (const group of groups){\n            if (group.length > 0) {\n                totalScore += calculateGroupBalance(group);\n                validGroups++;\n                // 그룹 번호 회피 보너스\n                for (const participant of group){\n                    const groupNumber = groups.indexOf(group) + 1;\n                    if (!shouldAvoidGroupNumber(participant, groupNumber)) {\n                        totalScore += 0.1;\n                    }\n                }\n            }\n        }\n        return validGroups > 0 ? totalScore / validGroups : 0;\n    }\n    // 교차\n    function crossover(parent1, parent2) {\n        const child = new Array(participants.length);\n        const crossoverPoint = Math.floor(Math.random() * participants.length);\n        for(let i = 0; i < participants.length; i++){\n            child[i] = i < crossoverPoint ? parent1[i] : parent2[i];\n        }\n        return child;\n    }\n    // 돌연변이\n    function mutate(individual) {\n        const mutated = [\n            ...individual\n        ];\n        for(let i = 0; i < mutated.length; i++){\n            if (Math.random() < mutationRate) {\n                let newGroup;\n                let attempts = 0;\n                do {\n                    newGroup = Math.floor(Math.random() * numGroups);\n                    attempts++;\n                }while (attempts < 5 && shouldAvoidGroupNumber(participants[i], newGroup + 1));\n                mutated[i] = newGroup;\n            }\n        }\n        return mutated;\n    }\n    // 유전 알고리즘 실행\n    let population = Array.from({\n        length: populationSize\n    }, ()=>createIndividual());\n    for(let generation = 0; generation < generations; generation++){\n        // 적합도 계산 및 정렬\n        const fitnessScores = population.map(calculateFitness);\n        const sortedIndices = fitnessScores.map((fitness, index)=>({\n                fitness,\n                index\n            })).sort((a, b)=>b.fitness - a.fitness);\n        // 엘리트 선택 (상위 20%)\n        const eliteSize = Math.floor(populationSize * 0.2);\n        const newPopulation = sortedIndices.slice(0, eliteSize).map((item)=>population[item.index]);\n        // 나머지는 교차와 돌연변이로 생성\n        while(newPopulation.length < populationSize){\n            const parent1Index = Math.floor(Math.random() * eliteSize);\n            const parent2Index = Math.floor(Math.random() * eliteSize);\n            const parent1 = newPopulation[parent1Index];\n            const parent2 = newPopulation[parent2Index];\n            let child = crossover(parent1, parent2);\n            child = mutate(child);\n            newPopulation.push(child);\n        }\n        population = newPopulation;\n    }\n    // 최적 해 선택\n    const fitnessScores = population.map(calculateFitness);\n    const bestIndex = fitnessScores.indexOf(Math.max(...fitnessScores));\n    const bestSolution = population[bestIndex];\n    // 결과 구성\n    const finalGroups = [];\n    const groupArrays = Array.from({\n        length: numGroups\n    }, ()=>[]);\n    bestSolution.forEach((groupIndex, participantIndex)=>{\n        groupArrays[groupIndex].push(participants[participantIndex]);\n    });\n    let newMeetingsTotal = 0;\n    let totalGenderBalance = 0;\n    let totalMbtiBalance = 0;\n    groupArrays.forEach((groupMembers, index)=>{\n        const maleCount = groupMembers.filter((p)=>p.gender === 'male').length;\n        const femaleCount = groupMembers.filter((p)=>p.gender === 'female').length;\n        const extrovertCount = groupMembers.filter((p)=>p.mbti === 'extrovert').length;\n        const introvertCount = groupMembers.filter((p)=>p.mbti === 'introvert').length;\n        // 새로운 만남 계산 (빈 그룹이 아닐 때만)\n        if (groupMembers.length > 0) {\n            for(let i = 0; i < groupMembers.length; i++){\n                for(let j = i + 1; j < groupMembers.length; j++){\n                    if (!haveMet(groupMembers[i], groupMembers[j])) {\n                        newMeetingsTotal++;\n                    }\n                }\n            }\n            totalGenderBalance += 1 - Math.abs(maleCount - femaleCount) / groupMembers.length;\n            totalMbtiBalance += 1 - Math.abs(extrovertCount - introvertCount) / groupMembers.length;\n        }\n        // 모든 그룹을 포함 (빈 그룹도 포함)\n        finalGroups.push({\n            id: index + 1,\n            members: groupMembers,\n            maleCount,\n            femaleCount,\n            extrovertCount,\n            introvertCount\n        });\n    });\n    return {\n        groups: finalGroups,\n        round: currentRound,\n        summary: {\n            totalGroups: finalGroups.length,\n            avgGroupSize: participants.length / finalGroups.length,\n            genderBalanceScore: Math.round(totalGenderBalance / finalGroups.length * 100),\n            mbtiBalanceScore: Math.round(totalMbtiBalance / finalGroups.length * 100),\n            newMeetingsCount: newMeetingsTotal\n        }\n    };\n}\n// 만남 히스토리 업데이트\nfunction updateMeetingHistory(participants, groups, round) {\n    const updatedParticipants = participants.map((p)=>({\n            ...p,\n            metPeople: [\n                ...p.metPeople || []\n            ],\n            groupHistory: [\n                ...p.groupHistory || []\n            ]\n        }));\n    // 각 그룹 내 참가자들의 만남 기록 업데이트\n    groups.forEach((group)=>{\n        // 그룹 번호 히스토리 업데이트\n        group.members.forEach((member)=>{\n            const participant = updatedParticipants.find((p)=>p.id === member.id);\n            if (participant) {\n                participant.groupHistory.push(group.id);\n            }\n        });\n        // 서로 만난 기록 업데이트\n        for(let i = 0; i < group.members.length; i++){\n            for(let j = i + 1; j < group.members.length; j++){\n                const p1 = updatedParticipants.find((p)=>p.id === group.members[i].id);\n                const p2 = updatedParticipants.find((p)=>p.id === group.members[j].id);\n                if (p1 && p2) {\n                    if (!p1.metPeople.includes(p2.id)) {\n                        p1.metPeople.push(p2.id);\n                    }\n                    if (!p2.metPeople.includes(p1.id)) {\n                        p2.metPeople.push(p1.id);\n                    }\n                }\n            }\n        }\n    });\n    return updatedParticipants;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ncm91cGluZy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQThCQSxxQkFBcUI7QUFDckIsU0FBU0EsUUFBUUMsRUFBZSxFQUFFQyxFQUFlO1FBQ3hDRDtJQUFQLE9BQU9BLEVBQUFBLGdCQUFBQSxHQUFHRSxTQUFTLGNBQVpGLG9DQUFBQSxjQUFjRyxRQUFRLENBQUNGLEdBQUdHLEVBQUUsTUFBSztBQUMxQztBQUVBLHlCQUF5QjtBQUN6QixTQUFTQyxzQkFBc0JDLEtBQW9CO0lBQ2pELE1BQU1DLFlBQVlELE1BQU1FLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTSxLQUFLLFFBQVFDLE1BQU07SUFDL0QsTUFBTUMsY0FBY04sTUFBTUUsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssVUFBVUMsTUFBTTtJQUNuRSxNQUFNRSxpQkFBaUJQLE1BQU1FLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUssSUFBSSxLQUFLLGFBQWFILE1BQU07SUFDdkUsTUFBTUksaUJBQWlCVCxNQUFNRSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVLLElBQUksS0FBSyxhQUFhSCxNQUFNO0lBRXZFLHFCQUFxQjtJQUNyQixNQUFNSyxnQkFBZ0IsSUFBSUMsS0FBS0MsR0FBRyxDQUFDWCxZQUFZSyxlQUFlTixNQUFNSyxNQUFNO0lBRTFFLHVCQUF1QjtJQUN2QixNQUFNUSxjQUFjLElBQUlGLEtBQUtDLEdBQUcsQ0FBQ0wsaUJBQWlCRSxrQkFBa0JULE1BQU1LLE1BQU07SUFFaEYsWUFBWTtJQUNaLElBQUlTLGNBQWM7SUFDbEIsSUFBSUMsYUFBYTtJQUNqQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWhCLE1BQU1LLE1BQU0sRUFBRVcsSUFBSztRQUNyQyxJQUFLLElBQUlDLElBQUlELElBQUksR0FBR0MsSUFBSWpCLE1BQU1LLE1BQU0sRUFBRVksSUFBSztZQUN6Q0Y7WUFDQSxJQUFJ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QUFJLENBQUM3RixDQUFBQSxJQUFLQSxFQUFFTCxFQUFFLEtBQUtFLE1BQU1xRixPQUFPLENBQUNwRSxFQUFFLENBQUNuQixFQUFFO2dCQUVyRSxJQUFJSixNQUFNQyxJQUFJO29CQUNaLElBQUksQ0FBQ0QsR0FBR0UsU0FBUyxDQUFFQyxRQUFRLENBQUNGLEdBQUdHLEVBQUUsR0FBRzt3QkFDbENKLEdBQUdFLFNBQVMsQ0FBRW9ELElBQUksQ0FBQ3JELEdBQUdHLEVBQUU7b0JBQzFCO29CQUNBLElBQUksQ0FBQ0gsR0FBR0MsU0FBUyxDQUFFQyxRQUFRLENBQUNILEdBQUdJLEVBQUUsR0FBRzt3QkFDbENILEdBQUdDLFNBQVMsQ0FBRW9ELElBQUksQ0FBQ3RELEdBQUdJLEVBQUU7b0JBQzFCO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBT2dHO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kb2h5ZW9uYW4vc2lkZVByb2plY3RzL3NvY2lhbGluZ1NlYXRBc3NpZ25lci9zcmMvdXRpbHMvZ3JvdXBpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBQYXJ0aWNpcGFudCB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGdlbmRlcjogJ21hbGUnIHwgJ2ZlbWFsZSdcbiAgbWJ0aTogJ2V4dHJvdmVydCcgfCAnaW50cm92ZXJ0J1xuICBtZXRQZW9wbGU/OiBzdHJpbmdbXVxuICBncm91cEhpc3Rvcnk/OiBudW1iZXJbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwIHtcbiAgaWQ6IG51bWJlclxuICBtZW1iZXJzOiBQYXJ0aWNpcGFudFtdXG4gIG1hbGVDb3VudDogbnVtYmVyXG4gIGZlbWFsZUNvdW50OiBudW1iZXJcbiAgZXh0cm92ZXJ0Q291bnQ6IG51bWJlclxuICBpbnRyb3ZlcnRDb3VudDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXBpbmdSZXN1bHQge1xuICBncm91cHM6IEdyb3VwW11cbiAgcm91bmQ6IG51bWJlclxuICBzdW1tYXJ5OiB7XG4gICAgdG90YWxHcm91cHM6IG51bWJlclxuICAgIGF2Z0dyb3VwU2l6ZTogbnVtYmVyXG4gICAgZ2VuZGVyQmFsYW5jZVNjb3JlOiBudW1iZXJcbiAgICBtYnRpQmFsYW5jZVNjb3JlOiBudW1iZXJcbiAgICBuZXdNZWV0aW5nc0NvdW50OiBudW1iZXJcbiAgfVxufVxuXG4vLyDrkZAg7LC46rCA7J6Q6rCAIOydtOyghOyXkCDrp4zrgqzripTsp4Ag7ZmV7J24XG5mdW5jdGlvbiBoYXZlTWV0KHAxOiBQYXJ0aWNpcGFudCwgcDI6IFBhcnRpY2lwYW50KTogYm9vbGVhbiB7XG4gIHJldHVybiBwMS5tZXRQZW9wbGU/LmluY2x1ZGVzKHAyLmlkKSB8fCBmYWxzZVxufVxuXG4vLyDqt7jro7nsnZgg6reg7ZiVIOygkOyImCDqs4TsgrAgKOuGkuydhOyImOuhnSDsoovsnYwpXG5mdW5jdGlvbiBjYWxjdWxhdGVHcm91cEJhbGFuY2UoZ3JvdXA6IFBhcnRpY2lwYW50W10pOiBudW1iZXIge1xuICBjb25zdCBtYWxlQ291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgY29uc3QgZmVtYWxlQ291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICBjb25zdCBleHRyb3ZlcnRDb3VudCA9IGdyb3VwLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2V4dHJvdmVydCcpLmxlbmd0aFxuICBjb25zdCBpbnRyb3ZlcnRDb3VudCA9IGdyb3VwLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICBcbiAgLy8g7ISx67OEIOq3oO2YlSDsoJDsiJggKOyasOyEoOyInOychCDrhpLsnYwpXG4gIGNvbnN0IGdlbmRlckJhbGFuY2UgPSAxIC0gTWF0aC5hYnMobWFsZUNvdW50IC0gZmVtYWxlQ291bnQpIC8gZ3JvdXAubGVuZ3RoXG4gIFxuICAvLyBNQlRJIOq3oO2YlSDsoJDsiJggKOyasOyEoOyInOychCDrgq7snYwpXG4gIGNvbnN0IG1idGlCYWxhbmNlID0gMSAtIE1hdGguYWJzKGV4dHJvdmVydENvdW50IC0gaW50cm92ZXJ0Q291bnQpIC8gZ3JvdXAubGVuZ3RoXG4gIFxuICAvLyDsg4jroZzsmrQg66eM64KoIOygkOyImFxuICBsZXQgbmV3TWVldGluZ3MgPSAwXG4gIGxldCB0b3RhbFBhaXJzID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ3JvdXAubGVuZ3RoOyBqKyspIHtcbiAgICAgIHRvdGFsUGFpcnMrK1xuICAgICAgaWYgKCFoYXZlTWV0KGdyb3VwW2ldLCBncm91cFtqXSkpIHtcbiAgICAgICAgbmV3TWVldGluZ3MrK1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBuZXdNZWV0aW5nU2NvcmUgPSB0b3RhbFBhaXJzID4gMCA/IG5ld01lZXRpbmdzIC8gdG90YWxQYWlycyA6IDFcbiAgXG4gIC8vIOqwgOykkSDtj4nqt6AgKOyEseuzhCDqt6DtmJUgNzAlLCDsg4jroZzsmrQg66eM64KoIDI1JSwgTUJUSSDqt6DtmJUgNSUpXG4gIHJldHVybiBnZW5kZXJCYWxhbmNlICogMC43ICsgbmV3TWVldGluZ1Njb3JlICogMC4yNSArIG1idGlCYWxhbmNlICogMC4wNVxufVxuXG4vLyDssLjqsIDsnpDqsIAg7J207KCEIOudvOyatOuTnOyZgCDri6Trpbgg6re466O5IOuyiO2YuOulvCDqsIDsoLjslbwg7ZWY64qU7KeAIO2ZleyduFxuZnVuY3Rpb24gc2hvdWxkQXZvaWRHcm91cE51bWJlcihwYXJ0aWNpcGFudDogUGFydGljaXBhbnQsIGdyb3VwTnVtYmVyOiBudW1iZXIpOiBib29sZWFuIHtcbiAgY29uc3QgaGlzdG9yeSA9IHBhcnRpY2lwYW50Lmdyb3VwSGlzdG9yeSB8fCBbXVxuICByZXR1cm4gaGlzdG9yeS5sZW5ndGggPiAwICYmIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXSA9PT0gZ3JvdXBOdW1iZXJcbn1cblxuLy8g7Jyg7KCEIOyVjOqzoOumrOymmOydhCDsgqzsmqntlZwg6re466O5IOuwsOy5mFxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9wdGltYWxHcm91cHMoXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRbXSwgXG4gIGdyb3VwU2l6ZTogbnVtYmVyID0gNCxcbiAgY3VycmVudFJvdW5kOiBudW1iZXIgPSAxXG4pOiBHcm91cGluZ1Jlc3VsdCB7XG4gIGlmIChwYXJ0aWNpcGFudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcign7LWc7IaMIDLrqoUg7J207IOB7J2YIOywuOqwgOyekOqwgCDtlYTsmpTtlanri4jri6QuJylcbiAgfVxuXG4gIGNvbnN0IG51bUdyb3VwcyA9IE1hdGguY2VpbChwYXJ0aWNpcGFudHMubGVuZ3RoIC8gZ3JvdXBTaXplKVxuICBjb25zdCBwb3B1bGF0aW9uU2l6ZSA9IDEwMFxuICBjb25zdCBnZW5lcmF0aW9ucyA9IDIwMFxuICBjb25zdCBtdXRhdGlvblJhdGUgPSAwLjFcblxuICAvLyDqsJzssrQg7IOd7ISxICjqt7jro7kg67Cw7LmYIOuwqeyLnSlcbiAgZnVuY3Rpb24gY3JlYXRlSW5kaXZpZHVhbCgpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgaW5kaXZpZHVhbCA9IG5ldyBBcnJheShwYXJ0aWNpcGFudHMubGVuZ3RoKVxuICAgIGNvbnN0IGdyb3VwU2l6ZXMgPSBuZXcgQXJyYXkobnVtR3JvdXBzKS5maWxsKDApXG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNpcGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBncm91cEluZGV4XG4gICAgICBsZXQgYXR0ZW1wdHMgPSAwXG4gICAgICBcbiAgICAgIGRvIHtcbiAgICAgICAgZ3JvdXBJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG51bUdyb3VwcylcbiAgICAgICAgYXR0ZW1wdHMrK1xuICAgICAgfSB3aGlsZSAoXG4gICAgICAgIGF0dGVtcHRzIDwgMTAgJiYgKFxuICAgICAgICAgIGdyb3VwU2l6ZXNbZ3JvdXBJbmRleF0gPj0gZ3JvdXBTaXplIHx8IFxuICAgICAgICAgIHNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnRzW2ldLCBncm91cEluZGV4ICsgMSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgXG4gICAgICBpbmRpdmlkdWFsW2ldID0gZ3JvdXBJbmRleFxuICAgICAgZ3JvdXBTaXplc1tncm91cEluZGV4XSsrXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpbmRpdmlkdWFsXG4gIH1cblxuICAvLyDsoIHtlanrj4Qg6rOE7IKwXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUZpdG5lc3MoaW5kaXZpZHVhbDogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGNvbnN0IGdyb3VwczogUGFydGljaXBhbnRbXVtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtR3JvdXBzIH0sICgpID0+IFtdKVxuICAgIFxuICAgIGluZGl2aWR1YWwuZm9yRWFjaCgoZ3JvdXBJbmRleCwgcGFydGljaXBhbnRJbmRleCkgPT4ge1xuICAgICAgZ3JvdXBzW2dyb3VwSW5kZXhdLnB1c2gocGFydGljaXBhbnRzW3BhcnRpY2lwYW50SW5kZXhdKVxuICAgIH0pXG4gICAgXG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwXG4gICAgbGV0IHZhbGlkR3JvdXBzID0gMFxuICAgIFxuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZ3JvdXBzKSB7XG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgICB0b3RhbFNjb3JlICs9IGNhbGN1bGF0ZUdyb3VwQmFsYW5jZShncm91cClcbiAgICAgICAgdmFsaWRHcm91cHMrK1xuICAgICAgICBcbiAgICAgICAgLy8g6re466O5IOuyiO2YuCDtmoztlLwg67O064SI7IqkXG4gICAgICAgIGZvciAoY29uc3QgcGFydGljaXBhbnQgb2YgZ3JvdXApIHtcbiAgICAgICAgICBjb25zdCBncm91cE51bWJlciA9IGdyb3Vwcy5pbmRleE9mKGdyb3VwKSArIDFcbiAgICAgICAgICBpZiAoIXNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQsIGdyb3VwTnVtYmVyKSkge1xuICAgICAgICAgICAgdG90YWxTY29yZSArPSAwLjFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHZhbGlkR3JvdXBzID4gMCA/IHRvdGFsU2NvcmUgLyB2YWxpZEdyb3VwcyA6IDBcbiAgfVxuXG4gIC8vIOq1kOywqFxuICBmdW5jdGlvbiBjcm9zc292ZXIocGFyZW50MTogbnVtYmVyW10sIHBhcmVudDI6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGNoaWxkID0gbmV3IEFycmF5KHBhcnRpY2lwYW50cy5sZW5ndGgpXG4gICAgY29uc3QgY3Jvc3NvdmVyUG9pbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYXJ0aWNpcGFudHMubGVuZ3RoKVxuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljaXBhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZFtpXSA9IGkgPCBjcm9zc292ZXJQb2ludCA/IHBhcmVudDFbaV0gOiBwYXJlbnQyW2ldXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjaGlsZFxuICB9XG5cbiAgLy8g64+M7Jew67OA7J20XG4gIGZ1bmN0aW9uIG11dGF0ZShpbmRpdmlkdWFsOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICBjb25zdCBtdXRhdGVkID0gWy4uLmluZGl2aWR1YWxdXG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IG11dGF0aW9uUmF0ZSkge1xuICAgICAgICBsZXQgbmV3R3JvdXBcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMFxuICAgICAgICBcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5ld0dyb3VwID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbnVtR3JvdXBzKVxuICAgICAgICAgIGF0dGVtcHRzKytcbiAgICAgICAgfSB3aGlsZSAoXG4gICAgICAgICAgYXR0ZW1wdHMgPCA1ICYmXG4gICAgICAgICAgc2hvdWxkQXZvaWRHcm91cE51bWJlcihwYXJ0aWNpcGFudHNbaV0sIG5ld0dyb3VwICsgMSlcbiAgICAgICAgKVxuICAgICAgICBcbiAgICAgICAgbXV0YXRlZFtpXSA9IG5ld0dyb3VwXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBtdXRhdGVkXG4gIH1cblxuICAvLyDsnKDsoIQg7JWM6rOg66as7KaYIOyLpO2WiVxuICBsZXQgcG9wdWxhdGlvbiA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHBvcHVsYXRpb25TaXplIH0sICgpID0+IGNyZWF0ZUluZGl2aWR1YWwoKSlcbiAgXG4gIGZvciAobGV0IGdlbmVyYXRpb24gPSAwOyBnZW5lcmF0aW9uIDwgZ2VuZXJhdGlvbnM7IGdlbmVyYXRpb24rKykge1xuICAgIC8vIOygge2VqeuPhCDqs4TsgrAg67CPIOygleugrFxuICAgIGNvbnN0IGZpdG5lc3NTY29yZXMgPSBwb3B1bGF0aW9uLm1hcChjYWxjdWxhdGVGaXRuZXNzKVxuICAgIGNvbnN0IHNvcnRlZEluZGljZXMgPSBmaXRuZXNzU2NvcmVzXG4gICAgICAubWFwKChmaXRuZXNzLCBpbmRleCkgPT4gKHsgZml0bmVzcywgaW5kZXggfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5maXRuZXNzIC0gYS5maXRuZXNzKVxuICAgIFxuICAgIC8vIOyXmOumrO2KuCDshKDtg50gKOyDgeychCAyMCUpXG4gICAgY29uc3QgZWxpdGVTaXplID0gTWF0aC5mbG9vcihwb3B1bGF0aW9uU2l6ZSAqIDAuMilcbiAgICBjb25zdCBuZXdQb3B1bGF0aW9uID0gc29ydGVkSW5kaWNlc1xuICAgICAgLnNsaWNlKDAsIGVsaXRlU2l6ZSlcbiAgICAgIC5tYXAoaXRlbSA9PiBwb3B1bGF0aW9uW2l0ZW0uaW5kZXhdKVxuICAgIFxuICAgIC8vIOuCmOuouOyngOuKlCDqtZDssKjsmYAg64+M7Jew67OA7J2066GcIOyDneyEsVxuICAgIHdoaWxlIChuZXdQb3B1bGF0aW9uLmxlbmd0aCA8IHBvcHVsYXRpb25TaXplKSB7XG4gICAgICBjb25zdCBwYXJlbnQxSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBlbGl0ZVNpemUpXG4gICAgICBjb25zdCBwYXJlbnQySW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBlbGl0ZVNpemUpXG4gICAgICBcbiAgICAgIGNvbnN0IHBhcmVudDEgPSBuZXdQb3B1bGF0aW9uW3BhcmVudDFJbmRleF1cbiAgICAgIGNvbnN0IHBhcmVudDIgPSBuZXdQb3B1bGF0aW9uW3BhcmVudDJJbmRleF1cbiAgICAgIFxuICAgICAgbGV0IGNoaWxkID0gY3Jvc3NvdmVyKHBhcmVudDEsIHBhcmVudDIpXG4gICAgICBjaGlsZCA9IG11dGF0ZShjaGlsZClcbiAgICAgIFxuICAgICAgbmV3UG9wdWxhdGlvbi5wdXNoKGNoaWxkKVxuICAgIH1cbiAgICBcbiAgICBwb3B1bGF0aW9uID0gbmV3UG9wdWxhdGlvblxuICB9XG5cbiAgLy8g7LWc7KCBIO2VtCDshKDtg51cbiAgY29uc3QgZml0bmVzc1Njb3JlcyA9IHBvcHVsYXRpb24ubWFwKGNhbGN1bGF0ZUZpdG5lc3MpXG4gIGNvbnN0IGJlc3RJbmRleCA9IGZpdG5lc3NTY29yZXMuaW5kZXhPZihNYXRoLm1heCguLi5maXRuZXNzU2NvcmVzKSlcbiAgY29uc3QgYmVzdFNvbHV0aW9uID0gcG9wdWxhdGlvbltiZXN0SW5kZXhdXG5cbiAgLy8g6rKw6rO8IOq1rOyEsVxuICBjb25zdCBmaW5hbEdyb3VwczogR3JvdXBbXSA9IFtdXG4gIGNvbnN0IGdyb3VwQXJyYXlzOiBQYXJ0aWNpcGFudFtdW10gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBudW1Hcm91cHMgfSwgKCkgPT4gW10pXG4gIFxuICBiZXN0U29sdXRpb24uZm9yRWFjaCgoZ3JvdXBJbmRleCwgcGFydGljaXBhbnRJbmRleCkgPT4ge1xuICAgIGdyb3VwQXJyYXlzW2dyb3VwSW5kZXhdLnB1c2gocGFydGljaXBhbnRzW3BhcnRpY2lwYW50SW5kZXhdKVxuICB9KVxuICBcbiAgbGV0IG5ld01lZXRpbmdzVG90YWwgPSAwXG4gIGxldCB0b3RhbEdlbmRlckJhbGFuY2UgPSAwXG4gIGxldCB0b3RhbE1idGlCYWxhbmNlID0gMFxuICBcbiAgZ3JvdXBBcnJheXMuZm9yRWFjaCgoZ3JvdXBNZW1iZXJzLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICBjb25zdCBmZW1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgIGNvbnN0IGV4dHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2V4dHJvdmVydCcpLmxlbmd0aFxuICAgIGNvbnN0IGludHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICAgIFxuICAgIC8vIOyDiOuhnOyatCDrp4zrgqgg6rOE7IKwICjruYgg6re466O57J20IOyVhOuLkCDrlYzrp4wpXG4gICAgaWYgKGdyb3VwTWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwTWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBncm91cE1lbWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoIWhhdmVNZXQoZ3JvdXBNZW1iZXJzW2ldLCBncm91cE1lbWJlcnNbal0pKSB7XG4gICAgICAgICAgICBuZXdNZWV0aW5nc1RvdGFsKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdG90YWxHZW5kZXJCYWxhbmNlICs9IDEgLSBNYXRoLmFicyhtYWxlQ291bnQgLSBmZW1hbGVDb3VudCkgLyBncm91cE1lbWJlcnMubGVuZ3RoXG4gICAgICB0b3RhbE1idGlCYWxhbmNlICs9IDEgLSBNYXRoLmFicyhleHRyb3ZlcnRDb3VudCAtIGludHJvdmVydENvdW50KSAvIGdyb3VwTWVtYmVycy5sZW5ndGhcbiAgICB9XG4gICAgXG4gICAgLy8g66qo65OgIOq3uOujueydhCDtj6ztlaggKOu5iCDqt7jro7nrj4Qg7Y+s7ZWoKVxuICAgIGZpbmFsR3JvdXBzLnB1c2goe1xuICAgICAgaWQ6IGluZGV4ICsgMSxcbiAgICAgIG1lbWJlcnM6IGdyb3VwTWVtYmVycyxcbiAgICAgIG1hbGVDb3VudCxcbiAgICAgIGZlbWFsZUNvdW50LFxuICAgICAgZXh0cm92ZXJ0Q291bnQsXG4gICAgICBpbnRyb3ZlcnRDb3VudFxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBncm91cHM6IGZpbmFsR3JvdXBzLFxuICAgIHJvdW5kOiBjdXJyZW50Um91bmQsXG4gICAgc3VtbWFyeToge1xuICAgICAgdG90YWxHcm91cHM6IGZpbmFsR3JvdXBzLmxlbmd0aCxcbiAgICAgIGF2Z0dyb3VwU2l6ZTogcGFydGljaXBhbnRzLmxlbmd0aCAvIGZpbmFsR3JvdXBzLmxlbmd0aCxcbiAgICAgIGdlbmRlckJhbGFuY2VTY29yZTogTWF0aC5yb3VuZCgodG90YWxHZW5kZXJCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCksXG4gICAgICBtYnRpQmFsYW5jZVNjb3JlOiBNYXRoLnJvdW5kKCh0b3RhbE1idGlCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCksXG4gICAgICBuZXdNZWV0aW5nc0NvdW50OiBuZXdNZWV0aW5nc1RvdGFsXG4gICAgfVxuICB9XG59XG5cbi8vIOunjOuCqCDtnojsiqTthqDrpqwg7JeF642w7J207Yq4XG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWVldGluZ0hpc3RvcnkoXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRbXSwgXG4gIGdyb3VwczogR3JvdXBbXSwgXG4gIHJvdW5kOiBudW1iZXJcbik6IFBhcnRpY2lwYW50W10ge1xuICBjb25zdCB1cGRhdGVkUGFydGljaXBhbnRzID0gcGFydGljaXBhbnRzLm1hcChwID0+ICh7XG4gICAgLi4ucCxcbiAgICBtZXRQZW9wbGU6IFsuLi4ocC5tZXRQZW9wbGUgfHwgW10pXSxcbiAgICBncm91cEhpc3Rvcnk6IFsuLi4ocC5ncm91cEhpc3RvcnkgfHwgW10pXVxuICB9KSlcblxuICAvLyDqsIEg6re466O5IOuCtCDssLjqsIDsnpDrk6TsnZgg66eM64KoIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgZ3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgIC8vIOq3uOujuSDrsojtmLgg7Z6I7Iqk7Yag66asIOyXheuNsOydtO2KuFxuICAgIGdyb3VwLm1lbWJlcnMuZm9yRWFjaChtZW1iZXIgPT4ge1xuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBtZW1iZXIuaWQpXG4gICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgcGFydGljaXBhbnQuZ3JvdXBIaXN0b3J5IS5wdXNoKGdyb3VwLmlkKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyDshJzroZwg66eM64KcIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgcDEgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBncm91cC5tZW1iZXJzW2ldLmlkKVxuICAgICAgICBjb25zdCBwMiA9IHVwZGF0ZWRQYXJ0aWNpcGFudHMuZmluZChwID0+IHAuaWQgPT09IGdyb3VwLm1lbWJlcnNbal0uaWQpXG4gICAgICAgIFxuICAgICAgICBpZiAocDEgJiYgcDIpIHtcbiAgICAgICAgICBpZiAoIXAxLm1ldFBlb3BsZSEuaW5jbHVkZXMocDIuaWQpKSB7XG4gICAgICAgICAgICBwMS5tZXRQZW9wbGUhLnB1c2gocDIuaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcDIubWV0UGVvcGxlIS5pbmNsdWRlcyhwMS5pZCkpIHtcbiAgICAgICAgICAgIHAyLm1ldFBlb3BsZSEucHVzaChwMS5pZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRQYXJ0aWNpcGFudHNcbn0iXSwibmFtZXMiOlsiaGF2ZU1ldCIsInAxIiwicDIiLCJtZXRQZW9wbGUiLCJpbmNsdWRlcyIsImlkIiwiY2FsY3VsYXRlR3JvdXBCYWxhbmNlIiwiZ3JvdXAiLCJtYWxlQ291bnQiLCJmaWx0ZXIiLCJwIiwiZ2VuZGVyIiwibGVuZ3RoIiwiZmVtYWxlQ291bnQiLCJleHRyb3ZlcnRDb3VudCIsIm1idGkiLCJpbnRyb3ZlcnRDb3VudCIsImdlbmRlckJhbGFuY2UiLCJNYXRoIiwiYWJzIiwibWJ0aUJhbGFuY2UiLCJuZXdNZWV0aW5ncyIsInRvdGFsUGFpcnMiLCJpIiwiaiIsIm5ld01lZXRpbmdTY29yZSIsInNob3VsZEF2b2lkR3JvdXBOdW1iZXIiLCJwYXJ0aWNpcGFudCIsImdyb3VwTnVtYmVyIiwiaGlzdG9yeSIsImdyb3VwSGlzdG9yeSIsImNyZWF0ZU9wdGltYWxHcm91cHMiLCJwYXJ0aWNpcGFudHMiLCJncm91cFNpemUiLCJjdXJyZW50Um91bmQiLCJFcnJvciIsIm51bUdyb3VwcyIsImNlaWwiLCJwb3B1bGF0aW9uU2l6ZSIsImdlbmVyYXRpb25zIiwibXV0YXRpb25SYXRlIiwiY3JlYXRlSW5kaXZpZHVhbCIsImluZGl2aWR1YWwiLCJBcnJheSIsImdyb3VwU2l6ZXMiLCJmaWxsIiwiZ3JvdXBJbmRleCIsImF0dGVtcHRzIiwiZmxvb3IiLCJyYW5kb20iLCJjYWxjdWxhdGVGaXRuZXNzIiwiZ3JvdXBzIiwiZnJvbSIsImZvckVhY2giLCJwYXJ0aWNpcGFudEluZGV4IiwicHVzaCIsInRvdGFsU2NvcmUiLCJ2YWxpZEdyb3VwcyIsImluZGV4T2YiLCJjcm9zc292ZXIiLCJwYXJlbnQxIiwicGFyZW50MiIsImNoaWxkIiwiY3Jvc3NvdmVyUG9pbnQiLCJtdXRhdGUiLCJtdXRhdGVkIiwibmV3R3JvdXAiLCJwb3B1bGF0aW9uIiwiZ2VuZXJhdGlvbiIsImZpdG5lc3NTY29yZXMiLCJtYXAiLCJzb3J0ZWRJbmRpY2VzIiwiZml0bmVzcyIsImluZGV4Iiwic29ydCIsImEiLCJiIiwiZWxpdGVTaXplIiwibmV3UG9wdWxhdGlvbiIsInNsaWNlIiwiaXRlbSIsInBhcmVudDFJbmRleCIsInBhcmVudDJJbmRleCIsImJlc3RJbmRleCIsIm1heCIsImJlc3RTb2x1dGlvbiIsImZpbmFsR3JvdXBzIiwiZ3JvdXBBcnJheXMiLCJuZXdNZWV0aW5nc1RvdGFsIiwidG90YWxHZW5kZXJCYWxhbmNlIiwidG90YWxNYnRpQmFsYW5jZSIsImdyb3VwTWVtYmVycyIsIm1lbWJlcnMiLCJyb3VuZCIsInN1bW1hcnkiLCJ0b3RhbEdyb3VwcyIsImF2Z0dyb3VwU2l6ZSIsImdlbmRlckJhbGFuY2VTY29yZSIsIm1idGlCYWxhbmNlU2NvcmUiLCJuZXdNZWV0aW5nc0NvdW50IiwidXBkYXRlTWVldGluZ0hpc3RvcnkiLCJ1cGRhdGVkUGFydGljaXBhbnRzIiwibWVtYmVyIiwiZmluZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/grouping.ts\n"));

/***/ })

});