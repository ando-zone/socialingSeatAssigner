"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/grouping.ts":
/*!*******************************!*\
  !*** ./src/utils/grouping.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOptimalGroups: () => (/* binding */ createOptimalGroups),\n/* harmony export */   updateMeetingHistory: () => (/* binding */ updateMeetingHistory)\n/* harmony export */ });\n// 두 참가자가 이전에 만났는지 확인\nfunction haveMet(p1, p2) {\n    var _p1_metPeople;\n    return ((_p1_metPeople = p1.metPeople) === null || _p1_metPeople === void 0 ? void 0 : _p1_metPeople.includes(p2.id)) || false;\n}\n// 그룹의 균형 점수 계산 (높을수록 좋음)\nfunction calculateGroupBalance(group) {\n    const maleCount = group.filter((p)=>p.gender === 'male').length;\n    const femaleCount = group.filter((p)=>p.gender === 'female').length;\n    const extrovertCount = group.filter((p)=>p.mbti === 'extrovert').length;\n    const introvertCount = group.filter((p)=>p.mbti === 'introvert').length;\n    // 성별 균형 점수 (우선순위 높음)\n    const genderBalance = 1 - Math.abs(maleCount - femaleCount) / group.length;\n    // MBTI 균형 점수 (우선순위 낮음)\n    const mbtiBalance = 1 - Math.abs(extrovertCount - introvertCount) / group.length;\n    // 새로운 만남 점수\n    let newMeetings = 0;\n    let totalPairs = 0;\n    for(let i = 0; i < group.length; i++){\n        for(let j = i + 1; j < group.length; j++){\n            totalPairs++;\n            if (!haveMet(group[i], group[j])) {\n                newMeetings++;\n            }\n        }\n    }\n    const newMeetingScore = totalPairs > 0 ? newMeetings / totalPairs : 1;\n    // 가중 평균 (성별 균형 70%, 새로운 만남 25%, MBTI 균형 5%)\n    return genderBalance * 0.7 + newMeetingScore * 0.25 + mbtiBalance * 0.05;\n}\n// 참가자가 이전 라운드와 다른 그룹 번호를 가져야 하는지 확인\nfunction shouldAvoidGroupNumber(participant, groupNumber) {\n    const history = participant.groupHistory || [];\n    return history.length > 0 && history[history.length - 1] === groupNumber;\n}\n// 간단한 그룹 배치 알고리즘\nfunction createOptimalGroups(participants) {\n    let groupSize1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, currentRound1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    if (participants.length < 2) {\n        throw new Error('최소 2명 이상의 참가자가 필요합니다.');\n    }\n    const numGroups1 = Math.ceil(participants.length / groupSize1);\n    // 간단한 배치 방식으로 변경\n    const groups = Array.from({\n        length: numGroups1\n    }, ()=>[]);\n    // 참가자를 순차적으로 그룹에 배치\n    participants.forEach((participant, index)=>{\n        const groupIndex = index % numGroups1;\n        groups[groupIndex].push(participant);\n    });\n    // 그룹 균형 최적화 (성별 균형 고려)\n    optimizeGroups(groups, participants);\n    // 결과 구성\n    const finalGroups = groups.map((groupMembers, index)=>{\n        const maleCount = groupMembers.filter((p)=>p.gender === 'male').length;\n        const femaleCount = groupMembers.filter((p)=>p.gender === 'female').length;\n        const extrovertCount = groupMembers.filter((p)=>p.mbti === 'extrovert').length;\n        const introvertCount = groupMembers.filter((p)=>p.mbti === 'introvert').length;\n        return {\n            id: index + 1,\n            members: groupMembers,\n            maleCount,\n            femaleCount,\n            extrovertCount,\n            introvertCount\n        };\n    }).filter((group)=>group.members.length > 0) // 빈 그룹 제거\n    ;\n    // 통계 계산\n    let newMeetingsTotal = 0;\n    let totalGenderBalance = 0;\n    let totalMbtiBalance = 0;\n    finalGroups.forEach((group)=>{\n        const groupMembers = group.members;\n        // 새로운 만남 계산\n        for(let i = 0; i < groupMembers.length; i++){\n            for(let j = i + 1; j < groupMembers.length; j++){\n                if (!haveMet(groupMembers[i], groupMembers[j])) {\n                    newMeetingsTotal++;\n                }\n            }\n        }\n        if (groupMembers.length > 0) {\n            totalGenderBalance += 1 - Math.abs(group.maleCount - group.femaleCount) / groupMembers.length;\n            totalMbtiBalance += 1 - Math.abs(group.extrovertCount - group.introvertCount) / groupMembers.length;\n        }\n    });\n    return {\n        groups: finalGroups,\n        round: currentRound1,\n        summary: {\n            totalGroups: finalGroups.length,\n            avgGroupSize: participants.length / finalGroups.length,\n            genderBalanceScore: finalGroups.length > 0 ? Math.round(totalGenderBalance / finalGroups.length * 100) : 0,\n            mbtiBalanceScore: finalGroups.length > 0 ? Math.round(totalMbtiBalance / finalGroups.length * 100) : 0,\n            newMeetingsCount: newMeetingsTotal\n        }\n    };\n}\n// 그룹 최적화 함수\nfunction optimizeGroups(groups, participants) {\n    // 간단한 성별 균형 최적화\n    for(let iterations = 0; iterations < 10; iterations++){\n        let improved = false;\n        for(let i = 0; i < groups.length; i++){\n            for(let j = i + 1; j < groups.length; j++){\n                if (groups[i].length === 0 || groups[j].length === 0) continue;\n                // 성별 균형 개선을 위한 교환 시도\n                const group1 = groups[i];\n                const group2 = groups[j];\n                const g1Males = group1.filter((p)=>p.gender === 'male').length;\n                const g1Females = group1.filter((p)=>p.gender === 'female').length;\n                const g2Males = group2.filter((p)=>p.gender === 'male').length;\n                const g2Females = group2.filter((p)=>p.gender === 'female').length;\n                // 불균형한 그룹들 간 교환\n                if (Math.abs(g1Males - g1Females) > 1 || Math.abs(g2Males - g2Females) > 1) {\n                    for(let p1 = 0; p1 < group1.length; p1++){\n                        for(let p2 = 0; p2 < group2.length; p2++){\n                            if (group1[p1].gender !== group2[p2].gender) {\n                                // 교환해보기\n                                const temp = group1[p1];\n                                group1[p1] = group2[p2];\n                                group2[p2] = temp;\n                                const newG1Males = group1.filter((p)=>p.gender === 'male').length;\n                                const newG1Females = group1.filter((p)=>p.gender === 'female').length;\n                                const newG2Males = group2.filter((p)=>p.gender === 'male').length;\n                                const newG2Females = group2.filter((p)=>p.gender === 'female').length;\n                                const oldImbalance = Math.abs(g1Males - g1Females) + Math.abs(g2Males - g2Females);\n                                const newImbalance = Math.abs(newG1Males - newG1Females) + Math.abs(newG2Males - newG2Females);\n                                if (newImbalance < oldImbalance) {\n                                    improved = true;\n                                    break;\n                                } else {\n                                    // 되돌리기\n                                    const temp2 = group1[p1];\n                                    group1[p1] = group2[p2];\n                                    group2[p2] = temp2;\n                                }\n                            }\n                        }\n                        if (improved) break;\n                    }\n                }\n                if (improved) break;\n            }\n            if (improved) break;\n        }\n        if (!improved) break;\n    }\n    // 개체 생성 (그룹 배치 방식)\n    function createIndividual() {\n        const individual = new Array(participants.length);\n        const groupSizes = new Array(numGroups).fill(0);\n        // 먼저 모든 참가자를 순차적으로 배치\n        for(let i = 0; i < participants.length; i++){\n            let groupIndex = i % numGroups // 순차 배치로 시작\n            ;\n            let attempts = 0;\n            // 그룹 크기 제한과 그룹 번호 회피를 고려한 재배치\n            while(attempts < 20){\n                if (groupSizes[groupIndex] < groupSize && !shouldAvoidGroupNumber(participants[i], groupIndex + 1)) {\n                    break;\n                }\n                groupIndex = Math.floor(Math.random() * numGroups);\n                attempts++;\n            }\n            // 최종적으로 조건을 만족하지 못하면 가장 적은 그룹에 배치\n            if (attempts >= 20) {\n                groupIndex = groupSizes.indexOf(Math.min(...groupSizes));\n            }\n            individual[i] = groupIndex;\n            groupSizes[groupIndex]++;\n        }\n        return individual;\n    }\n    // 적합도 계산\n    function calculateFitness(individual) {\n        const groups = Array.from({\n            length: numGroups\n        }, ()=>[]);\n        individual.forEach((groupIndex, participantIndex)=>{\n            groups[groupIndex].push(participants[participantIndex]);\n        });\n        let totalScore = 0;\n        let validGroups = 0;\n        for (const group of groups){\n            if (group.length > 0) {\n                totalScore += calculateGroupBalance(group);\n                validGroups++;\n                // 그룹 번호 회피 보너스\n                for (const participant of group){\n                    const groupNumber = groups.indexOf(group) + 1;\n                    if (!shouldAvoidGroupNumber(participant, groupNumber)) {\n                        totalScore += 0.1;\n                    }\n                }\n            }\n        }\n        return validGroups > 0 ? totalScore / validGroups : 0;\n    }\n    // 교차\n    function crossover(parent1, parent2) {\n        const child = new Array(participants.length);\n        const crossoverPoint = Math.floor(Math.random() * participants.length);\n        for(let i = 0; i < participants.length; i++){\n            child[i] = i < crossoverPoint ? parent1[i] : parent2[i];\n        }\n        return child;\n    }\n    // 돌연변이\n    function mutate(individual) {\n        const mutated = [\n            ...individual\n        ];\n        for(let i = 0; i < mutated.length; i++){\n            if (Math.random() < mutationRate) {\n                let newGroup;\n                let attempts = 0;\n                do {\n                    newGroup = Math.floor(Math.random() * numGroups);\n                    attempts++;\n                }while (attempts < 5 && shouldAvoidGroupNumber(participants[i], newGroup + 1));\n                mutated[i] = newGroup;\n            }\n        }\n        return mutated;\n    }\n    // 유전 알고리즘 실행\n    let population = Array.from({\n        length: populationSize\n    }, ()=>createIndividual());\n    for(let generation = 0; generation < generations; generation++){\n        // 적합도 계산 및 정렬\n        const fitnessScores = population.map(calculateFitness);\n        const sortedIndices = fitnessScores.map((fitness, index)=>({\n                fitness,\n                index\n            })).sort((a, b)=>b.fitness - a.fitness);\n        // 엘리트 선택 (상위 20%)\n        const eliteSize = Math.floor(populationSize * 0.2);\n        const newPopulation = sortedIndices.slice(0, eliteSize).map((item)=>population[item.index]);\n        // 나머지는 교차와 돌연변이로 생성\n        while(newPopulation.length < populationSize){\n            const parent1Index = Math.floor(Math.random() * eliteSize);\n            const parent2Index = Math.floor(Math.random() * eliteSize);\n            const parent1 = newPopulation[parent1Index];\n            const parent2 = newPopulation[parent2Index];\n            let child = crossover(parent1, parent2);\n            child = mutate(child);\n            newPopulation.push(child);\n        }\n        population = newPopulation;\n    }\n    // 최적 해 선택\n    const fitnessScores = population.map(calculateFitness);\n    const bestIndex = fitnessScores.indexOf(Math.max(...fitnessScores));\n    const bestSolution = population[bestIndex];\n    // 결과 구성\n    const finalGroups = [];\n    const groupArrays = Array.from({\n        length: numGroups\n    }, ()=>[]);\n    bestSolution.forEach((groupIndex, participantIndex)=>{\n        groupArrays[groupIndex].push(participants[participantIndex]);\n    });\n    let newMeetingsTotal = 0;\n    let totalGenderBalance = 0;\n    let totalMbtiBalance = 0;\n    groupArrays.forEach((groupMembers, index)=>{\n        const maleCount = groupMembers.filter((p)=>p.gender === 'male').length;\n        const femaleCount = groupMembers.filter((p)=>p.gender === 'female').length;\n        const extrovertCount = groupMembers.filter((p)=>p.mbti === 'extrovert').length;\n        const introvertCount = groupMembers.filter((p)=>p.mbti === 'introvert').length;\n        // 새로운 만남 계산 (빈 그룹이 아닐 때만)\n        if (groupMembers.length > 0) {\n            for(let i = 0; i < groupMembers.length; i++){\n                for(let j = i + 1; j < groupMembers.length; j++){\n                    if (!haveMet(groupMembers[i], groupMembers[j])) {\n                        newMeetingsTotal++;\n                    }\n                }\n            }\n            totalGenderBalance += 1 - Math.abs(maleCount - femaleCount) / groupMembers.length;\n            totalMbtiBalance += 1 - Math.abs(extrovertCount - introvertCount) / groupMembers.length;\n        }\n        // 모든 그룹을 포함 (빈 그룹도 포함)\n        finalGroups.push({\n            id: index + 1,\n            members: groupMembers,\n            maleCount,\n            femaleCount,\n            extrovertCount,\n            introvertCount\n        });\n    });\n    return {\n        groups: finalGroups,\n        round: currentRound,\n        summary: {\n            totalGroups: finalGroups.length,\n            avgGroupSize: participants.length / finalGroups.length,\n            genderBalanceScore: Math.round(totalGenderBalance / finalGroups.length * 100),\n            mbtiBalanceScore: Math.round(totalMbtiBalance / finalGroups.length * 100),\n            newMeetingsCount: newMeetingsTotal\n        }\n    };\n}\n// 만남 히스토리 업데이트\nfunction updateMeetingHistory(participants, groups, round) {\n    const updatedParticipants = participants.map((p)=>({\n            ...p,\n            metPeople: [\n                ...p.metPeople || []\n            ],\n            groupHistory: [\n                ...p.groupHistory || []\n            ]\n        }));\n    // 각 그룹 내 참가자들의 만남 기록 업데이트\n    groups.forEach((group)=>{\n        // 그룹 번호 히스토리 업데이트\n        group.members.forEach((member)=>{\n            const participant = updatedParticipants.find((p)=>p.id === member.id);\n            if (participant) {\n                participant.groupHistory.push(group.id);\n            }\n        });\n        // 서로 만난 기록 업데이트\n        for(let i = 0; i < group.members.length; i++){\n            for(let j = i + 1; j < group.members.length; j++){\n                const p1 = updatedParticipants.find((p)=>p.id === group.members[i].id);\n                const p2 = updatedParticipants.find((p)=>p.id === group.members[j].id);\n                if (p1 && p2) {\n                    if (!p1.metPeople.includes(p2.id)) {\n                        p1.metPeople.push(p2.id);\n                    }\n                    if (!p2.metPeople.includes(p1.id)) {\n                        p2.metPeople.push(p1.id);\n                    }\n                }\n            }\n        }\n    });\n    return updatedParticipants;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ncm91cGluZy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQThCQSxxQkFBcUI7QUFDckIsU0FBU0EsUUFBUUMsRUFBZSxFQUFFQyxFQUFlO1FBQ3hDRDtJQUFQLE9BQU9BLEVBQUFBLGdCQUFBQSxHQUFHRSxTQUFTLGNBQVpGLG9DQUFBQSxjQUFjRyxRQUFRLENBQUNGLEdBQUdHLEVBQUUsTUFBSztBQUMxQztBQUVBLHlCQUF5QjtBQUN6QixTQUFTQyxzQkFBc0JDLEtBQW9CO0lBQ2pELE1BQU1DLFlBQVlELE1BQU1FLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTSxLQUFLLFFBQVFDLE1BQU07SUFDL0QsTUFBTUMsY0FBY04sTUFBTUUsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssVUFBVUMsTUFBTTtJQUNuRSxNQUFNRSxpQkFBaUJQLE1BQU1FLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUssSUFBSSxLQUFLLGFBQWFILE1BQU07SUFDdkUsTUFBTUksaUJBQWlCVCxNQUFNRSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVLLElBQUksS0FBSyxhQUFhSCxNQUFNO0lBRXZFLHFCQUFxQjtJQUNyQixNQUFNSyxnQkFBZ0IsSUFBSUMsS0FBS0MsR0FBRyxDQUFDWCxZQUFZSyxlQUFlTixNQUFNSyxNQUFNO0lBRTFFLHVCQUF1QjtJQUN2QixNQUFNUSxjQUFjLElBQUlGLEtBQUtDLEdBQUcsQ0FBQ0wsaUJBQWlCRSxrQkFBa0JULE1BQU1LLE1BQU07SUFFaEYsWUFBWTtJQUNaLElBQUlTLGNBQWM7SUFDbEIsSUFBSUMsYUFBYTtJQUNqQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWhCLE1BQU1LLE1BQU0sRUFBRVcsSUFBSztRQUNyQyxJQUFLLElBQUlDLElBQUlELElBQUksR0FBR0MsSUFBSWpCLE1BQU1LLE1BQU0sRUFBRVksSUFBSztZQUN6Q0Y7WUFDQSxJQUFJLENBQUN0QixRQUFRTyxLQUFLLENBQUNnQixFQUFFLEVBQUVoQixLQUFLLENBQUNpQixFQUFFLEdBQUc7Z0JBQ2hDSDtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE1BQU1JLGtCQUFrQkgsYUFBYSxJQUFJRCxjQUFjQyxhQUFhO0lBRXBFLDRDQUE0QztJQUM1QyxPQUFPTCxnQkFBZ0IsTUFBTVEsa0JBQWtCLE9BQU9MLGNBQWM7QUFDdEU7QUFFQSxvQ0FBb0M7QUFDcEMsU0FBU00sdUJBQXVCQyxXQUF3QixFQUFFQyxXQUFtQjtJQUMzRSxNQUFNQyxVQUFVRixZQUFZRyxZQUFZLElBQUksRUFBRTtJQUM5QyxPQUFPRCxRQUFRakIsTUFBTSxHQUFHLEtBQUtpQixPQUFPLENBQUNBLFFBQVFqQixNQUFNLEdBQUcsRUFBRSxLQUFLZ0I7QUFDL0Q7QUFFQSxpQkFBaUI7QUFDVixTQUFTRyxvQkFDZEMsWUFBMkI7UUFDM0JDLGFBQUFBLGlFQUFvQixHQUNwQkMsZ0JBQUFBLGlFQUF1QjtJQUV2QixJQUFJRixhQUFhcEIsTUFBTSxHQUFHLEdBQUc7UUFDM0IsTUFBTSxJQUFJdUIsTUFBTTtJQUNsQjtJQUVBLE1BQU1DLGFBQVlsQixLQUFLbUIsSUFBSSxDQUFDTCxhQUFhcEIsTUFBTSxHQUFHcUI7SUFFbEQsaUJBQWlCO0lBQ2pCLE1BQU1LLFNBQTBCQyxNQUFNQyxJQUFJLENBQUM7UUFBRTVCLFFBQVF3QjtJQUFVLEdBQUcsSUFBTSxFQUFFO0lBRTFFLG9CQUFvQjtJQUNwQkosYUFBYVMsT0FBTyxDQUFDLENBQUNkLGFBQWFlO1FBQ2pDLE1BQU1DLGFBQWFELFFBQVFOO1FBQzNCRSxNQUFNLENBQUNLLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDakI7SUFDMUI7SUFFQSx1QkFBdUI7SUFDdkJrQixlQUFlUCxRQUFRTjtJQUV2QixRQUFRO0lBQ1IsTUFBTWMsY0FBdUJSLE9BQU9TLEdBQUcsQ0FBQyxDQUFDQyxjQUFjTjtRQUNyRCxNQUFNbEMsWUFBWXdDLGFBQWF2QyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxRQUFRQyxNQUFNO1FBQ3RFLE1BQU1DLGNBQWNtQyxhQUFhdkMsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssVUFBVUMsTUFBTTtRQUMxRSxNQUFNRSxpQkFBaUJrQyxhQUFhdkMsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFSyxJQUFJLEtBQUssYUFBYUgsTUFBTTtRQUM5RSxNQUFNSSxpQkFBaUJnQyxhQUFhdkMsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFSyxJQUFJLEtBQUssYUFBYUgsTUFBTTtRQUU5RSxPQUFPO1lBQ0xQLElBQUlxQyxRQUFRO1lBQ1pPLFNBQVNEO1lBQ1R4QztZQUNBSztZQUNBQztZQUNBRTtRQUNGO0lBQ0YsR0FBR1AsTUFBTSxDQUFDRixDQUFBQSxRQUFTQSxNQUFNMEMsT0FBTyxDQUFDckMsTUFBTSxHQUFHLEdBQUcsVUFBVTs7SUFFdkQsUUFBUTtJQUNSLElBQUlzQyxtQkFBbUI7SUFDdkIsSUFBSUMscUJBQXFCO0lBQ3pCLElBQUlDLG1CQUFtQjtJQUV2Qk4sWUFBWUwsT0FBTyxDQUFDbEMsQ0FBQUE7UUFDbEIsTUFBTXlDLGVBQWV6QyxNQUFNMEMsT0FBTztRQUVsQyxZQUFZO1FBQ1osSUFBSyxJQUFJMUIsSUFBSSxHQUFHQSxJQUFJeUIsYUFBYXBDLE1BQU0sRUFBRVcsSUFBSztZQUM1QyxJQUFLLElBQUlDLElBQUlELElBQUksR0FBR0MsSUFBSXdCLGFBQWFwQyxNQUFNLEVBQUVZLElBQUs7Z0JBQ2hELElBQUksQ0FBQ3hCLFFBQVFnRCxZQUFZLENBQUN6QixFQUFFLEVBQUV5QixZQUFZLENBQUN4QixFQUFFLEdBQUc7b0JBQzlDMEI7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsSUFBSUYsYUFBYXBDLE1BQU0sR0FBRyxHQUFHO1lBQzNCdUMsc0JBQXNCLElBQUlqQyxLQUFLQyxHQUFHLENBQUNaLE1BQU1DLFNBQVMsR0FBR0QsTUFBTU0sV0FBVyxJQUFJbUMsYUFBYXBDLE1BQU07WUFDN0Z3QyxvQkFBb0IsSUFBSWxDLEtBQUtDLEdBQUcsQ0FBQ1osTUFBTU8sY0FBYyxHQUFHUCxNQUFNUyxjQUFjLElBQUlnQyxhQUFhcEMsTUFBTTtRQUNyRztJQUNGO0lBRUEsT0FBTztRQUNMMEIsUUFBUVE7UUFDUk8sT0FBT25CO1FBQ1BvQixTQUFTO1lBQ1BDLGFBQWFULFlBQVlsQyxNQUFNO1lBQy9CNEMsY0FBY3hCLGFBQWFwQixNQUFNLEdBQUdrQyxZQUFZbEMsTUFBTTtZQUN0RDZDLG9CQUFvQlgsWUFBWWxDLE1BQU0sR0FBRyxJQUFJTSxLQUFLbUMsS0FBSyxDQUFDLHFCQUFzQlAsWUFBWWxDLE1BQU0sR0FBSSxPQUFPO1lBQzNHOEMsa0JBQWtCWixZQUFZbEMsTUFBTSxHQUFHLElBQUlNLEtBQUttQyxLQUFLLENBQUMsbUJBQW9CUCxZQUFZbEMsTUFBTSxHQUFJLE9BQU87WUFDdkcrQyxrQkFBa0JUO1FBQ3BCO0lBQ0Y7QUFDRjtBQUVBLFlBQVk7QUFDWixTQUFTTCxlQUFlUCxNQUF1QixFQUFFTixZQUEyQjtJQUMxRSxnQkFBZ0I7SUFDaEIsSUFBSyxJQUFJNEIsYUFBYSxHQUFHQSxhQUFhLElBQUlBLGFBQWM7UUFDdEQsSUFBSUMsV0FBVztRQUVmLElBQUssSUFBSXRDLElBQUksR0FBR0EsSUFBSWUsT0FBTzFCLE1BQU0sRUFBRVcsSUFBSztZQUN0QyxJQUFLLElBQUlDLElBQUlELElBQUksR0FBR0MsSUFBSWMsT0FBTzFCLE1BQU0sRUFBRVksSUFBSztnQkFDMUMsSUFBSWMsTUFBTSxDQUFDZixFQUFFLENBQUNYLE1BQU0sS0FBSyxLQUFLMEIsTUFBTSxDQUFDZCxFQUFFLENBQUNaLE1BQU0sS0FBSyxHQUFHO2dCQUV0RCxxQkFBcUI7Z0JBQ3JCLE1BQU1rRCxTQUFTeEIsTUFBTSxDQUFDZixFQUFFO2dCQUN4QixNQUFNd0MsU0FBU3pCLE1BQU0sQ0FBQ2QsRUFBRTtnQkFFeEIsTUFBTXdDLFVBQVVGLE9BQU9yRCxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxRQUFRQyxNQUFNO2dCQUM5RCxNQUFNcUQsWUFBWUgsT0FBT3JELE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTSxLQUFLLFVBQVVDLE1BQU07Z0JBQ2xFLE1BQU1zRCxVQUFVSCxPQUFPdEQsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssUUFBUUMsTUFBTTtnQkFDOUQsTUFBTXVELFlBQVlKLE9BQU90RCxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxVQUFVQyxNQUFNO2dCQUVsRSxnQkFBZ0I7Z0JBQ2hCLElBQUlNLEtBQUtDLEdBQUcsQ0FBQzZDLFVBQVVDLGFBQWEsS0FBSy9DLEtBQUtDLEdBQUcsQ0FBQytDLFVBQVVDLGFBQWEsR0FBRztvQkFDMUUsSUFBSyxJQUFJbEUsS0FBSyxHQUFHQSxLQUFLNkQsT0FBT2xELE1BQU0sRUFBRVgsS0FBTTt3QkFDekMsSUFBSyxJQUFJQyxLQUFLLEdBQUdBLEtBQUs2RCxPQUFPbkQsTUFBTSxFQUFFVixLQUFNOzRCQUN6QyxJQUFJNEQsTUFBTSxDQUFDN0QsR0FBRyxDQUFDVSxNQUFNLEtBQUtvRCxNQUFNLENBQUM3RCxHQUFHLENBQUNTLE1BQU0sRUFBRTtnQ0FDM0MsUUFBUTtnQ0FDUixNQUFNeUQsT0FBT04sTUFBTSxDQUFDN0QsR0FBRztnQ0FDdkI2RCxNQUFNLENBQUM3RCxHQUFHLEdBQUc4RCxNQUFNLENBQUM3RCxHQUFHO2dDQUN2QjZELE1BQU0sQ0FBQzdELEdBQUcsR0FBR2tFO2dDQUViLE1BQU1DLGFBQWFQLE9BQU9yRCxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxRQUFRQyxNQUFNO2dDQUNqRSxNQUFNMEQsZUFBZVIsT0FBT3JELE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTSxLQUFLLFVBQVVDLE1BQU07Z0NBQ3JFLE1BQU0yRCxhQUFhUixPQUFPdEQsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssUUFBUUMsTUFBTTtnQ0FDakUsTUFBTTRELGVBQWVULE9BQU90RCxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBSyxVQUFVQyxNQUFNO2dDQUVyRSxNQUFNNkQsZUFBZXZELEtBQUtDLEdBQUcsQ0FBQzZDLFVBQVVDLGFBQWEvQyxLQUFLQyxHQUFHLENBQUMrQyxVQUFVQztnQ0FDeEUsTUFBTU8sZUFBZXhELEtBQUtDLEdBQUcsQ0FBQ2tELGFBQWFDLGdCQUFnQnBELEtBQUtDLEdBQUcsQ0FBQ29ELGFBQWFDO2dDQUVqRixJQUFJRSxlQUFlRCxjQUFjO29DQUMvQlosV0FBVztvQ0FDWDtnQ0FDRixPQUFPO29DQUNMLE9BQU87b0NBQ1AsTUFBTWMsUUFBUWIsTUFBTSxDQUFDN0QsR0FBRztvQ0FDeEI2RCxNQUFNLENBQUM3RCxHQUFHLEdBQUc4RCxNQUFNLENBQUM3RCxHQUFHO29DQUN2QjZELE1BQU0sQ0FBQzdELEdBQUcsR0FBR3lFO2dDQUNmOzRCQUNGO3dCQUNGO3dCQUNBLElBQUlkLFVBQVU7b0JBQ2hCO2dCQUNGO2dCQUNBLElBQUlBLFVBQVU7WUFDaEI7WUFDQSxJQUFJQSxVQUFVO1FBQ2hCO1FBRUEsSUFBSSxDQUFDQSxVQUFVO0lBQ2pCO0lBRUEsbUJBQW1CO0lBQ25CLFNBQVNlO1FBQ1AsTUFBTUMsYUFBYSxJQUFJdEMsTUFBTVAsYUFBYXBCLE1BQU07UUFDaEQsTUFBTWtFLGFBQWEsSUFBSXZDLE1BQU1ILFdBQVcyQyxJQUFJLENBQUM7UUFFN0Msc0JBQXNCO1FBQ3RCLElBQUssSUFBSXhELElBQUksR0FBR0EsSUFBSVMsYUFBYXBCLE1BQU0sRUFBRVcsSUFBSztZQUM1QyxJQUFJb0IsYUFBYXBCLElBQUlhLFVBQVUsWUFBWTs7WUFDM0MsSUFBSTRDLFdBQVc7WUFFZiw4QkFBOEI7WUFDOUIsTUFBT0EsV0FBVyxHQUFJO2dCQUNwQixJQUFJRixVQUFVLENBQUNuQyxXQUFXLEdBQUdWLGFBQ3pCLENBQUNQLHVCQUF1Qk0sWUFBWSxDQUFDVCxFQUFFLEVBQUVvQixhQUFhLElBQUk7b0JBQzVEO2dCQUNGO2dCQUNBQSxhQUFhekIsS0FBSytELEtBQUssQ0FBQy9ELEtBQUtnRSxNQUFNLEtBQUs5QztnQkFDeEM0QztZQUNGO1lBRUEsa0NBQWtDO1lBQ2xDLElBQUlBLFlBQVksSUFBSTtnQkFDbEJyQyxhQUFhbUMsV0FBV0ssT0FBTyxDQUFDakUsS0FBS2tFLEdBQUcsSUFBSU47WUFDOUM7WUFFQUQsVUFBVSxDQUFDdEQsRUFBRSxHQUFHb0I7WUFDaEJtQyxVQUFVLENBQUNuQyxXQUFXO1FBQ3hCO1FBRUEsT0FBT2tDO0lBQ1Q7SUFFQSxTQUFTO0lBQ1QsU0FBU1EsaUJBQWlCUixVQUFvQjtRQUM1QyxNQUFNdkMsU0FBMEJDLE1BQU1DLElBQUksQ0FBQztZQUFFNUIsUUFBUXdCO1FBQVUsR0FBRyxJQUFNLEVBQUU7UUFFMUV5QyxXQUFXcEMsT0FBTyxDQUFDLENBQUNFLFlBQVkyQztZQUM5QmhELE1BQU0sQ0FBQ0ssV0FBVyxDQUFDQyxJQUFJLENBQUNaLFlBQVksQ0FBQ3NELGlCQUFpQjtRQUN4RDtRQUVBLElBQUlDLGFBQWE7UUFDakIsSUFBSUMsY0FBYztRQUVsQixLQUFLLE1BQU1qRixTQUFTK0IsT0FBUTtZQUMxQixJQUFJL0IsTUFBTUssTUFBTSxHQUFHLEdBQUc7Z0JBQ3BCMkUsY0FBY2pGLHNCQUFzQkM7Z0JBQ3BDaUY7Z0JBRUEsZUFBZTtnQkFDZixLQUFLLE1BQU03RCxlQUFlcEIsTUFBTztvQkFDL0IsTUFBTXFCLGNBQWNVLE9BQU82QyxPQUFPLENBQUM1RSxTQUFTO29CQUM1QyxJQUFJLENBQUNtQix1QkFBdUJDLGFBQWFDLGNBQWM7d0JBQ3JEMkQsY0FBYztvQkFDaEI7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT0MsY0FBYyxJQUFJRCxhQUFhQyxjQUFjO0lBQ3REO0lBRUEsS0FBSztJQUNMLFNBQVNDLFVBQVVDLE9BQWlCLEVBQUVDLE9BQWlCO1FBQ3JELE1BQU1DLFFBQVEsSUFBSXJELE1BQU1QLGFBQWFwQixNQUFNO1FBQzNDLE1BQU1pRixpQkFBaUIzRSxLQUFLK0QsS0FBSyxDQUFDL0QsS0FBS2dFLE1BQU0sS0FBS2xELGFBQWFwQixNQUFNO1FBRXJFLElBQUssSUFBSVcsSUFBSSxHQUFHQSxJQUFJUyxhQUFhcEIsTUFBTSxFQUFFVyxJQUFLO1lBQzVDcUUsS0FBSyxDQUFDckUsRUFBRSxHQUFHQSxJQUFJc0UsaUJBQWlCSCxPQUFPLENBQUNuRSxFQUFFLEdBQUdvRSxPQUFPLENBQUNwRSxFQUFFO1FBQ3pEO1FBRUEsT0FBT3FFO0lBQ1Q7SUFFQSxPQUFPO0lBQ1AsU0FBU0UsT0FBT2pCLFVBQW9CO1FBQ2xDLE1BQU1rQixVQUFVO2VBQUlsQjtTQUFXO1FBRS9CLElBQUssSUFBSXRELElBQUksR0FBR0EsSUFBSXdFLFFBQVFuRixNQUFNLEVBQUVXLElBQUs7WUFDdkMsSUFBSUwsS0FBS2dFLE1BQU0sS0FBS2MsY0FBYztnQkFDaEMsSUFBSUM7Z0JBQ0osSUFBSWpCLFdBQVc7Z0JBRWYsR0FBRztvQkFDRGlCLFdBQVcvRSxLQUFLK0QsS0FBSyxDQUFDL0QsS0FBS2dFLE1BQU0sS0FBSzlDO29CQUN0QzRDO2dCQUNGLFFBQ0VBLFdBQVcsS0FDWHRELHVCQUF1Qk0sWUFBWSxDQUFDVCxFQUFFLEVBQUUwRSxXQUFXLElBQ3BEO2dCQUVERixPQUFPLENBQUN4RSxFQUFFLEdBQUcwRTtZQUNmO1FBQ0Y7UUFFQSxPQUFPRjtJQUNUO0lBRUEsYUFBYTtJQUNiLElBQUlHLGFBQWEzRCxNQUFNQyxJQUFJLENBQUM7UUFBRTVCLFFBQVF1RjtJQUFlLEdBQUcsSUFBTXZCO0lBRTlELElBQUssSUFBSXdCLGFBQWEsR0FBR0EsYUFBYUMsYUFBYUQsYUFBYztRQUMvRCxjQUFjO1FBQ2QsTUFBTUUsZ0JBQWdCSixXQUFXbkQsR0FBRyxDQUFDc0M7UUFDckMsTUFBTWtCLGdCQUFnQkQsY0FDbkJ2RCxHQUFHLENBQUMsQ0FBQ3lELFNBQVM5RCxRQUFXO2dCQUFFOEQ7Z0JBQVM5RDtZQUFNLElBQzFDK0QsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVILE9BQU8sR0FBR0UsRUFBRUYsT0FBTztRQUV2QyxrQkFBa0I7UUFDbEIsTUFBTUksWUFBWTFGLEtBQUsrRCxLQUFLLENBQUNrQixpQkFBaUI7UUFDOUMsTUFBTVUsZ0JBQWdCTixjQUNuQk8sS0FBSyxDQUFDLEdBQUdGLFdBQ1Q3RCxHQUFHLENBQUNnRSxDQUFBQSxPQUFRYixVQUFVLENBQUNhLEtBQUtyRSxLQUFLLENBQUM7UUFFckMsb0JBQW9CO1FBQ3BCLE1BQU9tRSxjQUFjakcsTUFBTSxHQUFHdUYsZUFBZ0I7WUFDNUMsTUFBTWEsZUFBZTlGLEtBQUsrRCxLQUFLLENBQUMvRCxLQUFLZ0UsTUFBTSxLQUFLMEI7WUFDaEQsTUFBTUssZUFBZS9GLEtBQUsrRCxLQUFLLENBQUMvRCxLQUFLZ0UsTUFBTSxLQUFLMEI7WUFFaEQsTUFBTWxCLFVBQVVtQixhQUFhLENBQUNHLGFBQWE7WUFDM0MsTUFBTXJCLFVBQVVrQixhQUFhLENBQUNJLGFBQWE7WUFFM0MsSUFBSXJCLFFBQVFILFVBQVVDLFNBQVNDO1lBQy9CQyxRQUFRRSxPQUFPRjtZQUVmaUIsY0FBY2pFLElBQUksQ0FBQ2dEO1FBQ3JCO1FBRUFNLGFBQWFXO0lBQ2Y7SUFFQSxVQUFVO0lBQ1YsTUFBTVAsZ0JBQWdCSixXQUFXbkQsR0FBRyxDQUFDc0M7SUFDckMsTUFBTTZCLFlBQVlaLGNBQWNuQixPQUFPLENBQUNqRSxLQUFLaUcsR0FBRyxJQUFJYjtJQUNwRCxNQUFNYyxlQUFlbEIsVUFBVSxDQUFDZ0IsVUFBVTtJQUUxQyxRQUFRO0lBQ1IsTUFBTXBFLGNBQXVCLEVBQUU7SUFDL0IsTUFBTXVFLGNBQStCOUUsTUFBTUMsSUFBSSxDQUFDO1FBQUU1QixRQUFRd0I7SUFBVSxHQUFHLElBQU0sRUFBRTtJQUUvRWdGLGFBQWEzRSxPQUFPLENBQUMsQ0FBQ0UsWUFBWTJDO1FBQ2hDK0IsV0FBVyxDQUFDMUUsV0FBVyxDQUFDQyxJQUFJLENBQUNaLFlBQVksQ0FBQ3NELGlCQUFpQjtJQUM3RDtJQUVBLElBQUlwQyxtQkFBbUI7SUFDdkIsSUFBSUMscUJBQXFCO0lBQ3pCLElBQUlDLG1CQUFtQjtJQUV2QmlFLFlBQVk1RSxPQUFPLENBQUMsQ0FBQ08sY0FBY047UUFDakMsTUFBTWxDLFlBQVl3QyxhQUFhdkMsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxNQUFNLEtBQUssUUFBUUMsTUFBTTtRQUN0RSxNQUFNQyxjQUFjbUMsYUFBYXZDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsTUFBTSxLQUFLLFVBQVVDLE1BQU07UUFDMUUsTUFBTUUsaUJBQWlCa0MsYUFBYXZDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUssSUFBSSxLQUFLLGFBQWFILE1BQU07UUFDOUUsTUFBTUksaUJBQWlCZ0MsYUFBYXZDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUssSUFBSSxLQUFLLGFBQWFILE1BQU07UUFFOUUsMEJBQTBCO1FBQzFCLElBQUlvQyxhQUFhcEMsTUFBTSxHQUFHLEdBQUc7WUFDM0IsSUFBSyxJQUFJVyxJQUFJLEdBQUdBLElBQUl5QixhQUFhcEMsTUFBTSxFQUFFVyxJQUFLO2dCQUM1QyxJQUFLLElBQUlDLElBQUlELElBQUksR0FBR0MsSUFBSXdCLGFBQWFwQyxNQUFNLEVBQUVZLElBQUs7b0JBQ2hELElBQUksQ0FBQ3hCLFFBQVFnRCxZQUFZLENBQUN6QixFQUFFLEVBQUV5QixZQUFZLENBQUN4QixFQUFFLEdBQUc7d0JBQzlDMEI7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBQyxzQkFBc0IsSUFBSWpDLEtBQUtDLEdBQUcsQ0FBQ1gsWUFBWUssZUFBZW1DLGFBQWFwQyxNQUFNO1lBQ2pGd0Msb0JBQW9CLElBQUlsQyxLQUFLQyxHQUFHLENBQUNMLGlCQUFpQkUsa0JBQWtCZ0MsYUFBYXBDLE1BQU07UUFDekY7UUFFQSx1QkFBdUI7UUFDdkJrQyxZQUFZRixJQUFJLENBQUM7WUFDZnZDLElBQUlxQyxRQUFRO1lBQ1pPLFNBQVNEO1lBQ1R4QztZQUNBSztZQUNBQztZQUNBRTtRQUNGO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xzQixRQUFRUTtRQUNSTyxPQUFPbkI7UUFDUG9CLFNBQVM7WUFDUEMsYUFBYVQsWUFBWWxDLE1BQU07WUFDL0I0QyxjQUFjeEIsYUFBYXBCLE1BQU0sR0FBR2tDLFlBQVlsQyxNQUFNO1lBQ3RENkMsb0JBQW9CdkMsS0FBS21DLEtBQUssQ0FBQyxxQkFBc0JQLFlBQVlsQyxNQUFNLEdBQUk7WUFDM0U4QyxrQkFBa0J4QyxLQUFLbUMsS0FBSyxDQUFDLG1CQUFvQlAsWUFBWWxDLE1BQU0sR0FBSTtZQUN2RStDLGtCQUFrQlQ7UUFDcEI7SUFDRjtBQUNGO0FBRUEsZUFBZTtBQUNSLFNBQVNvRSxxQkFDZHRGLFlBQTJCLEVBQzNCTSxNQUFlLEVBQ2ZlLEtBQWE7SUFFYixNQUFNa0Usc0JBQXNCdkYsYUFBYWUsR0FBRyxDQUFDckMsQ0FBQUEsSUFBTTtZQUNqRCxHQUFHQSxDQUFDO1lBQ0pQLFdBQVc7bUJBQUtPLEVBQUVQLFNBQVMsSUFBSSxFQUFFO2FBQUU7WUFDbkMyQixjQUFjO21CQUFLcEIsRUFBRW9CLFlBQVksSUFBSSxFQUFFO2FBQUU7UUFDM0M7SUFFQSwwQkFBMEI7SUFDMUJRLE9BQU9HLE9BQU8sQ0FBQ2xDLENBQUFBO1FBQ2Isa0JBQWtCO1FBQ2xCQSxNQUFNMEMsT0FBTyxDQUFDUixPQUFPLENBQUMrRSxDQUFBQTtZQUNwQixNQUFNN0YsY0FBYzRGLG9CQUFvQkUsSUFBSSxDQUFDL0csQ0FBQUEsSUFBS0EsRUFBRUwsRUFBRSxLQUFLbUgsT0FBT25ILEVBQUU7WUFDcEUsSUFBSXNCLGFBQWE7Z0JBQ2ZBLFlBQVlHLFlBQVksQ0FBRWMsSUFBSSxDQUFDckMsTUFBTUYsRUFBRTtZQUN6QztRQUNGO1FBRUEsZ0JBQWdCO1FBQ2hCLElBQUssSUFBSWtCLElBQUksR0FBR0EsSUFBSWhCLE1BQU0wQyxPQUFPLENBQUNyQyxNQUFNLEVBQUVXLElBQUs7WUFDN0MsSUFBSyxJQUFJQyxJQUFJRCxJQUFJLEdBQUdDLElBQUlqQixNQUFNMEMsT0FBTyxDQUFDckMsTUFBTSxFQUFFWSxJQUFLO2dCQUNqRCxNQUFNdkIsS0FBS3NILG9CQUFvQkUsSUFBSSxDQUFDL0csQ0FBQUEsSUFBS0EsRUFBRUwsRUFBRSxLQUFLRSxNQUFNMEMsT0FBTyxDQUFDMUIsRUFBRSxDQUFDbEIsRUFBRTtnQkFDckUsTUFBTUgsS0FBS3FILG9CQUFvQkUsSUFBSSxDQUFDL0csQ0FBQUEsSUFBS0EsRUFBRUwsRUFBRSxLQUFLRSxNQUFNMEMsT0FBTyxDQUFDekIsRUFBRSxDQUFDbkIsRUFBRTtnQkFFckUsSUFBSUosTUFBTUMsSUFBSTtvQkFDWixJQUFJLENBQUNELEdBQUdFLFNBQVMsQ0FBRUMsUUFBUSxDQUFDRixHQUFHRyxFQUFFLEdBQUc7d0JBQ2xDSixHQUFHRSxTQUFTLENBQUV5QyxJQUFJLENBQUMxQyxHQUFHRyxFQUFFO29CQUMxQjtvQkFDQSxJQUFJLENBQUNILEdBQUdDLFNBQVMsQ0FBRUMsUUFBUSxDQUFDSCxHQUFHSSxFQUFFLEdBQUc7d0JBQ2xDSCxHQUFHQyxTQUFTLENBQUV5QyxJQUFJLENBQUMzQyxHQUFHSSxFQUFFO29CQUMxQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU9rSDtBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvZG9oeWVvbmFuL3NpZGVQcm9qZWN0cy9zb2NpYWxpbmdTZWF0QXNzaWduZXIvc3JjL3V0aWxzL2dyb3VwaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgUGFydGljaXBhbnQge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBnZW5kZXI6ICdtYWxlJyB8ICdmZW1hbGUnXG4gIG1idGk6ICdleHRyb3ZlcnQnIHwgJ2ludHJvdmVydCdcbiAgbWV0UGVvcGxlPzogc3RyaW5nW11cbiAgZ3JvdXBIaXN0b3J5PzogbnVtYmVyW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91cCB7XG4gIGlkOiBudW1iZXJcbiAgbWVtYmVyczogUGFydGljaXBhbnRbXVxuICBtYWxlQ291bnQ6IG51bWJlclxuICBmZW1hbGVDb3VudDogbnVtYmVyXG4gIGV4dHJvdmVydENvdW50OiBudW1iZXJcbiAgaW50cm92ZXJ0Q291bnQ6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwaW5nUmVzdWx0IHtcbiAgZ3JvdXBzOiBHcm91cFtdXG4gIHJvdW5kOiBudW1iZXJcbiAgc3VtbWFyeToge1xuICAgIHRvdGFsR3JvdXBzOiBudW1iZXJcbiAgICBhdmdHcm91cFNpemU6IG51bWJlclxuICAgIGdlbmRlckJhbGFuY2VTY29yZTogbnVtYmVyXG4gICAgbWJ0aUJhbGFuY2VTY29yZTogbnVtYmVyXG4gICAgbmV3TWVldGluZ3NDb3VudDogbnVtYmVyXG4gIH1cbn1cblxuLy8g65GQIOywuOqwgOyekOqwgCDsnbTsoITsl5Ag66eM64Ks64qU7KeAIO2ZleyduFxuZnVuY3Rpb24gaGF2ZU1ldChwMTogUGFydGljaXBhbnQsIHAyOiBQYXJ0aWNpcGFudCk6IGJvb2xlYW4ge1xuICByZXR1cm4gcDEubWV0UGVvcGxlPy5pbmNsdWRlcyhwMi5pZCkgfHwgZmFsc2Vcbn1cblxuLy8g6re466O57J2YIOq3oO2YlSDsoJDsiJgg6rOE7IKwICjrhpLsnYTsiJjroZ0g7KKL7J2MKVxuZnVuY3Rpb24gY2FsY3VsYXRlR3JvdXBCYWxhbmNlKGdyb3VwOiBQYXJ0aWNpcGFudFtdKTogbnVtYmVyIHtcbiAgY29uc3QgbWFsZUNvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gIGNvbnN0IGZlbWFsZUNvdW50ID0gZ3JvdXAuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdmZW1hbGUnKS5sZW5ndGhcbiAgY29uc3QgZXh0cm92ZXJ0Q291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdleHRyb3ZlcnQnKS5sZW5ndGhcbiAgY29uc3QgaW50cm92ZXJ0Q291bnQgPSBncm91cC5maWx0ZXIocCA9PiBwLm1idGkgPT09ICdpbnRyb3ZlcnQnKS5sZW5ndGhcbiAgXG4gIC8vIOyEseuzhCDqt6DtmJUg7KCQ7IiYICjsmrDshKDsiJzsnIQg64aS7J2MKVxuICBjb25zdCBnZW5kZXJCYWxhbmNlID0gMSAtIE1hdGguYWJzKG1hbGVDb3VudCAtIGZlbWFsZUNvdW50KSAvIGdyb3VwLmxlbmd0aFxuICBcbiAgLy8gTUJUSSDqt6DtmJUg7KCQ7IiYICjsmrDshKDsiJzsnIQg64Ku7J2MKVxuICBjb25zdCBtYnRpQmFsYW5jZSA9IDEgLSBNYXRoLmFicyhleHRyb3ZlcnRDb3VudCAtIGludHJvdmVydENvdW50KSAvIGdyb3VwLmxlbmd0aFxuICBcbiAgLy8g7IOI66Gc7Jq0IOunjOuCqCDsoJDsiJhcbiAgbGV0IG5ld01lZXRpbmdzID0gMFxuICBsZXQgdG90YWxQYWlycyA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwLmxlbmd0aDsgaisrKSB7XG4gICAgICB0b3RhbFBhaXJzKytcbiAgICAgIGlmICghaGF2ZU1ldChncm91cFtpXSwgZ3JvdXBbal0pKSB7XG4gICAgICAgIG5ld01lZXRpbmdzKytcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbmV3TWVldGluZ1Njb3JlID0gdG90YWxQYWlycyA+IDAgPyBuZXdNZWV0aW5ncyAvIHRvdGFsUGFpcnMgOiAxXG4gIFxuICAvLyDqsIDspJEg7Y+J6regICjshLHrs4Qg6reg7ZiVIDcwJSwg7IOI66Gc7Jq0IOunjOuCqCAyNSUsIE1CVEkg6reg7ZiVIDUlKVxuICByZXR1cm4gZ2VuZGVyQmFsYW5jZSAqIDAuNyArIG5ld01lZXRpbmdTY29yZSAqIDAuMjUgKyBtYnRpQmFsYW5jZSAqIDAuMDVcbn1cblxuLy8g7LC46rCA7J6Q6rCAIOydtOyghCDrnbzsmrTrk5zsmYAg64uk66W4IOq3uOujuSDrsojtmLjrpbwg6rCA7KC47JW8IO2VmOuKlOyngCDtmZXsnbhcbmZ1bmN0aW9uIHNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQ6IFBhcnRpY2lwYW50LCBncm91cE51bWJlcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhpc3RvcnkgPSBwYXJ0aWNpcGFudC5ncm91cEhpc3RvcnkgfHwgW11cbiAgcmV0dXJuIGhpc3RvcnkubGVuZ3RoID4gMCAmJiBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV0gPT09IGdyb3VwTnVtYmVyXG59XG5cbi8vIOqwhOuLqO2VnCDqt7jro7kg67Cw7LmYIOyVjOqzoOumrOymmFxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9wdGltYWxHcm91cHMoXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRbXSwgXG4gIGdyb3VwU2l6ZTogbnVtYmVyID0gNCxcbiAgY3VycmVudFJvdW5kOiBudW1iZXIgPSAxXG4pOiBHcm91cGluZ1Jlc3VsdCB7XG4gIGlmIChwYXJ0aWNpcGFudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcign7LWc7IaMIDLrqoUg7J207IOB7J2YIOywuOqwgOyekOqwgCDtlYTsmpTtlanri4jri6QuJylcbiAgfVxuXG4gIGNvbnN0IG51bUdyb3VwcyA9IE1hdGguY2VpbChwYXJ0aWNpcGFudHMubGVuZ3RoIC8gZ3JvdXBTaXplKVxuICBcbiAgLy8g6rCE64uo7ZWcIOuwsOy5mCDrsKnsi53snLzroZwg67OA6rK9XG4gIGNvbnN0IGdyb3VwczogUGFydGljaXBhbnRbXVtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtR3JvdXBzIH0sICgpID0+IFtdKVxuICBcbiAgLy8g7LC46rCA7J6Q66W8IOyInOywqOyggeycvOuhnCDqt7jro7nsl5Ag67Cw7LmYXG4gIHBhcnRpY2lwYW50cy5mb3JFYWNoKChwYXJ0aWNpcGFudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBncm91cEluZGV4ID0gaW5kZXggJSBudW1Hcm91cHNcbiAgICBncm91cHNbZ3JvdXBJbmRleF0ucHVzaChwYXJ0aWNpcGFudClcbiAgfSlcbiAgXG4gIC8vIOq3uOujuSDqt6DtmJUg7LWc7KCB7ZmUICjshLHrs4Qg6reg7ZiVIOqzoOugpClcbiAgb3B0aW1pemVHcm91cHMoZ3JvdXBzLCBwYXJ0aWNpcGFudHMpXG4gIFxuICAvLyDqsrDqs7wg6rWs7ISxXG4gIGNvbnN0IGZpbmFsR3JvdXBzOiBHcm91cFtdID0gZ3JvdXBzLm1hcCgoZ3JvdXBNZW1iZXJzLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICBjb25zdCBmZW1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgIGNvbnN0IGV4dHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2V4dHJvdmVydCcpLmxlbmd0aFxuICAgIGNvbnN0IGludHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBpZDogaW5kZXggKyAxLFxuICAgICAgbWVtYmVyczogZ3JvdXBNZW1iZXJzLFxuICAgICAgbWFsZUNvdW50LFxuICAgICAgZmVtYWxlQ291bnQsXG4gICAgICBleHRyb3ZlcnRDb3VudCxcbiAgICAgIGludHJvdmVydENvdW50XG4gICAgfVxuICB9KS5maWx0ZXIoZ3JvdXAgPT4gZ3JvdXAubWVtYmVycy5sZW5ndGggPiAwKSAvLyDruYgg6re466O5IOygnOqxsFxuICBcbiAgLy8g7Ya16rOEIOqzhOyCsFxuICBsZXQgbmV3TWVldGluZ3NUb3RhbCA9IDBcbiAgbGV0IHRvdGFsR2VuZGVyQmFsYW5jZSA9IDBcbiAgbGV0IHRvdGFsTWJ0aUJhbGFuY2UgPSAwXG4gIFxuICBmaW5hbEdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICBjb25zdCBncm91cE1lbWJlcnMgPSBncm91cC5tZW1iZXJzXG4gICAgXG4gICAgLy8g7IOI66Gc7Jq0IOunjOuCqCDqs4TsgrBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwTWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ3JvdXBNZW1iZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghaGF2ZU1ldChncm91cE1lbWJlcnNbaV0sIGdyb3VwTWVtYmVyc1tqXSkpIHtcbiAgICAgICAgICBuZXdNZWV0aW5nc1RvdGFsKytcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoZ3JvdXBNZW1iZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRvdGFsR2VuZGVyQmFsYW5jZSArPSAxIC0gTWF0aC5hYnMoZ3JvdXAubWFsZUNvdW50IC0gZ3JvdXAuZmVtYWxlQ291bnQpIC8gZ3JvdXBNZW1iZXJzLmxlbmd0aFxuICAgICAgdG90YWxNYnRpQmFsYW5jZSArPSAxIC0gTWF0aC5hYnMoZ3JvdXAuZXh0cm92ZXJ0Q291bnQgLSBncm91cC5pbnRyb3ZlcnRDb3VudCkgLyBncm91cE1lbWJlcnMubGVuZ3RoXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgZ3JvdXBzOiBmaW5hbEdyb3VwcyxcbiAgICByb3VuZDogY3VycmVudFJvdW5kLFxuICAgIHN1bW1hcnk6IHtcbiAgICAgIHRvdGFsR3JvdXBzOiBmaW5hbEdyb3Vwcy5sZW5ndGgsXG4gICAgICBhdmdHcm91cFNpemU6IHBhcnRpY2lwYW50cy5sZW5ndGggLyBmaW5hbEdyb3Vwcy5sZW5ndGgsXG4gICAgICBnZW5kZXJCYWxhbmNlU2NvcmU6IGZpbmFsR3JvdXBzLmxlbmd0aCA+IDAgPyBNYXRoLnJvdW5kKCh0b3RhbEdlbmRlckJhbGFuY2UgLyBmaW5hbEdyb3Vwcy5sZW5ndGgpICogMTAwKSA6IDAsXG4gICAgICBtYnRpQmFsYW5jZVNjb3JlOiBmaW5hbEdyb3Vwcy5sZW5ndGggPiAwID8gTWF0aC5yb3VuZCgodG90YWxNYnRpQmFsYW5jZSAvIGZpbmFsR3JvdXBzLmxlbmd0aCkgKiAxMDApIDogMCxcbiAgICAgIG5ld01lZXRpbmdzQ291bnQ6IG5ld01lZXRpbmdzVG90YWxcbiAgICB9XG4gIH1cbn1cblxuLy8g6re466O5IOy1nOygge2ZlCDtlajsiJhcbmZ1bmN0aW9uIG9wdGltaXplR3JvdXBzKGdyb3VwczogUGFydGljaXBhbnRbXVtdLCBwYXJ0aWNpcGFudHM6IFBhcnRpY2lwYW50W10pIHtcbiAgLy8g6rCE64uo7ZWcIOyEseuzhCDqt6DtmJUg7LWc7KCB7ZmUXG4gIGZvciAobGV0IGl0ZXJhdGlvbnMgPSAwOyBpdGVyYXRpb25zIDwgMTA7IGl0ZXJhdGlvbnMrKykge1xuICAgIGxldCBpbXByb3ZlZCA9IGZhbHNlXG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoZ3JvdXBzW2ldLmxlbmd0aCA9PT0gMCB8fCBncm91cHNbal0ubGVuZ3RoID09PSAwKSBjb250aW51ZVxuICAgICAgICBcbiAgICAgICAgLy8g7ISx67OEIOq3oO2YlSDqsJzshKDsnYQg7JyE7ZWcIOq1kO2ZmCDsi5zrj4RcbiAgICAgICAgY29uc3QgZ3JvdXAxID0gZ3JvdXBzW2ldXG4gICAgICAgIGNvbnN0IGdyb3VwMiA9IGdyb3Vwc1tqXVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZzFNYWxlcyA9IGdyb3VwMS5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICAgICAgY29uc3QgZzFGZW1hbGVzID0gZ3JvdXAxLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgICAgIGNvbnN0IGcyTWFsZXMgPSBncm91cDIuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gICAgICAgIGNvbnN0IGcyRmVtYWxlcyA9IGdyb3VwMi5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgICAgICBcbiAgICAgICAgLy8g67aI6reg7ZiV7ZWcIOq3uOujueuTpCDqsIQg6rWQ7ZmYXG4gICAgICAgIGlmIChNYXRoLmFicyhnMU1hbGVzIC0gZzFGZW1hbGVzKSA+IDEgfHwgTWF0aC5hYnMoZzJNYWxlcyAtIGcyRmVtYWxlcykgPiAxKSB7XG4gICAgICAgICAgZm9yIChsZXQgcDEgPSAwOyBwMSA8IGdyb3VwMS5sZW5ndGg7IHAxKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAyID0gMDsgcDIgPCBncm91cDIubGVuZ3RoOyBwMisrKSB7XG4gICAgICAgICAgICAgIGlmIChncm91cDFbcDFdLmdlbmRlciAhPT0gZ3JvdXAyW3AyXS5nZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAvLyDqtZDtmZjtlbTrs7TquLBcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gZ3JvdXAxW3AxXVxuICAgICAgICAgICAgICAgIGdyb3VwMVtwMV0gPSBncm91cDJbcDJdXG4gICAgICAgICAgICAgICAgZ3JvdXAyW3AyXSA9IHRlbXBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdHMU1hbGVzID0gZ3JvdXAxLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnbWFsZScpLmxlbmd0aFxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0cxRmVtYWxlcyA9IGdyb3VwMS5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0cyTWFsZXMgPSBncm91cDIuZmlsdGVyKHAgPT4gcC5nZW5kZXIgPT09ICdtYWxlJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RzJGZW1hbGVzID0gZ3JvdXAyLmZpbHRlcihwID0+IHAuZ2VuZGVyID09PSAnZmVtYWxlJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkSW1iYWxhbmNlID0gTWF0aC5hYnMoZzFNYWxlcyAtIGcxRmVtYWxlcykgKyBNYXRoLmFicyhnMk1hbGVzIC0gZzJGZW1hbGVzKVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ltYmFsYW5jZSA9IE1hdGguYWJzKG5ld0cxTWFsZXMgLSBuZXdHMUZlbWFsZXMpICsgTWF0aC5hYnMobmV3RzJNYWxlcyAtIG5ld0cyRmVtYWxlcylcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobmV3SW1iYWxhbmNlIDwgb2xkSW1iYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICBpbXByb3ZlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIOuQmOuPjOumrOq4sFxuICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcDIgPSBncm91cDFbcDFdXG4gICAgICAgICAgICAgICAgICBncm91cDFbcDFdID0gZ3JvdXAyW3AyXVxuICAgICAgICAgICAgICAgICAgZ3JvdXAyW3AyXSA9IHRlbXAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1wcm92ZWQpIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbXByb3ZlZCkgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpbXByb3ZlZCkgYnJlYWtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFpbXByb3ZlZCkgYnJlYWtcbiAgfVxuXG4gIC8vIOqwnOyytCDsg53shLEgKOq3uOujuSDrsLDsuZgg67Cp7IudKVxuICBmdW5jdGlvbiBjcmVhdGVJbmRpdmlkdWFsKCk6IG51bWJlcltdIHtcbiAgICBjb25zdCBpbmRpdmlkdWFsID0gbmV3IEFycmF5KHBhcnRpY2lwYW50cy5sZW5ndGgpXG4gICAgY29uc3QgZ3JvdXBTaXplcyA9IG5ldyBBcnJheShudW1Hcm91cHMpLmZpbGwoMClcbiAgICBcbiAgICAvLyDrqLzsoIAg66qo65OgIOywuOqwgOyekOulvCDsiJzssKjsoIHsnLzroZwg67Cw7LmYXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNpcGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBncm91cEluZGV4ID0gaSAlIG51bUdyb3VwcyAvLyDsiJzssKgg67Cw7LmY66GcIOyLnOyekVxuICAgICAgbGV0IGF0dGVtcHRzID0gMFxuICAgICAgXG4gICAgICAvLyDqt7jro7kg7YGs6riwIOygnO2VnOqzvCDqt7jro7kg67KI7Zi4IO2ajO2UvOulvCDqs6DroKTtlZwg7J6s67Cw7LmYXG4gICAgICB3aGlsZSAoYXR0ZW1wdHMgPCAyMCkge1xuICAgICAgICBpZiAoZ3JvdXBTaXplc1tncm91cEluZGV4XSA8IGdyb3VwU2l6ZSAmJiBcbiAgICAgICAgICAgICFzaG91bGRBdm9pZEdyb3VwTnVtYmVyKHBhcnRpY2lwYW50c1tpXSwgZ3JvdXBJbmRleCArIDEpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBncm91cEluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbnVtR3JvdXBzKVxuICAgICAgICBhdHRlbXB0cysrXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIOy1nOyiheyggeycvOuhnCDsobDqsbTsnYQg66eM7KGx7ZWY7KeAIOuqu+2VmOuptCDqsIDsnqUg7KCB7J2AIOq3uOujueyXkCDrsLDsuZhcbiAgICAgIGlmIChhdHRlbXB0cyA+PSAyMCkge1xuICAgICAgICBncm91cEluZGV4ID0gZ3JvdXBTaXplcy5pbmRleE9mKE1hdGgubWluKC4uLmdyb3VwU2l6ZXMpKVxuICAgICAgfVxuICAgICAgXG4gICAgICBpbmRpdmlkdWFsW2ldID0gZ3JvdXBJbmRleFxuICAgICAgZ3JvdXBTaXplc1tncm91cEluZGV4XSsrXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpbmRpdmlkdWFsXG4gIH1cblxuICAvLyDsoIHtlanrj4Qg6rOE7IKwXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUZpdG5lc3MoaW5kaXZpZHVhbDogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGNvbnN0IGdyb3VwczogUGFydGljaXBhbnRbXVtdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtR3JvdXBzIH0sICgpID0+IFtdKVxuICAgIFxuICAgIGluZGl2aWR1YWwuZm9yRWFjaCgoZ3JvdXBJbmRleCwgcGFydGljaXBhbnRJbmRleCkgPT4ge1xuICAgICAgZ3JvdXBzW2dyb3VwSW5kZXhdLnB1c2gocGFydGljaXBhbnRzW3BhcnRpY2lwYW50SW5kZXhdKVxuICAgIH0pXG4gICAgXG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwXG4gICAgbGV0IHZhbGlkR3JvdXBzID0gMFxuICAgIFxuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZ3JvdXBzKSB7XG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgICB0b3RhbFNjb3JlICs9IGNhbGN1bGF0ZUdyb3VwQmFsYW5jZShncm91cClcbiAgICAgICAgdmFsaWRHcm91cHMrK1xuICAgICAgICBcbiAgICAgICAgLy8g6re466O5IOuyiO2YuCDtmoztlLwg67O064SI7IqkXG4gICAgICAgIGZvciAoY29uc3QgcGFydGljaXBhbnQgb2YgZ3JvdXApIHtcbiAgICAgICAgICBjb25zdCBncm91cE51bWJlciA9IGdyb3Vwcy5pbmRleE9mKGdyb3VwKSArIDFcbiAgICAgICAgICBpZiAoIXNob3VsZEF2b2lkR3JvdXBOdW1iZXIocGFydGljaXBhbnQsIGdyb3VwTnVtYmVyKSkge1xuICAgICAgICAgICAgdG90YWxTY29yZSArPSAwLjFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHZhbGlkR3JvdXBzID4gMCA/IHRvdGFsU2NvcmUgLyB2YWxpZEdyb3VwcyA6IDBcbiAgfVxuXG4gIC8vIOq1kOywqFxuICBmdW5jdGlvbiBjcm9zc292ZXIocGFyZW50MTogbnVtYmVyW10sIHBhcmVudDI6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGNoaWxkID0gbmV3IEFycmF5KHBhcnRpY2lwYW50cy5sZW5ndGgpXG4gICAgY29uc3QgY3Jvc3NvdmVyUG9pbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYXJ0aWNpcGFudHMubGVuZ3RoKVxuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljaXBhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZFtpXSA9IGkgPCBjcm9zc292ZXJQb2ludCA/IHBhcmVudDFbaV0gOiBwYXJlbnQyW2ldXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjaGlsZFxuICB9XG5cbiAgLy8g64+M7Jew67OA7J20XG4gIGZ1bmN0aW9uIG11dGF0ZShpbmRpdmlkdWFsOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICBjb25zdCBtdXRhdGVkID0gWy4uLmluZGl2aWR1YWxdXG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IG11dGF0aW9uUmF0ZSkge1xuICAgICAgICBsZXQgbmV3R3JvdXBcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMFxuICAgICAgICBcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5ld0dyb3VwID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbnVtR3JvdXBzKVxuICAgICAgICAgIGF0dGVtcHRzKytcbiAgICAgICAgfSB3aGlsZSAoXG4gICAgICAgICAgYXR0ZW1wdHMgPCA1ICYmXG4gICAgICAgICAgc2hvdWxkQXZvaWRHcm91cE51bWJlcihwYXJ0aWNpcGFudHNbaV0sIG5ld0dyb3VwICsgMSlcbiAgICAgICAgKVxuICAgICAgICBcbiAgICAgICAgbXV0YXRlZFtpXSA9IG5ld0dyb3VwXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBtdXRhdGVkXG4gIH1cblxuICAvLyDsnKDsoIQg7JWM6rOg66as7KaYIOyLpO2WiVxuICBsZXQgcG9wdWxhdGlvbiA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHBvcHVsYXRpb25TaXplIH0sICgpID0+IGNyZWF0ZUluZGl2aWR1YWwoKSlcbiAgXG4gIGZvciAobGV0IGdlbmVyYXRpb24gPSAwOyBnZW5lcmF0aW9uIDwgZ2VuZXJhdGlvbnM7IGdlbmVyYXRpb24rKykge1xuICAgIC8vIOygge2VqeuPhCDqs4TsgrAg67CPIOygleugrFxuICAgIGNvbnN0IGZpdG5lc3NTY29yZXMgPSBwb3B1bGF0aW9uLm1hcChjYWxjdWxhdGVGaXRuZXNzKVxuICAgIGNvbnN0IHNvcnRlZEluZGljZXMgPSBmaXRuZXNzU2NvcmVzXG4gICAgICAubWFwKChmaXRuZXNzLCBpbmRleCkgPT4gKHsgZml0bmVzcywgaW5kZXggfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5maXRuZXNzIC0gYS5maXRuZXNzKVxuICAgIFxuICAgIC8vIOyXmOumrO2KuCDshKDtg50gKOyDgeychCAyMCUpXG4gICAgY29uc3QgZWxpdGVTaXplID0gTWF0aC5mbG9vcihwb3B1bGF0aW9uU2l6ZSAqIDAuMilcbiAgICBjb25zdCBuZXdQb3B1bGF0aW9uID0gc29ydGVkSW5kaWNlc1xuICAgICAgLnNsaWNlKDAsIGVsaXRlU2l6ZSlcbiAgICAgIC5tYXAoaXRlbSA9PiBwb3B1bGF0aW9uW2l0ZW0uaW5kZXhdKVxuICAgIFxuICAgIC8vIOuCmOuouOyngOuKlCDqtZDssKjsmYAg64+M7Jew67OA7J2066GcIOyDneyEsVxuICAgIHdoaWxlIChuZXdQb3B1bGF0aW9uLmxlbmd0aCA8IHBvcHVsYXRpb25TaXplKSB7XG4gICAgICBjb25zdCBwYXJlbnQxSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBlbGl0ZVNpemUpXG4gICAgICBjb25zdCBwYXJlbnQySW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBlbGl0ZVNpemUpXG4gICAgICBcbiAgICAgIGNvbnN0IHBhcmVudDEgPSBuZXdQb3B1bGF0aW9uW3BhcmVudDFJbmRleF1cbiAgICAgIGNvbnN0IHBhcmVudDIgPSBuZXdQb3B1bGF0aW9uW3BhcmVudDJJbmRleF1cbiAgICAgIFxuICAgICAgbGV0IGNoaWxkID0gY3Jvc3NvdmVyKHBhcmVudDEsIHBhcmVudDIpXG4gICAgICBjaGlsZCA9IG11dGF0ZShjaGlsZClcbiAgICAgIFxuICAgICAgbmV3UG9wdWxhdGlvbi5wdXNoKGNoaWxkKVxuICAgIH1cbiAgICBcbiAgICBwb3B1bGF0aW9uID0gbmV3UG9wdWxhdGlvblxuICB9XG5cbiAgLy8g7LWc7KCBIO2VtCDshKDtg51cbiAgY29uc3QgZml0bmVzc1Njb3JlcyA9IHBvcHVsYXRpb24ubWFwKGNhbGN1bGF0ZUZpdG5lc3MpXG4gIGNvbnN0IGJlc3RJbmRleCA9IGZpdG5lc3NTY29yZXMuaW5kZXhPZihNYXRoLm1heCguLi5maXRuZXNzU2NvcmVzKSlcbiAgY29uc3QgYmVzdFNvbHV0aW9uID0gcG9wdWxhdGlvbltiZXN0SW5kZXhdXG5cbiAgLy8g6rKw6rO8IOq1rOyEsVxuICBjb25zdCBmaW5hbEdyb3VwczogR3JvdXBbXSA9IFtdXG4gIGNvbnN0IGdyb3VwQXJyYXlzOiBQYXJ0aWNpcGFudFtdW10gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBudW1Hcm91cHMgfSwgKCkgPT4gW10pXG4gIFxuICBiZXN0U29sdXRpb24uZm9yRWFjaCgoZ3JvdXBJbmRleCwgcGFydGljaXBhbnRJbmRleCkgPT4ge1xuICAgIGdyb3VwQXJyYXlzW2dyb3VwSW5kZXhdLnB1c2gocGFydGljaXBhbnRzW3BhcnRpY2lwYW50SW5kZXhdKVxuICB9KVxuICBcbiAgbGV0IG5ld01lZXRpbmdzVG90YWwgPSAwXG4gIGxldCB0b3RhbEdlbmRlckJhbGFuY2UgPSAwXG4gIGxldCB0b3RhbE1idGlCYWxhbmNlID0gMFxuICBcbiAgZ3JvdXBBcnJheXMuZm9yRWFjaCgoZ3JvdXBNZW1iZXJzLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ21hbGUnKS5sZW5ndGhcbiAgICBjb25zdCBmZW1hbGVDb3VudCA9IGdyb3VwTWVtYmVycy5maWx0ZXIocCA9PiBwLmdlbmRlciA9PT0gJ2ZlbWFsZScpLmxlbmd0aFxuICAgIGNvbnN0IGV4dHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2V4dHJvdmVydCcpLmxlbmd0aFxuICAgIGNvbnN0IGludHJvdmVydENvdW50ID0gZ3JvdXBNZW1iZXJzLmZpbHRlcihwID0+IHAubWJ0aSA9PT0gJ2ludHJvdmVydCcpLmxlbmd0aFxuICAgIFxuICAgIC8vIOyDiOuhnOyatCDrp4zrgqgg6rOE7IKwICjruYgg6re466O57J20IOyVhOuLkCDrlYzrp4wpXG4gICAgaWYgKGdyb3VwTWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwTWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBncm91cE1lbWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoIWhhdmVNZXQoZ3JvdXBNZW1iZXJzW2ldLCBncm91cE1lbWJlcnNbal0pKSB7XG4gICAgICAgICAgICBuZXdNZWV0aW5nc1RvdGFsKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdG90YWxHZW5kZXJCYWxhbmNlICs9IDEgLSBNYXRoLmFicyhtYWxlQ291bnQgLSBmZW1hbGVDb3VudCkgLyBncm91cE1lbWJlcnMubGVuZ3RoXG4gICAgICB0b3RhbE1idGlCYWxhbmNlICs9IDEgLSBNYXRoLmFicyhleHRyb3ZlcnRDb3VudCAtIGludHJvdmVydENvdW50KSAvIGdyb3VwTWVtYmVycy5sZW5ndGhcbiAgICB9XG4gICAgXG4gICAgLy8g66qo65OgIOq3uOujueydhCDtj6ztlaggKOu5iCDqt7jro7nrj4Qg7Y+s7ZWoKVxuICAgIGZpbmFsR3JvdXBzLnB1c2goe1xuICAgICAgaWQ6IGluZGV4ICsgMSxcbiAgICAgIG1lbWJlcnM6IGdyb3VwTWVtYmVycyxcbiAgICAgIG1hbGVDb3VudCxcbiAgICAgIGZlbWFsZUNvdW50LFxuICAgICAgZXh0cm92ZXJ0Q291bnQsXG4gICAgICBpbnRyb3ZlcnRDb3VudFxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBncm91cHM6IGZpbmFsR3JvdXBzLFxuICAgIHJvdW5kOiBjdXJyZW50Um91bmQsXG4gICAgc3VtbWFyeToge1xuICAgICAgdG90YWxHcm91cHM6IGZpbmFsR3JvdXBzLmxlbmd0aCxcbiAgICAgIGF2Z0dyb3VwU2l6ZTogcGFydGljaXBhbnRzLmxlbmd0aCAvIGZpbmFsR3JvdXBzLmxlbmd0aCxcbiAgICAgIGdlbmRlckJhbGFuY2VTY29yZTogTWF0aC5yb3VuZCgodG90YWxHZW5kZXJCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCksXG4gICAgICBtYnRpQmFsYW5jZVNjb3JlOiBNYXRoLnJvdW5kKCh0b3RhbE1idGlCYWxhbmNlIC8gZmluYWxHcm91cHMubGVuZ3RoKSAqIDEwMCksXG4gICAgICBuZXdNZWV0aW5nc0NvdW50OiBuZXdNZWV0aW5nc1RvdGFsXG4gICAgfVxuICB9XG59XG5cbi8vIOunjOuCqCDtnojsiqTthqDrpqwg7JeF642w7J207Yq4XG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWVldGluZ0hpc3RvcnkoXG4gIHBhcnRpY2lwYW50czogUGFydGljaXBhbnRbXSwgXG4gIGdyb3VwczogR3JvdXBbXSwgXG4gIHJvdW5kOiBudW1iZXJcbik6IFBhcnRpY2lwYW50W10ge1xuICBjb25zdCB1cGRhdGVkUGFydGljaXBhbnRzID0gcGFydGljaXBhbnRzLm1hcChwID0+ICh7XG4gICAgLi4ucCxcbiAgICBtZXRQZW9wbGU6IFsuLi4ocC5tZXRQZW9wbGUgfHwgW10pXSxcbiAgICBncm91cEhpc3Rvcnk6IFsuLi4ocC5ncm91cEhpc3RvcnkgfHwgW10pXVxuICB9KSlcblxuICAvLyDqsIEg6re466O5IOuCtCDssLjqsIDsnpDrk6TsnZgg66eM64KoIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgZ3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgIC8vIOq3uOujuSDrsojtmLgg7Z6I7Iqk7Yag66asIOyXheuNsOydtO2KuFxuICAgIGdyb3VwLm1lbWJlcnMuZm9yRWFjaChtZW1iZXIgPT4ge1xuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBtZW1iZXIuaWQpXG4gICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgcGFydGljaXBhbnQuZ3JvdXBIaXN0b3J5IS5wdXNoKGdyb3VwLmlkKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyDshJzroZwg66eM64KcIOq4sOuhnSDsl4XrjbDsnbTtirhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGdyb3VwLm1lbWJlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgcDEgPSB1cGRhdGVkUGFydGljaXBhbnRzLmZpbmQocCA9PiBwLmlkID09PSBncm91cC5tZW1iZXJzW2ldLmlkKVxuICAgICAgICBjb25zdCBwMiA9IHVwZGF0ZWRQYXJ0aWNpcGFudHMuZmluZChwID0+IHAuaWQgPT09IGdyb3VwLm1lbWJlcnNbal0uaWQpXG4gICAgICAgIFxuICAgICAgICBpZiAocDEgJiYgcDIpIHtcbiAgICAgICAgICBpZiAoIXAxLm1ldFBlb3BsZSEuaW5jbHVkZXMocDIuaWQpKSB7XG4gICAgICAgICAgICBwMS5tZXRQZW9wbGUhLnB1c2gocDIuaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcDIubWV0UGVvcGxlIS5pbmNsdWRlcyhwMS5pZCkpIHtcbiAgICAgICAgICAgIHAyLm1ldFBlb3BsZSEucHVzaChwMS5pZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRQYXJ0aWNpcGFudHNcbn0iXSwibmFtZXMiOlsiaGF2ZU1ldCIsInAxIiwicDIiLCJtZXRQZW9wbGUiLCJpbmNsdWRlcyIsImlkIiwiY2FsY3VsYXRlR3JvdXBCYWxhbmNlIiwiZ3JvdXAiLCJtYWxlQ291bnQiLCJmaWx0ZXIiLCJwIiwiZ2VuZGVyIiwibGVuZ3RoIiwiZmVtYWxlQ291bnQiLCJleHRyb3ZlcnRDb3VudCIsIm1idGkiLCJpbnRyb3ZlcnRDb3VudCIsImdlbmRlckJhbGFuY2UiLCJNYXRoIiwiYWJzIiwibWJ0aUJhbGFuY2UiLCJuZXdNZWV0aW5ncyIsInRvdGFsUGFpcnMiLCJpIiwiaiIsIm5ld01lZXRpbmdTY29yZSIsInNob3VsZEF2b2lkR3JvdXBOdW1iZXIiLCJwYXJ0aWNpcGFudCIsImdyb3VwTnVtYmVyIiwiaGlzdG9yeSIsImdyb3VwSGlzdG9yeSIsImNyZWF0ZU9wdGltYWxHcm91cHMiLCJwYXJ0aWNpcGFudHMiLCJncm91cFNpemUiLCJjdXJyZW50Um91bmQiLCJFcnJvciIsIm51bUdyb3VwcyIsImNlaWwiLCJncm91cHMiLCJBcnJheSIsImZyb20iLCJmb3JFYWNoIiwiaW5kZXgiLCJncm91cEluZGV4IiwicHVzaCIsIm9wdGltaXplR3JvdXBzIiwiZmluYWxHcm91cHMiLCJtYXAiLCJncm91cE1lbWJlcnMiLCJtZW1iZXJzIiwibmV3TWVldGluZ3NUb3RhbCIsInRvdGFsR2VuZGVyQmFsYW5jZSIsInRvdGFsTWJ0aUJhbGFuY2UiLCJyb3VuZCIsInN1bW1hcnkiLCJ0b3RhbEdyb3VwcyIsImF2Z0dyb3VwU2l6ZSIsImdlbmRlckJhbGFuY2VTY29yZSIsIm1idGlCYWxhbmNlU2NvcmUiLCJuZXdNZWV0aW5nc0NvdW50IiwiaXRlcmF0aW9ucyIsImltcHJvdmVkIiwiZ3JvdXAxIiwiZ3JvdXAyIiwiZzFNYWxlcyIsImcxRmVtYWxlcyIsImcyTWFsZXMiLCJnMkZlbWFsZXMiLCJ0ZW1wIiwibmV3RzFNYWxlcyIsIm5ld0cxRmVtYWxlcyIsIm5ld0cyTWFsZXMiLCJuZXdHMkZlbWFsZXMiLCJvbGRJbWJhbGFuY2UiLCJuZXdJbWJhbGFuY2UiLCJ0ZW1wMiIsImNyZWF0ZUluZGl2aWR1YWwiLCJpbmRpdmlkdWFsIiwiZ3JvdXBTaXplcyIsImZpbGwiLCJhdHRlbXB0cyIsImZsb29yIiwicmFuZG9tIiwiaW5kZXhPZiIsIm1pbiIsImNhbGN1bGF0ZUZpdG5lc3MiLCJwYXJ0aWNpcGFudEluZGV4IiwidG90YWxTY29yZSIsInZhbGlkR3JvdXBzIiwiY3Jvc3NvdmVyIiwicGFyZW50MSIsInBhcmVudDIiLCJjaGlsZCIsImNyb3Nzb3ZlclBvaW50IiwibXV0YXRlIiwibXV0YXRlZCIsIm11dGF0aW9uUmF0ZSIsIm5ld0dyb3VwIiwicG9wdWxhdGlvbiIsInBvcHVsYXRpb25TaXplIiwiZ2VuZXJhdGlvbiIsImdlbmVyYXRpb25zIiwiZml0bmVzc1Njb3JlcyIsInNvcnRlZEluZGljZXMiLCJmaXRuZXNzIiwic29ydCIsImEiLCJiIiwiZWxpdGVTaXplIiwibmV3UG9wdWxhdGlvbiIsInNsaWNlIiwiaXRlbSIsInBhcmVudDFJbmRleCIsInBhcmVudDJJbmRleCIsImJlc3RJbmRleCIsIm1heCIsImJlc3RTb2x1dGlvbiIsImdyb3VwQXJyYXlzIiwidXBkYXRlTWVldGluZ0hpc3RvcnkiLCJ1cGRhdGVkUGFydGljaXBhbnRzIiwibWVtYmVyIiwiZmluZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/grouping.ts\n"));

/***/ })

});